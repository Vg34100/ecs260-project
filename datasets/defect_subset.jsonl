{"task_id": "defect/train/0", "input": "static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    /* init pix_fmts of codec */\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    /* init vda */\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    /* changes callback functions */\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    // force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    /* init H.264 decoder */\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n", "target": false}
{"task_id": "defect/train/1", "input": "static int transcode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     InputFile *input_files,\n\n                     int nb_input_files,\n\n                     StreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret = 0, i, j, k, n, nb_ostreams = 0, step;\n\n\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost, **ost_table = NULL;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int key;\n\n    int want_sdp = 1;\n\n    uint8_t no_packet[MAX_FILES]={0};\n\n    int no_packet_count=0;\n\n    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};\n\n    int nb_streams[AVMEDIA_TYPE_NB]={0};\n\n\n\n    if (rate_emu)\n\n        for (i = 0; i < nb_input_streams; i++)\n\n            input_streams[i].start = av_gettime();\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        fi = stream_maps[i].sync_file_index;\n\n        si = stream_maps[i].sync_stream_index;\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find sync stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            nb_streams[os->streams[i]->codec->codec_type]++;\n\n        }\n\n    }\n\n    for(step=1<<30; step; step>>=1){\n\n        int found_streams[AVMEDIA_TYPE_NB]={0};\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            nb_frame_threshold[j] += step;\n\n\n\n        for(j=0; j<nb_input_streams; j++) {\n\n            int skip=0;\n\n            ist = &input_streams[j];\n\n            if(opt_programid){\n\n                int pi,si;\n\n                AVFormatContext *f= input_files[ ist->file_index ].ctx;\n\n                skip=1;\n\n                for(pi=0; pi<f->nb_programs; pi++){\n\n                    AVProgram *p= f->programs[pi];\n\n                    if(p->id == opt_programid)\n\n                        for(si=0; si<p->nb_stream_indexes; si++){\n\n                            if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                skip=0;\n\n                        }\n\n                }\n\n            }\n\n            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip\n\n                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){\n\n                found_streams[ist->st->codec->codec_type]++;\n\n            }\n\n        }\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            if(found_streams[j] < nb_streams[j])\n\n                nb_frame_threshold[j] -= step;\n\n    }\n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            int found;\n\n            ost = ost_table[n] = output_streams_for_file[k][i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = input_files[stream_maps[n].file_index].ist_index +\n\n                    stream_maps[n].stream_index;\n\n\n\n                /* Sanity check that the stream types match */\n\n                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n\n                    int i= ost->file_index;\n\n                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n].file_index, stream_maps[n].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    ffmpeg_exit(1);\n\n                }\n\n\n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for (j = 0; j < nb_input_streams; j++) {\n\n                    int skip=0;\n\n                    ist = &input_streams[j];\n\n                    if(opt_programid){\n\n                        int pi,si;\n\n                        AVFormatContext *f = input_files[ist->file_index].ctx;\n\n                        skip=1;\n\n                        for(pi=0; pi<f->nb_programs; pi++){\n\n                            AVProgram *p= f->programs[pi];\n\n                            if(p->id == opt_programid)\n\n                                for(si=0; si<p->nb_stream_indexes; si++){\n\n                                    if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                        skip=0;\n\n                                }\n\n                        }\n\n                    }\n\n                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&\n\n                        ist->st->codec->codec_type == ost->st->codec->codec_type &&\n\n                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                            break;\n\n                    }\n\n                }\n\n\n\n                if (!found) {\n\n                    if(! opt_programid) {\n\n                        /* try again and reuse existing stream */\n\n                        for (j = 0; j < nb_input_streams; j++) {\n\n                            ist = &input_streams[j];\n\n                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type\n\n                                && ist->st->discard != AVDISCARD_ALL) {\n\n                                ost->source_index = j;\n\n                                found = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        int i= ost->file_index;\n\n                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = &input_streams[ost->source_index];\n\n            ist->discard = 0;\n\n            ost->sync_ist = (nb_stream_maps > 0) ?\n\n                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +\n\n                         stream_maps[n].sync_stream_index] : ist;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        os = output_files[ost->file_index];\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        if (metadata_streams_autocopy)\n\n            av_dict_copy(&ost->st->metadata, ist->st->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX)\n\n                goto fail;\n\n\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata)\n\n                goto fail;\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if(!ost->fifo)\n\n                    goto fail;\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels) {\n\n                    codec->channels = icodec->channels;\n\n                    codec->channel_layout = icodec->channel_layout;\n\n                }\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;\n\n                }\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method\n\n                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){\n\n                    av_log(os, AV_LOG_WARNING, \"Frame rate very high for a muxer not effciciently supporting it.\\n\"\n\n                                               \"Please consider specifiying a lower framerate, a different muxer or -vsync 2\\n\");\n\n                }\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            /* maximum video buffer size is 6-bytes per pixel, plus DPX header size */\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits/s as argument, not kbits/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec = ist->dec;\n\n            if (!codec)\n\n                codec = avcodec_find_decoder(ist->st->codec->codec_id);\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Decoder (codec id %d) not found for input stream #%d.%d\",\n\n                        ist->st->codec->codec_id, ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening decoder for input stream #%d.%d\",\n\n                        ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ist->st->codec, 0);\n\n            assert_avoptions(ost->opts);\n\n            //if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            //    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        AVStream *st;\n\n        ist = &input_streams[i];\n\n        st= ist->st;\n\n        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE / av_q2d(st->avg_frame_rate) : 0;\n\n        ist->next_pts = AV_NOPTS_VALUE;\n\n        ist->is_start = 1;\n\n    }\n\n\n\n    /* set meta data information from input file if required */\n\n    for (i=0;i<nb_meta_data_maps;i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            snprintf(error, sizeof(error), \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            ret = AVERROR(EINVAL);\\\n\n            goto dump_format;\\\n\n        }\n\n\n\n        int out_file_index = meta_data_maps[i][0].file;\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0 || out_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(out_file_index, nb_output_files, \"output file\")\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = output_files[out_file_index];\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy) {\n\n\n\n        for (i = 0; i < nb_output_files; i++)\n\n            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy chapters according to chapter maps */\n\n    for (i = 0; i < nb_chapter_maps; i++) {\n\n        int infile  = chapter_maps[i].in_file;\n\n        int outfile = chapter_maps[i].out_file;\n\n\n\n        if (infile < 0 || outfile < 0)\n\n            continue;\n\n        if (infile >= nb_input_files) {\n\n            snprintf(error, sizeof(error), \"Invalid input file index %d in chapter mapping.\\n\", infile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        if (outfile >= nb_output_files) {\n\n            snprintf(error, sizeof(error), \"Invalid output file index %d in chapter mapping.\\n\",outfile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        copy_chapters(infile, outfile);\n\n    }\n\n\n\n    /* copy chapters from the first input file that has them*/\n\n    if (!nb_chapter_maps)\n\n        for (i = 0; i < nb_input_files; i++) {\n\n            if (!input_files[i].ctx->nb_chapters)\n\n                continue;\n\n\n\n            for (j = 0; j < nb_output_files; j++)\n\n                if ((ret = copy_chapters(i, j)) < 0)\n\n                    goto dump_format;\n\n            break;\n\n        }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (avformat_write_header(os, &output_opts[i]) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_opts[i]);\n\n        if (strcmp(output_files[i]->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        goto fail;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    if (!using_stdin) {\n\n        if(verbose >= 0)\n\n            fprintf(stderr, \"Press [q] to stop, [?] for help\\n\");\n\n        avio_set_interrupt_cb(decode_interrupt_cb);\n\n    }\n\n    term_init();\n\n\n\n    timer_start = av_gettime();\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        double ipts_min;\n\n        double opts_min;\n\n\n\n    redo:\n\n        ipts_min= 1e100;\n\n        opts_min= 1e100;\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            if (q_pressed)\n\n                break;\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n            if (key == '+') verbose++;\n\n            if (key == '-') verbose--;\n\n            if (key == 's') qp_hist     ^= 1;\n\n            if (key == 'h'){\n\n                if (do_hex_dump){\n\n                    do_hex_dump = do_pkt_dump = 0;\n\n                } else if(do_pkt_dump){\n\n                    do_hex_dump = 1;\n\n                } else\n\n                    do_pkt_dump = 1;\n\n                av_log_set_level(AV_LOG_DEBUG);\n\n            }\n\n            if (key == 'd' || key == 'D'){\n\n                int debug=0;\n\n                if(key == 'D') {\n\n                    debug = input_streams[0].st->codec->debug<<1;\n\n                    if(!debug) debug = 1;\n\n                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n\n                        debug += debug;\n\n                }else\n\n                    scanf(\"%d\", &debug);\n\n                for(i=0;i<nb_input_streams;i++) {\n\n                    input_streams[i].st->codec->debug = debug;\n\n                }\n\n                for(i=0;i<nb_ostreams;i++) {\n\n                    ost = ost_table[i];\n\n                    ost->st->codec->debug = debug;\n\n                }\n\n                if(debug) av_log_set_level(AV_LOG_DEBUG);\n\n                fprintf(stderr,\"debug=%d\\n\", debug);\n\n            }\n\n            if (key == '?'){\n\n                fprintf(stderr, \"key    function\\n\"\n\n                                \"?      show this help\\n\"\n\n                                \"+      increase verbosity\\n\"\n\n                                \"-      decrease verbosity\\n\"\n\n                                \"D      cycle through available debug modes\\n\"\n\n                                \"h      dump packets/hex press to cycle through the 3 states\\n\"\n\n                                \"q      quit\\n\"\n\n                                \"s      Show QP histogram\\n\"\n\n                );\n\n            }\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double ipts, opts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = &input_streams[ost->source_index];\n\n            if(ist->is_past_recording_time || no_packet[ist->file_index])\n\n                continue;\n\n                opts = ost->st->pts.val * av_q2d(ost->st->time_base);\n\n            ipts = (double)ist->pts;\n\n            if (!input_files[ist->file_index].eof_reached){\n\n                if(ipts < ipts_min) {\n\n                    ipts_min = ipts;\n\n                    if(input_sync ) file_index = ist->file_index;\n\n                }\n\n                if(opts < opts_min) {\n\n                    opts_min = opts;\n\n                    if(!input_sync) file_index = ist->file_index;\n\n                }\n\n            }\n\n            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){\n\n                file_index= -1;\n\n                break;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            if(no_packet_count){\n\n                no_packet_count=0;\n\n                memset(no_packet, 0, sizeof(no_packet));\n\n                usleep(10000);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* finish if limit size exhausted */\n\n        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))\n\n            break;\n\n\n\n        /* read a frame from it and output it in the fifo */\n\n        is = input_files[file_index].ctx;\n\n        ret= av_read_frame(is, &pkt);\n\n        if(ret == AVERROR(EAGAIN)){\n\n            no_packet[file_index]=1;\n\n            no_packet_count++;\n\n            continue;\n\n        }\n\n        if (ret < 0) {\n\n            input_files[file_index].eof_reached = 1;\n\n            if (opt_shortest)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        no_packet_count=0;\n\n        memset(no_packet, 0, sizeof(no_packet));\n\n\n\n        if (do_pkt_dump) {\n\n            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n\n                             is->streams[pkt.stream_index]);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)\n\n            goto discard_packet;\n\n        ist_index = input_files[file_index].ist_index + pkt.stream_index;\n\n        ist = &input_streams[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        if (pkt.dts != AV_NOPTS_VALUE)\n\n            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n\n\n        if (ist->ts_scale) {\n\n            if(pkt.pts != AV_NOPTS_VALUE)\n\n                pkt.pts *= ist->ts_scale;\n\n            if(pkt.dts != AV_NOPTS_VALUE)\n\n                pkt.dts *= ist->ts_scale;\n\n        }\n\n\n\n//        fprintf(stderr, \"next:%\"PRId64\" dts:%\"PRId64\" off:%\"PRId64\" %d\\n\", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);\n\n        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE\n\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n\n            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            int64_t delta= pkt_dts - ist->next_pts;\n\n            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){\n\n                input_files[ist->file_index].ts_offset -= delta;\n\n                if (verbose > 2)\n\n                    fprintf(stderr, \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n\n                            delta, input_files[ist->file_index].ts_offset);\n\n                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n                if(pkt.pts != AV_NOPTS_VALUE)\n\n                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n            }\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time != INT64_MAX &&\n\n            (pkt.pts != AV_NOPTS_VALUE ?\n\n                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})\n\n                    :\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})\n\n            )>= 0) {\n\n            ist->is_past_recording_time = 1;\n\n            goto discard_packet;\n\n        }\n\n\n\n        //fprintf(stderr,\"read #%d.%d size=%d\\n\", ist->file_index, ist->st->index, pkt.size);\n\n        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n\n\n\n            if (verbose >= 0)\n\n                fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                        ist->file_index, ist->st->index);\n\n            if (exit_on_error)\n\n                ffmpeg_exit(1);\n\n            av_free_packet(&pkt);\n\n            goto redo;\n\n        }\n\n\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n\n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n\n\n    /* at the end of stream, we must flush the decoder buffers */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            output_packet(ist, i, ost_table, nb_ostreams, NULL);\n\n        }\n\n    }\n\n\n\n    term_exit();\n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec->stats_in);\n\n            avcodec_close(ost->st->codec);\n\n        }\n\n#if CONFIG_AVFILTER\n\n        avfilter_graph_free(&ost->graph);\n\n#endif\n\n    }\n\n\n\n    /* close each decoder */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(ist->st->codec);\n\n        }\n\n    }\n\n\n\n    /* finished ! */\n\n    ret = 0;\n\n\n\n fail:\n\n    av_freep(&bit_buffer);\n\n\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->st->stream_copy)\n\n                    av_freep(&ost->st->codec->extradata);\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                av_fifo_free(ost->fifo); /* works even if fifo is not\n\n                                             initialized but set to zero */\n\n                av_freep(&ost->st->codec->subtitle_header);\n\n                av_free(ost->resample_frame.data[0]);\n\n                av_free(ost->forced_kf_pts);\n\n                if (ost->video_resample)\n\n                    sws_freeContext(ost->img_resample_ctx);\n\n                if (ost->resample)\n\n                    audio_resample_close(ost->resample);\n\n                if (ost->reformat_ctx)\n\n                    av_audio_convert_free(ost->reformat_ctx);\n\n                av_dict_free(&ost->opts);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/2", "input": "static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/3", "input": "int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/4", "input": "static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) / 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/5", "input": "static int dds_decode(AVCodecContext *avctx, void *data,\n\n                      int *got_frame, AVPacket *avpkt)\n\n{\n\n    DDSContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    AVFrame *frame = data;\n\n    int mipmap;\n\n    int ret;\n\n\n\n    ff_texturedsp_init(&ctx->texdsp);\n\n    bytestream2_init(gbc, avpkt->data, avpkt->size);\n\n\n\n    if (bytestream2_get_bytes_left(gbc) < 128) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small (%d).\\n\",\n\n               bytestream2_get_bytes_left(gbc));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||\n\n        bytestream2_get_le32(gbc) != 124) { // header size\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid DDS header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(gbc, 4); // flags\n\n\n\n    avctx->height = bytestream2_get_le32(gbc);\n\n    avctx->width  = bytestream2_get_le32(gbc);\n\n    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size %dx%d.\\n\",\n\n               avctx->width, avctx->height);\n\n        return ret;\n\n    }\n\n\n\n    /* Since codec is based on 4x4 blocks, size is aligned to 4. */\n\n    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);\n\n    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);\n\n\n\n    bytestream2_skip(gbc, 4); // pitch\n\n    bytestream2_skip(gbc, 4); // depth\n\n    mipmap = bytestream2_get_le32(gbc);\n\n    if (mipmap != 0)\n\n        av_log(avctx, AV_LOG_VERBOSE, \"Found %d mipmaps (ignored).\\n\", mipmap);\n\n\n\n    /* Extract pixel format information, considering additional elements\n\n     * in reserved1 and reserved2. */\n\n    ret = parse_pixel_format(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = ff_get_buffer(avctx, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (ctx->compressed) {\n\n        int size = (avctx->coded_height / TEXTURE_BLOCK_H) *\n\n                   (avctx->coded_width / TEXTURE_BLOCK_W) * ctx->tex_ratio;\n\n        ctx->slice_count = av_clip(avctx->thread_count, 1,\n\n                                   avctx->coded_height / TEXTURE_BLOCK_H);\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < size) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Compressed Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* Use the decompress function on the texture, one block per thread. */\n\n        ctx->tex_data = gbc->buffer;\n\n        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);\n\n    } else if (!ctx->paletted && ctx->bpp == 4 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n\n        uint8_t *dst = frame->data[0];\n\n        int x, y, i;\n\n\n\n        /* Use the first 64 bytes as palette, then copy the rest. */\n\n        bytestream2_get_buffer(gbc, frame->data[1], 16 * 4);\n\n        for (i = 0; i < 16; i++) {\n\n            AV_WN32(frame->data[1] + i*4,\n\n                    (frame->data[1][2+i*4]<<0)+\n\n                    (frame->data[1][1+i*4]<<8)+\n\n                    (frame->data[1][0+i*4]<<16)+\n\n                    (frame->data[1][3+i*4]<<24)\n\n            );\n\n        }\n\n        frame->palette_has_changed = 1;\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * frame->width / 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * frame->width / 2);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (y = 0; y < frame->height; y++) {\n\n            for (x = 0; x < frame->width; x += 2) {\n\n                uint8_t val = bytestream2_get_byte(gbc);\n\n                dst[x    ] = val & 0xF;\n\n                dst[x + 1] = val >> 4;\n\n            }\n\n            dst += frame->linesize[0];\n\n        }\n\n    } else {\n\n        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);\n\n\n\n        if (ctx->paletted) {\n\n            int i;\n\n            /* Use the first 1024 bytes as palette, then copy the rest. */\n\n            bytestream2_get_buffer(gbc, frame->data[1], 256 * 4);\n\n            for (i = 0; i < 256; i++)\n\n                AV_WN32(frame->data[1] + i*4,\n\n                        (frame->data[1][2+i*4]<<0)+\n\n                        (frame->data[1][1+i*4]<<8)+\n\n                        (frame->data[1][0+i*4]<<16)+\n\n                        (frame->data[1][3+i*4]<<24)\n\n                );\n\n\n\n            frame->palette_has_changed = 1;\n\n        }\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * linesize);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        av_image_copy_plane(frame->data[0], frame->linesize[0],\n\n                            gbc->buffer, linesize,\n\n                            linesize, frame->height);\n\n    }\n\n\n\n    /* Run any post processing here if needed. */\n\n    if (ctx->postproc != DDS_NONE)\n\n        run_postproc(avctx, frame);\n\n\n\n    /* Frame is ready to be output. */\n\n    frame->pict_type = AV_PICTURE_TYPE_I;\n\n    frame->key_frame = 1;\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "target": true}
{"task_id": "defect/train/6", "input": "static void check_lowpass_line(int depth){\n\n    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);\n\n    int w = WIDTH;\n\n    int mref = WIDTH_PADDED * -1;\n\n    int pref = WIDTH_PADDED;\n\n    int i, depth_byte;\n\n    InterlaceContext s;\n\n\n\n    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,\n\n                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);\n\n\n\n    s.lowpass = 1;\n\n    s.lowpass = VLPF_LIN;\n\n    depth_byte = depth >> 3;\n\n    w /= depth_byte;\n\n\n\n    memset(src,     0, SRC_SIZE);\n\n    memset(dst_ref, 0, WIDTH_PADDED);\n\n    memset(dst_new, 0, WIDTH_PADDED);\n\n    randomize_buffers(src, SRC_SIZE);\n\n\n\n    ff_interlace_init(&s, depth);\n\n\n\n    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {\n\n        for (i = 0; i < 32; i++) { /* simulate crop */\n\n            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            if (memcmp(dst_ref, dst_new, WIDTH - i))\n\n                fail();\n\n        }\n\n        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/7", "input": "static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    /* set ACPI PM I/O space base address */\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    /* enable ACPI I/O */\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    /* set Root Complex BAR */\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n", "target": true}
{"task_id": "defect/train/8", "input": "void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/9", "input": "static void nbd_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *saddr_qdict;\n\n    Visitor *ov;\n\n    const char *host = NULL, *port = NULL, *path = NULL;\n\n\n\n    if (s->saddr->type == SOCKET_ADDRESS_KIND_INET) {\n\n        const InetSocketAddress *inet = s->saddr->u.inet.data;\n\n        if (!inet->has_ipv4 && !inet->has_ipv6 && !inet->has_to) {\n\n            host = inet->host;\n\n            port = inet->port;\n\n        }\n\n    } else if (s->saddr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        path = s->saddr->u.q_unix.data->path;\n\n    }\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nbd\"));\n\n\n\n    if (path && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix:///%s?socket=%s\", s->export, path);\n\n    } else if (path && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix://?socket=%s\", path);\n\n    } else if (host && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s/%s\", host, port, s->export);\n\n    } else if (host && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s\", host, port);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&saddr_qdict);\n\n    visit_type_SocketAddress(ov, NULL, &s->saddr, &error_abort);\n\n    visit_complete(ov, &saddr_qdict);\n\n\n    assert(qobject_type(saddr_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", saddr_qdict);\n\n\n\n    if (s->export) {\n\n        qdict_put(opts, \"export\", qstring_from_str(s->export));\n\n    }\n\n    if (s->tlscredsid) {\n\n        qdict_put(opts, \"tls-creds\", qstring_from_str(s->tlscredsid));\n\n    }\n\n\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}", "target": true}
{"task_id": "defect/train/10", "input": "int net_init_tap(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    const char *ifname;\n\n\n\n    ifname = qemu_opt_get(opts, \"ifname\");\n\n\n\n    if (!ifname) {\n\n        error_report(\"tap: no interface name\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap_win32_init(vlan, \"tap\", name, ifname) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/11", "input": "print_insn (bfd_vma pc, disassemble_info *info)\n\n{\n\n  const struct dis386 *dp;\n\n  int i;\n\n  char *op_txt[MAX_OPERANDS];\n\n  int needcomma;\n\n  unsigned char uses_DATA_prefix, uses_LOCK_prefix;\n\n  unsigned char uses_REPNZ_prefix, uses_REPZ_prefix;\n\n  int sizeflag;\n\n  const char *p;\n\n  struct dis_private priv;\n\n  unsigned char op;\n\n  unsigned char threebyte;\n\n\n\n  if (info->mach == bfd_mach_x86_64_intel_syntax\n\n      || info->mach == bfd_mach_x86_64)\n\n    address_mode = mode_64bit;\n\n  else\n\n    address_mode = mode_32bit;\n\n\n\n  if (intel_syntax == (char) -1)\n\n    intel_syntax = (info->mach == bfd_mach_i386_i386_intel_syntax\n\n\t\t    || info->mach == bfd_mach_x86_64_intel_syntax);\n\n\n\n  if (info->mach == bfd_mach_i386_i386\n\n      || info->mach == bfd_mach_x86_64\n\n      || info->mach == bfd_mach_i386_i386_intel_syntax\n\n      || info->mach == bfd_mach_x86_64_intel_syntax)\n\n    priv.orig_sizeflag = AFLAG | DFLAG;\n\n  else if (info->mach == bfd_mach_i386_i8086)\n\n    priv.orig_sizeflag = 0;\n\n  else\n\n    abort ();\n\n\n\n  for (p = info->disassembler_options; p != NULL; )\n\n    {\n\n      if (strncmp (p, \"x86-64\", 6) == 0)\n\n\t{\n\n\t  address_mode = mode_64bit;\n\n\t  priv.orig_sizeflag = AFLAG | DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"i386\", 4) == 0)\n\n\t{\n\n\t  address_mode = mode_32bit;\n\n\t  priv.orig_sizeflag = AFLAG | DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"i8086\", 5) == 0)\n\n\t{\n\n\t  address_mode = mode_16bit;\n\n\t  priv.orig_sizeflag = 0;\n\n\t}\n\n      else if (strncmp (p, \"intel\", 5) == 0)\n\n\t{\n\n\t  intel_syntax = 1;\n\n\t}\n\n      else if (strncmp (p, \"att\", 3) == 0)\n\n\t{\n\n\t  intel_syntax = 0;\n\n\t}\n\n      else if (strncmp (p, \"addr\", 4) == 0)\n\n\t{\n\n\t  if (address_mode == mode_64bit)\n\n\t    {\n\n\t      if (p[4] == '3' && p[5] == '2')\n\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\n\t      else if (p[4] == '6' && p[5] == '4')\n\n\t\tpriv.orig_sizeflag |= AFLAG;\n\n\t    }\n\n\t  else\n\n\t    {\n\n\t      if (p[4] == '1' && p[5] == '6')\n\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\n\t      else if (p[4] == '3' && p[5] == '2')\n\n\t\tpriv.orig_sizeflag |= AFLAG;\n\n\t    }\n\n\t}\n\n      else if (strncmp (p, \"data\", 4) == 0)\n\n\t{\n\n\t  if (p[4] == '1' && p[5] == '6')\n\n\t    priv.orig_sizeflag &= ~DFLAG;\n\n\t  else if (p[4] == '3' && p[5] == '2')\n\n\t    priv.orig_sizeflag |= DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"suffix\", 6) == 0)\n\n\tpriv.orig_sizeflag |= SUFFIX_ALWAYS;\n\n\n\n      p = strchr (p, ',');\n\n      if (p != NULL)\n\n\tp++;\n\n    }\n\n\n\n  if (intel_syntax)\n\n    {\n\n      names64 = intel_names64;\n\n      names32 = intel_names32;\n\n      names16 = intel_names16;\n\n      names8 = intel_names8;\n\n      names8rex = intel_names8rex;\n\n      names_seg = intel_names_seg;\n\n      index16 = intel_index16;\n\n      open_char = '[';\n\n      close_char = ']';\n\n      separator_char = '+';\n\n      scale_char = '*';\n\n    }\n\n  else\n\n    {\n\n      names64 = att_names64;\n\n      names32 = att_names32;\n\n      names16 = att_names16;\n\n      names8 = att_names8;\n\n      names8rex = att_names8rex;\n\n      names_seg = att_names_seg;\n\n      index16 = att_index16;\n\n      open_char = '(';\n\n      close_char =  ')';\n\n      separator_char = ',';\n\n      scale_char = ',';\n\n    }\n\n\n\n  /* The output looks better if we put 7 bytes on a line, since that\n\n     puts most long word instructions on a single line.  */\n\n  info->bytes_per_line = 7;\n\n\n\n  info->private_data = &priv;\n\n  priv.max_fetched = priv.the_buffer;\n\n  priv.insn_start = pc;\n\n\n\n  obuf[0] = 0;\n\n  for (i = 0; i < MAX_OPERANDS; ++i)\n\n    {\n\n      op_out[i][0] = 0;\n\n      op_index[i] = -1;\n\n    }\n\n\n\n  the_info = info;\n\n  start_pc = pc;\n\n  start_codep = priv.the_buffer;\n\n  codep = priv.the_buffer;\n\n\n\n  if (sigsetjmp(priv.bailout, 0) != 0)\n\n    {\n\n      const char *name;\n\n\n\n      /* Getting here means we tried for data but didn't get it.  That\n\n\t means we have an incomplete instruction of some sort.  Just\n\n\t print the first byte as a prefix or a .byte pseudo-op.  */\n\n      if (codep > priv.the_buffer)\n\n\t{\n\n\t  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n\t  if (name != NULL)\n\n\t    (*info->fprintf_func) (info->stream, \"%s\", name);\n\n\t  else\n\n\t    {\n\n\t      /* Just print the first byte as a .byte instruction.  */\n\n\t      (*info->fprintf_func) (info->stream, \".byte 0x%x\",\n\n\t\t\t\t     (unsigned int) priv.the_buffer[0]);\n\n\t    }\n\n\n\n\t  return 1;\n\n\t}\n\n\n\n      return -1;\n\n    }\n\n\n\n  obufp = obuf;\n\n  ckprefix ();\n\n  ckvexprefix ();\n\n\n\n  insn_codep = codep;\n\n  sizeflag = priv.orig_sizeflag;\n\n\n\n  fetch_data(info, codep + 1);\n\n  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);\n\n\n\n  if (((prefixes & PREFIX_FWAIT)\n\n       && ((*codep < 0xd8) || (*codep > 0xdf)))\n\n      || (rex && rex_used))\n\n    {\n\n      const char *name;\n\n\n\n      /* fwait not followed by floating point instruction, or rex followed\n\n\t by other prefixes.  Print the first prefix.  */\n\n      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s\", name);\n\n      return 1;\n\n    }\n\n\n\n  op = 0;\n\n  if (prefixes & PREFIX_VEX_0F)\n\n    {\n\n      used_prefixes |= PREFIX_VEX_0F | PREFIX_VEX_0F38 | PREFIX_VEX_0F3A;\n\n      if (prefixes & PREFIX_VEX_0F38)\n\n        threebyte = 0x38;\n\n      else if (prefixes & PREFIX_VEX_0F3A)\n\n        threebyte = 0x3a;\n\n      else\n\n        threebyte = *codep++;\n\n      goto vex_opcode;\n\n    }\n\n  if (*codep == 0x0f)\n\n    {\n\n      fetch_data(info, codep + 2);\n\n      threebyte = codep[1];\n\n      codep += 2;\n\n    vex_opcode:\n\n      dp = &dis386_twobyte[threebyte];\n\n      need_modrm = twobyte_has_modrm[threebyte];\n\n      uses_DATA_prefix = twobyte_uses_DATA_prefix[threebyte];\n\n      uses_REPNZ_prefix = twobyte_uses_REPNZ_prefix[threebyte];\n\n      uses_REPZ_prefix = twobyte_uses_REPZ_prefix[threebyte];\n\n      uses_LOCK_prefix = (threebyte & ~0x02) == 0x20;\n\n      if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)\n\n\t{\n\n          fetch_data(info, codep + 2);\n\n\t  op = *codep++;\n\n\t  switch (threebyte)\n\n\t    {\n\n\t    case 0x38:\n\n\t      uses_DATA_prefix = threebyte_0x38_uses_DATA_prefix[op];\n\n\t      uses_REPNZ_prefix = threebyte_0x38_uses_REPNZ_prefix[op];\n\n\t      uses_REPZ_prefix = threebyte_0x38_uses_REPZ_prefix[op];\n\n\t      break;\n\n\t    case 0x3a:\n\n\t      uses_DATA_prefix = threebyte_0x3a_uses_DATA_prefix[op];\n\n\t      uses_REPNZ_prefix = threebyte_0x3a_uses_REPNZ_prefix[op];\n\n\t      uses_REPZ_prefix = threebyte_0x3a_uses_REPZ_prefix[op];\n\n\t      break;\n\n\t    default:\n\n\t      break;\n\n\t    }\n\n\t}\n\n    }\n\n  else\n\n    {\n\n      dp = &dis386[*codep];\n\n      need_modrm = onebyte_has_modrm[*codep];\n\n      uses_DATA_prefix = 0;\n\n      uses_REPNZ_prefix = 0;\n\n      /* pause is 0xf3 0x90.  */\n\n      uses_REPZ_prefix = *codep == 0x90;\n\n      uses_LOCK_prefix = 0;\n\n      codep++;\n\n    }\n\n\n\n  if (!uses_REPZ_prefix && (prefixes & PREFIX_REPZ))\n\n    {\n\n      oappend (\"repz \");\n\n      used_prefixes |= PREFIX_REPZ;\n\n    }\n\n  if (!uses_REPNZ_prefix && (prefixes & PREFIX_REPNZ))\n\n    {\n\n      oappend (\"repnz \");\n\n      used_prefixes |= PREFIX_REPNZ;\n\n    }\n\n\n\n  if (!uses_LOCK_prefix && (prefixes & PREFIX_LOCK))\n\n    {\n\n      oappend (\"lock \");\n\n      used_prefixes |= PREFIX_LOCK;\n\n    }\n\n\n\n  if (prefixes & PREFIX_ADDR)\n\n    {\n\n      sizeflag ^= AFLAG;\n\n      if (dp->op[2].bytemode != loop_jcxz_mode || intel_syntax)\n\n\t{\n\n\t  if ((sizeflag & AFLAG) || address_mode == mode_64bit)\n\n\t    oappend (\"addr32 \");\n\n\t  else\n\n\t    oappend (\"addr16 \");\n\n\t  used_prefixes |= PREFIX_ADDR;\n\n\t}\n\n    }\n\n\n\n  if (!uses_DATA_prefix && (prefixes & PREFIX_DATA))\n\n    {\n\n      sizeflag ^= DFLAG;\n\n      if (dp->op[2].bytemode == cond_jump_mode\n\n\t  && dp->op[0].bytemode == v_mode\n\n\t  && !intel_syntax)\n\n\t{\n\n\t  if (sizeflag & DFLAG)\n\n\t    oappend (\"data32 \");\n\n\t  else\n\n\t    oappend (\"data16 \");\n\n\t  used_prefixes |= PREFIX_DATA;\n\n\t}\n\n    }\n\n\n\n  if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)\n\n    {\n\n      dp = &three_byte_table[dp->op[1].bytemode][op];\n\n      modrm.mod = (*codep >> 6) & 3;\n\n      modrm.reg = (*codep >> 3) & 7;\n\n      modrm.rm = *codep & 7;\n\n    }\n\n  else if (need_modrm)\n\n    {\n\n      fetch_data(info, codep + 1);\n\n      modrm.mod = (*codep >> 6) & 3;\n\n      modrm.reg = (*codep >> 3) & 7;\n\n      modrm.rm = *codep & 7;\n\n    }\n\n\n\n  if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n\n    {\n\n      dofloat (sizeflag);\n\n    }\n\n  else\n\n    {\n\n      int index;\n\n      if (dp->name == NULL)\n\n\t{\n\n\t  switch (dp->op[0].bytemode)\n\n\t    {\n\n\t    case USE_GROUPS:\n\n\t      dp = &grps[dp->op[1].bytemode][modrm.reg];\n\n\t      break;\n\n\n\n\t    case USE_PREFIX_USER_TABLE:\n\n\t      index = 0;\n\n\t      used_prefixes |= (prefixes & PREFIX_REPZ);\n\n\t      if (prefixes & PREFIX_REPZ)\n\n\t\tindex = 1;\n\n\t      else\n\n\t\t{\n\n\t\t  /* We should check PREFIX_REPNZ and PREFIX_REPZ\n\n\t\t     before PREFIX_DATA.  */\n\n\t\t  used_prefixes |= (prefixes & PREFIX_REPNZ);\n\n\t\t  if (prefixes & PREFIX_REPNZ)\n\n\t\t    index = 3;\n\n\t\t  else\n\n\t\t    {\n\n\t\t      used_prefixes |= (prefixes & PREFIX_DATA);\n\n\t\t      if (prefixes & PREFIX_DATA)\n\n\t\t\tindex = 2;\n\n\t\t    }\n\n\t\t}\n\n\t      dp = &prefix_user_table[dp->op[1].bytemode][index];\n\n\t      break;\n\n\n\n\t    case X86_64_SPECIAL:\n\n\t      index = address_mode == mode_64bit ? 1 : 0;\n\n\t      dp = &x86_64_table[dp->op[1].bytemode][index];\n\n\t      break;\n\n\n\n\t    default:\n\n\t      oappend (INTERNAL_DISASSEMBLER_ERROR);\n\n\t      break;\n\n\t    }\n\n\t}\n\n\n\n      if (putop (dp->name, sizeflag) == 0)\n\n        {\n\n\t  for (i = 0; i < MAX_OPERANDS; ++i)\n\n\t    {\n\n\t      obufp = op_out[i];\n\n\t      op_ad = MAX_OPERANDS - 1 - i;\n\n\t      if (dp->op[i].rtn)\n\n\t\t(*dp->op[i].rtn) (dp->op[i].bytemode, sizeflag);\n\n\t    }\n\n\t}\n\n    }\n\n\n\n  /* See if any prefixes were not used.  If so, print the first one\n\n     separately.  If we don't do this, we'll wind up printing an\n\n     instruction stream which does not precisely correspond to the\n\n     bytes we are disassembling.  */\n\n  if ((prefixes & ~used_prefixes) != 0)\n\n    {\n\n      const char *name;\n\n\n\n      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s\", name);\n\n      return 1;\n\n    }\n\n  if (rex & ~rex_used)\n\n    {\n\n      const char *name;\n\n      name = prefix_name (rex | 0x40, priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s \", name);\n\n    }\n\n\n\n  obufp = obuf + strlen (obuf);\n\n  for (i = strlen (obuf); i < 6; i++)\n\n    oappend (\" \");\n\n  oappend (\" \");\n\n  (*info->fprintf_func) (info->stream, \"%s\", obuf);\n\n\n\n  /* The enter and bound instructions are printed with operands in the same\n\n     order as the intel book; everything else is printed in reverse order.  */\n\n  if (intel_syntax || two_source_ops)\n\n    {\n\n      bfd_vma riprel;\n\n\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\n        op_txt[i] = op_out[i];\n\n\n\n      for (i = 0; i < (MAX_OPERANDS >> 1); ++i)\n\n\t{\n\n          op_ad = op_index[i];\n\n          op_index[i] = op_index[MAX_OPERANDS - 1 - i];\n\n          op_index[MAX_OPERANDS - 1 - i] = op_ad;\n\n\t  riprel = op_riprel[i];\n\n\t  op_riprel[i] = op_riprel [MAX_OPERANDS - 1 - i];\n\n\t  op_riprel[MAX_OPERANDS - 1 - i] = riprel;\n\n\t}\n\n    }\n\n  else\n\n    {\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\n        op_txt[MAX_OPERANDS - 1 - i] = op_out[i];\n\n    }\n\n\n\n  needcomma = 0;\n\n  for (i = 0; i < MAX_OPERANDS; ++i)\n\n    if (*op_txt[i])\n\n      {\n\n\tif (needcomma)\n\n\t  (*info->fprintf_func) (info->stream, \",\");\n\n\tif (op_index[i] != -1 && !op_riprel[i])\n\n\t  (*info->print_address_func) ((bfd_vma) op_address[op_index[i]], info);\n\n\telse\n\n\t  (*info->fprintf_func) (info->stream, \"%s\", op_txt[i]);\n\n\tneedcomma = 1;\n\n      }\n\n\n\n  for (i = 0; i < MAX_OPERANDS; i++)\n\n    if (op_index[i] != -1 && op_riprel[i])\n\n      {\n\n\t(*info->fprintf_func) (info->stream, \"        # \");\n\n\t(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep\n\n\t\t\t\t\t\t+ op_address[op_index[i]]), info);\n\n\tbreak;\n\n      }\n\n  return codep - priv.the_buffer;\n\n}\n", "target": true}
{"task_id": "defect/train/12", "input": "static void vp6_parse_coeff_huffman(VP56Context *s)\n\n{\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->scantable.permutated;\n\n    VLC *vlc_coeff;\n\n    int coeff, sign, coeff_idx;\n\n    int b, cg, idx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 0;    /* code type */\n\n        if (b > 3) pt = 1;\n\n        vlc_coeff = &s->dccv_vlc[pt];\n\n\n\n        for (coeff_idx=0; coeff_idx<64; ) {\n\n            int run = 1;\n\n            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {\n\n                s->nb_null[coeff_idx][pt]--;\n\n                if (coeff_idx)\n\n                    break;\n\n            } else {\n\n                if (get_bits_count(&s->gb) >= s->gb.size_in_bits)\n\n                    return;\n\n                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);\n\n                if (coeff == 0) {\n\n                    if (coeff_idx) {\n\n                        int pt = (coeff_idx >= 6);\n\n                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);\n\n                        if (run >= 9)\n\n                            run += get_bits(&s->gb, 6);\n\n                    } else\n\n                        s->nb_null[0][pt] = vp6_get_nb_null(s);\n\n                    ct = 0;\n\n                } else if (coeff == 11) {  /* end of block */\n\n                    if (coeff_idx == 1)    /* first AC coeff ? */\n\n                        s->nb_null[1][pt] = vp6_get_nb_null(s);\n\n                    break;\n\n                } else {\n\n                    int coeff2 = vp56_coeff_bias[coeff];\n\n                    if (coeff > 4)\n\n                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);\n\n                    ct = 1 + (coeff2 > 1);\n\n                    sign = get_bits1(&s->gb);\n\n                    coeff2 = (coeff2 ^ -sign) + sign;\n\n                    if (coeff_idx)\n\n                        coeff2 *= s->dequant_ac;\n\n                    idx = model->coeff_index_to_pos[coeff_idx];\n\n                    s->block_coeff[b][permute[idx]] = coeff2;\n\n                }\n\n            }\n\n            coeff_idx+=run;\n\n            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);\n\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n\n        }\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/13", "input": "static int vncws_start_tls_handshake(VncState *vs)\n\n{\n\n    int ret = gnutls_handshake(vs->tls.session);\n\n\n\n    if (ret < 0) {\n\n        if (!gnutls_error_is_fatal(ret)) {\n\n            VNC_DEBUG(\"Handshake interrupted (blocking)\\n\");\n\n            if (!gnutls_record_get_direction(vs->tls.session)) {\n\n                qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io,\n\n                                    NULL, vs);\n\n            } else {\n\n                qemu_set_fd_handler(vs->csock, NULL, vncws_tls_handshake_io,\n\n                                    vs);\n\n            }\n\n            return 0;\n\n        }\n\n        VNC_DEBUG(\"Handshake failed %s\\n\", gnutls_strerror(ret));\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (vs->vd->tls.x509verify) {\n\n        if (vnc_tls_validate_certificate(vs) < 0) {\n\n            VNC_DEBUG(\"Client verification failed\\n\");\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        } else {\n\n            VNC_DEBUG(\"Client verification passed\\n\");\n\n        }\n\n    }\n\n\n\n    VNC_DEBUG(\"Handshake done, switching to TLS data mode\\n\");\n\n    qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/14", "input": "av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "target": false}
{"task_id": "defect/train/15", "input": "static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    char *backing_file = NULL;\n\n    char *backing_fmt = NULL;\n\n    char *buf = NULL;\n\n    uint64_t size = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    PreallocMode prealloc;\n\n    int version;\n\n    uint64_t refcount_bits;\n\n    int refcount_order;\n\n    const char *encryptfmt = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    /* Read out options */\n\n    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                    BDRV_SECTOR_SIZE);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);\n\n    encryptfmt = qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT_FORMAT);\n\n    if (encryptfmt) {\n\n        if (qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT)) {\n\n            error_setg(errp, \"Options \" BLOCK_OPT_ENCRYPT \" and \"\n\n                       BLOCK_OPT_ENCRYPT_FORMAT \" are mutually exclusive\");\n\n            ret = -EINVAL;\n\n            goto finish;\n\n        }\n\n    } else if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        encryptfmt = \"aes\";\n\n    }\n\n    cluster_size = qcow2_opt_get_cluster_size_del(opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    version = qcow2_opt_get_version_del(opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n\n        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;\n\n    }\n\n\n\n    if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n\n        error_setg(errp, \"Backing file and preallocation cannot be used at \"\n\n                   \"the same time\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {\n\n        error_setg(errp, \"Lazy refcounts only supported with compatibility \"\n\n                   \"level 1.1 and above (use compat=1.1 or greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_order = ctz32(refcount_bits);\n\n\n\n    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,\n\n                        cluster_size, prealloc, opts, version, refcount_order,\n\n                        encryptfmt, &local_err);\n\n    error_propagate(errp, local_err);\n\n\n\nfinish:\n\n    g_free(backing_file);\n\n    g_free(backing_fmt);\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "target": true}
{"task_id": "defect/train/16", "input": "static void quantize_mantissas(AC3EncodeContext *s)\n\n{\n\n    int blk, ch;\n\n\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        s->mant1_cnt  = s->mant2_cnt  = s->mant4_cnt  = 0;\n\n        s->qmant1_ptr = s->qmant2_ptr = s->qmant4_ptr = NULL;\n\n\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            quantize_mantissas_blk_ch(s, block->fixed_coef[ch], block->exp_shift[ch],\n\n                                      block->exp[ch], block->bap[ch],\n\n                                      block->qmant[ch], s->nb_coefs[ch]);\n\n        }\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/17", "input": "static void dma_blk_cb(void *opaque, int ret)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n    dma_addr_t cur_addr, cur_len;\n\n    void *mem;\n\n\n\n    trace_dma_blk_cb(dbs, ret);\n\n\n\n    dbs->acb = NULL;\n\n    dbs->sector_num += dbs->iov.size / 512;\n\n\n\n    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {\n\n        dma_complete(dbs, ret);\n\n        return;\n\n    }\n\n    dma_blk_unmap(dbs);\n\n\n\n    while (dbs->sg_cur_index < dbs->sg->nsg) {\n\n        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;\n\n        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;\n\n        mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);\n\n        if (!mem)\n\n            break;\n\n        qemu_iovec_add(&dbs->iov, mem, cur_len);\n\n        dbs->sg_cur_byte += cur_len;\n\n        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {\n\n            dbs->sg_cur_byte = 0;\n\n            ++dbs->sg_cur_index;\n\n        }\n\n    }\n\n\n\n    if (dbs->iov.size == 0) {\n\n        trace_dma_map_wait(dbs);\n\n        cpu_register_map_client(dbs, continue_after_map_failure);\n\n        return;\n\n    }\n\n\n\n    if (dbs->iov.size & ~BDRV_SECTOR_MASK) {\n\n        qemu_iovec_discard_back(&dbs->iov, dbs->iov.size & ~BDRV_SECTOR_MASK);\n\n    }\n\n\n\n    dbs->acb = dbs->io_func(dbs->blk, dbs->sector_num, &dbs->iov,\n\n                            dbs->iov.size / 512, dma_blk_cb, dbs);\n\n    assert(dbs->acb);\n\n}\n", "target": true}
{"task_id": "defect/train/18", "input": "long do_sigreturn(CPUPPCState *env)\n\n{\n\n    struct target_sigcontext *sc = NULL;\n\n    struct target_mcontext *sr = NULL;\n\n    target_ulong sr_addr = 0, sc_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t set;\n\n\n\n    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;\n\n    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1))\n\n        goto sigsegv;\n\n\n\n#if defined(TARGET_PPC64)\n\n    set.sig[0] = sc->oldmask + ((uint64_t)(sc->_unused[3]) << 32);\n\n#else\n\n    __get_user(set.sig[0], &sc->oldmask);\n\n    __get_user(set.sig[1], &sc->_unused[3]);\n\n#endif\n\n    target_to_host_sigset_internal(&blocked, &set);\n\n    set_sigmask(&blocked);\n\n\n\n    __get_user(sr_addr, &sc->regs);\n\n    if (!lock_user_struct(VERIFY_READ, sr, sr_addr, 1))\n\n        goto sigsegv;\n\n    restore_user_regs(env, sr, 1);\n\n\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nsigsegv:\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/19", "input": "static int virtio_gpu_load(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    VirtIOGPU *g = opaque;\n\n    struct virtio_gpu_simple_resource *res;\n\n    struct virtio_gpu_scanout *scanout;\n\n    uint32_t resource_id, pformat;\n\n    int i;\n\n\n\n    g->hostmem = 0;\n\n\n\n    resource_id = qemu_get_be32(f);\n\n    while (resource_id != 0) {\n\n        res = g_new0(struct virtio_gpu_simple_resource, 1);\n\n        res->resource_id = resource_id;\n\n        res->width = qemu_get_be32(f);\n\n        res->height = qemu_get_be32(f);\n\n        res->format = qemu_get_be32(f);\n\n        res->iov_cnt = qemu_get_be32(f);\n\n\n\n        /* allocate */\n\n        pformat = get_pixman_format(res->format);\n\n        if (!pformat) {\n\n\n            return -EINVAL;\n\n\n        res->image = pixman_image_create_bits(pformat,\n\n                                              res->width, res->height,\n\n                                              NULL, 0);\n\n        if (!res->image) {\n\n\n            return -EINVAL;\n\n\n\n\n        res->hostmem = PIXMAN_FORMAT_BPP(pformat) * res->width * res->height;\n\n\n\n        res->addrs = g_new(uint64_t, res->iov_cnt);\n\n        res->iov = g_new(struct iovec, res->iov_cnt);\n\n\n\n        /* read data */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            res->addrs[i] = qemu_get_be64(f);\n\n            res->iov[i].iov_len = qemu_get_be32(f);\n\n\n        qemu_get_buffer(f, (void *)pixman_image_get_data(res->image),\n\n                        pixman_image_get_stride(res->image) * res->height);\n\n\n\n        /* restore mapping */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            hwaddr len = res->iov[i].iov_len;\n\n            res->iov[i].iov_base =\n\n                cpu_physical_memory_map(res->addrs[i], &len, 1);\n\n            if (!res->iov[i].iov_base || len != res->iov[i].iov_len) {\n\n\n\n\n\n\n\n\n\n\n\n                return -EINVAL;\n\n\n\n\n\n        QTAILQ_INSERT_HEAD(&g->reslist, res, next);\n\n        g->hostmem += res->hostmem;\n\n\n\n        resource_id = qemu_get_be32(f);\n\n\n\n\n    /* load & apply scanout state */\n\n    vmstate_load_state(f, &vmstate_virtio_gpu_scanouts, g, 1);\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n\n        scanout = &g->scanout[i];\n\n        if (!scanout->resource_id) {\n\n            continue;\n\n\n        res = virtio_gpu_find_resource(g, scanout->resource_id);\n\n        if (!res) {\n\n            return -EINVAL;\n\n\n        scanout->ds = qemu_create_displaysurface_pixman(res->image);\n\n        if (!scanout->ds) {\n\n            return -EINVAL;\n\n\n\n\n        dpy_gfx_replace_surface(scanout->con, scanout->ds);\n\n        dpy_gfx_update(scanout->con, 0, 0, scanout->width, scanout->height);\n\n        update_cursor(g, &scanout->cursor);\n\n        res->scanout_bitmask |= (1 << i);\n\n\n\n\n    return 0;\n", "target": true}
{"task_id": "defect/train/20", "input": "static av_cold int iv_alloc_frames(Indeo3DecodeContext *s)\n\n{\n\n    int luma_width    = (s->width           + 3) & ~3,\n\n        luma_height   = (s->height          + 3) & ~3,\n\n        chroma_width  = ((luma_width  >> 2) + 3) & ~3,\n\n        chroma_height = ((luma_height >> 2) + 3) & ~3,\n\n        luma_pixels   = luma_width   * luma_height,\n\n        chroma_pixels = chroma_width * chroma_height,\n\n        i;\n\n    unsigned int bufsize = luma_pixels * 2 + luma_width * 3 +\n\n                          (chroma_pixels   + chroma_width) * 4;\n\n\n\n\n    if(!(s->buf = av_malloc(bufsize)))\n\n        return AVERROR(ENOMEM);\n\n    s->iv_frame[0].y_w = s->iv_frame[1].y_w = luma_width;\n\n    s->iv_frame[0].y_h = s->iv_frame[1].y_h = luma_height;\n\n    s->iv_frame[0].uv_w = s->iv_frame[1].uv_w = chroma_width;\n\n    s->iv_frame[0].uv_h = s->iv_frame[1].uv_h = chroma_height;\n\n\n\n    s->iv_frame[0].Ybuf = s->buf + luma_width;\n\n    i = luma_pixels + luma_width * 2;\n\n    s->iv_frame[1].Ybuf = s->buf + i;\n\n    i += (luma_pixels + luma_width);\n\n    s->iv_frame[0].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[0].Vbuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Vbuf = s->buf + i;\n\n\n\n    for(i = 1; i <= luma_width; i++)\n\n        s->iv_frame[0].Ybuf[-i] = s->iv_frame[1].Ybuf[-i] =\n\n            s->iv_frame[0].Ubuf[-i] = 0x80;\n\n\n\n    for(i = 1; i <= chroma_width; i++) {\n\n        s->iv_frame[1].Ubuf[-i] = 0x80;\n\n        s->iv_frame[0].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[chroma_pixels+i-1] = 0x80;\n\n    }\n\n\n\n    return 0;\n\n}", "target": true}
{"task_id": "defect/train/21", "input": "static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */\n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}\n", "target": false}
{"task_id": "defect/train/22", "input": "int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/23", "input": "av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n", "target": false}
{"task_id": "defect/train/24", "input": "static int config_props(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    LutContext *lut = ctx->priv;\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];\n\n    int min[4], max[4];\n\n    int val, comp, ret;\n\n\n\n    lut->hsub = desc->log2_chroma_w;\n\n    lut->vsub = desc->log2_chroma_h;\n\n\n\n    lut->var_values[VAR_W] = inlink->w;\n\n    lut->var_values[VAR_H] = inlink->h;\n\n\n\n    switch (inlink->format) {\n\n    case PIX_FMT_YUV410P:\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_YUVA420P:\n\n        min[Y] = min[U] = min[V] = 16;\n\n        max[Y] = 235;\n\n        max[U] = max[V] = 240;\n\n        min[A] = 0; max[A] = 255;\n\n        break;\n\n    default:\n\n        min[0] = min[1] = min[2] = min[3] = 0;\n\n        max[0] = max[1] = max[2] = max[3] = 255;\n\n    }\n\n\n\n    lut->is_yuv = lut->is_rgb = 0;\n\n    if      (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;\n\n    else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;\n\n\n\n    if (lut->is_rgb) {\n\n        switch (inlink->format) {\n\n        case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;\n\n        case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;\n\n        case PIX_FMT_RGBA:\n\n        case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;\n\n        case PIX_FMT_BGRA:\n\n        case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;\n\n        }\n\n        lut->step = av_get_bits_per_pixel(desc) >> 3;\n\n    }\n\n\n\n    for (comp = 0; comp < desc->nb_components; comp++) {\n\n        double res;\n\n\n\n        /* create the parsed expression */\n\n        ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],\n\n                            var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);\n\n        if (ret < 0) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Error when parsing the expression '%s' for the component %d.\\n\",\n\n                   lut->comp_expr_str[comp], comp);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        /* compute the lut */\n\n        lut->var_values[VAR_MAXVAL] = max[comp];\n\n        lut->var_values[VAR_MINVAL] = min[comp];\n\n\n\n        for (val = 0; val < 256; val++) {\n\n            lut->var_values[VAR_VAL] = val;\n\n            lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);\n\n            lut->var_values[VAR_NEGVAL] =\n\n                av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],\n\n                        min[comp], max[comp]);\n\n\n\n            res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);\n\n            if (isnan(res)) {\n\n                av_log(ctx, AV_LOG_ERROR,\n\n                       \"Error when evaluating the expression '%s' for the value %d for the component #%d.\\n\",\n\n                       lut->comp_expr_str[comp], val, comp);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);\n\n            av_log(ctx, AV_LOG_DEBUG, \"val[%d][%d] = %d\\n\", comp, val, lut->lut[comp][val]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/25", "input": "static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/26", "input": "static int huffman_decode(MPADecodeContext *s, GranuleDef *g,\n\n                          int16_t *exponents, int end_pos2)\n\n{\n\n    int s_index;\n\n    int i;\n\n    int last_pos, bits_left;\n\n    VLC *vlc;\n\n    int end_pos = FFMIN(end_pos2, s->gb.size_in_bits);\n\n\n\n    /* low frequencies (called big values) */\n\n    s_index = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        int j, k, l, linbits;\n\n        j = g->region_size[i];\n\n        if (j == 0)\n\n            continue;\n\n        /* select vlc table */\n\n        k       = g->table_select[i];\n\n        l       = mpa_huff_data[k][0];\n\n        linbits = mpa_huff_data[k][1];\n\n        vlc     = &huff_vlc[l];\n\n\n\n        if (!l) {\n\n            memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * 2 * j);\n\n            s_index += 2 * j;\n\n            continue;\n\n        }\n\n\n\n        /* read huffcode and compute each couple */\n\n        for (; j > 0; j--) {\n\n            int exponent, x, y;\n\n            int v;\n\n            int pos = get_bits_count(&s->gb);\n\n\n\n            if (pos >= end_pos){\n\n                switch_buffer(s, &pos, &end_pos, &end_pos2);\n\n                if (pos >= end_pos)\n\n                    break;\n\n            }\n\n            y = get_vlc2(&s->gb, vlc->table, 7, 3);\n\n\n\n            if (!y) {\n\n                g->sb_hybrid[s_index  ] =\n\n                g->sb_hybrid[s_index+1] = 0;\n\n                s_index += 2;\n\n                continue;\n\n            }\n\n\n\n            exponent= exponents[s_index];\n\n\n\n            ff_dlog(s->avctx, \"region=%d n=%d x=%d y=%d exp=%d\\n\",\n\n                    i, g->region_size[i] - j, x, y, exponent);\n\n            if (y & 16) {\n\n                x = y >> 5;\n\n                y = y & 0x0f;\n\n                if (x < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index, RENAME(expval_table)[exponent] + x)\n\n                } else {\n\n                    x += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(x, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index] = v;\n\n                }\n\n                if (y < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index + 1, RENAME(expval_table)[exponent] + y)\n\n                } else {\n\n                    y += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(y, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index+1] = v;\n\n                }\n\n            } else {\n\n                x = y >> 5;\n\n                y = y & 0x0f;\n\n                x += y;\n\n                if (x < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index + !!y, RENAME(expval_table)[exponent] + x)\n\n                } else {\n\n                    x += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(x, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index+!!y] = v;\n\n                }\n\n                g->sb_hybrid[s_index + !y] = 0;\n\n            }\n\n            s_index += 2;\n\n        }\n\n    }\n\n\n\n    /* high frequencies */\n\n    vlc = &huff_quad_vlc[g->count1table_select];\n\n    last_pos = 0;\n\n    while (s_index <= 572) {\n\n        int pos, code;\n\n        pos = get_bits_count(&s->gb);\n\n        if (pos >= end_pos) {\n\n            if (pos > end_pos2 && last_pos) {\n\n                /* some encoders generate an incorrect size for this\n\n                   part. We must go back into the data */\n\n                s_index -= 4;\n\n                skip_bits_long(&s->gb, last_pos - pos);\n\n                av_log(s->avctx, AV_LOG_INFO, \"overread, skip %d enddists: %d %d\\n\", last_pos - pos, end_pos-pos, end_pos2-pos);\n\n                if(s->err_recognition & AV_EF_BITSTREAM)\n\n                    s_index=0;\n\n                break;\n\n            }\n\n            switch_buffer(s, &pos, &end_pos, &end_pos2);\n\n            if (pos >= end_pos)\n\n                break;\n\n        }\n\n        last_pos = pos;\n\n\n\n        code = get_vlc2(&s->gb, vlc->table, vlc->bits, 1);\n\n        ff_dlog(s->avctx, \"t=%d code=%d\\n\", g->count1table_select, code);\n\n        g->sb_hybrid[s_index+0] =\n\n        g->sb_hybrid[s_index+1] =\n\n        g->sb_hybrid[s_index+2] =\n\n        g->sb_hybrid[s_index+3] = 0;\n\n        while (code) {\n\n            static const int idxtab[16] = { 3,3,2,2,1,1,1,1,0,0,0,0,0,0,0,0 };\n\n            int v;\n\n            int pos = s_index + idxtab[code];\n\n            code   ^= 8 >> idxtab[code];\n\n            READ_FLIP_SIGN(g->sb_hybrid + pos, RENAME(exp_table)+exponents[pos])\n\n        }\n\n        s_index += 4;\n\n    }\n\n    /* skip extension bits */\n\n    bits_left = end_pos2 - get_bits_count(&s->gb);\n\n    if (bits_left < 0 && (s->err_recognition & AV_EF_BUFFER)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"bits_left=%d\\n\", bits_left);\n\n        s_index=0;\n\n    } else if (bits_left > 0 && (s->err_recognition & AV_EF_BUFFER)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"bits_left=%d\\n\", bits_left);\n\n        s_index = 0;\n\n    }\n\n    memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * (576 - s_index));\n\n    skip_bits_long(&s->gb, bits_left);\n\n\n\n    i = get_bits_count(&s->gb);\n\n    switch_buffer(s, &i, &end_pos, &end_pos2);\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/27", "input": "void helper_slbie(CPUPPCState *env, target_ulong addr)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    ppc_slb_t *slb;\n\n\n\n    slb = slb_lookup(cpu, addr);\n\n    if (!slb) {\n\n        return;\n\n    }\n\n\n\n    if (slb->esid & SLB_ESID_V) {\n\n        slb->esid &= ~SLB_ESID_V;\n\n\n\n        /* XXX: given the fact that segment size is 256 MB or 1TB,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n         *      in QEMU, we just invalidate all TLBs\n\n         */\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/28", "input": "static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)\n\n{\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n\n\n    /* MSR:POW cannot be set by any form of rfi */\n\n    msr &= ~(1ULL << MSR_POW);\n\n\n\n#if defined(TARGET_PPC64)\n\n    /* Switching to 32-bit ? Crop the nip */\n\n    if (!msr_is_64bit(env, msr)) {\n\n        nip = (uint32_t)nip;\n\n    }\n\n#else\n\n    nip = (uint32_t)nip;\n\n#endif\n\n    /* XXX: beware: this is false if VLE is supported */\n\n    env->nip = nip & ~((target_ulong)0x00000003);\n\n    hreg_store_msr(env, msr, 1);\n\n#if defined(DEBUG_OP)\n\n    cpu_dump_rfi(env->nip, env->msr);\n\n#endif\n\n    /* No need to raise an exception here,\n\n     * as rfi is always the last insn of a TB\n\n     */\n\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n\n\n    /* Context synchronizing: check if TCG TLB needs flush */\n\n    check_tlb_flush(env);\n\n}\n", "target": true}
{"task_id": "defect/train/29", "input": "static void d3d11va_device_uninit(AVHWDeviceContext *hwdev)\n\n{\n\n    AVD3D11VADeviceContext *device_hwctx = hwdev->hwctx;\n\n\n\n    if (device_hwctx->device)\n\n        ID3D11Device_Release(device_hwctx->device);\n\n\n\n    if (device_hwctx->device_context)\n\n        ID3D11DeviceContext_Release(device_hwctx->device_context);\n\n\n\n    if (device_hwctx->video_device)\n\n        ID3D11VideoDevice_Release(device_hwctx->video_device);\n\n\n\n    if (device_hwctx->video_context)\n\n        ID3D11VideoContext_Release(device_hwctx->video_context);\n\n\n\n    if (device_hwctx->lock == d3d11va_default_lock)\n\n        CloseHandle(device_hwctx->lock_ctx);\n\n}\n", "target": true}
{"task_id": "defect/train/30", "input": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        codec->channels    = avio_rl16(pb);\n\n        codec->sample_rate = avio_rl32(pb);\n\n        bitrate            = avio_rl32(pb) * 8;\n\n        codec->block_align = avio_rl16(pb);\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/31", "input": "static void test_acpi_asl(test_data *data)\n\n{\n\n    int i;\n\n    AcpiSdtTable *sdt, *exp_sdt;\n\n    test_data exp_data;\n\n    gboolean exp_err, err;\n\n\n\n    memset(&exp_data, 0, sizeof(exp_data));\n\n    exp_data.tables = load_expected_aml(data);\n\n    dump_aml_files(data, false);\n\n    for (i = 0; i < data->tables->len; ++i) {\n\n        GString *asl, *exp_asl;\n\n\n\n        sdt = &g_array_index(data->tables, AcpiSdtTable, i);\n\n        exp_sdt = &g_array_index(exp_data.tables, AcpiSdtTable, i);\n\n\n\n        err = load_asl(data->tables, sdt);\n\n        asl = normalize_asl(sdt->asl);\n\n\n\n        exp_err = load_asl(exp_data.tables, exp_sdt);\n\n        exp_asl = normalize_asl(exp_sdt->asl);\n\n\n\n        /* TODO: check for warnings */\n\n        g_assert(!err || exp_err);\n\n\n\n        if (g_strcmp0(asl->str, exp_asl->str)) {\n\n            uint32_t signature = cpu_to_le32(exp_sdt->header.signature);\n\n            sdt->tmp_files_retain = true;\n\n            exp_sdt->tmp_files_retain = true;\n\n            fprintf(stderr,\n\n                    \"acpi-test: Warning! %.4s mismatch. \"\n\n                    \"Actual [asl:%s, aml:%s], Expected [asl:%s, aml:%s].\\n\",\n\n                    (gchar *)&signature,\n\n                    sdt->asl_file, sdt->aml_file,\n\n                    exp_sdt->asl_file, exp_sdt->aml_file);\n\n        }\n\n        g_string_free(asl, true);\n\n        g_string_free(exp_asl, true);\n\n    }\n\n\n\n    free_test_data(&exp_data);\n\n}\n", "target": true}
{"task_id": "defect/train/32", "input": "static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,\n\n                                int size, int type,\n\n                                uint32_t **lace_buf, int *laces)\n\n{\n\n    int res = 0, n;\n\n    uint8_t *data = *buf;\n\n    uint32_t *lace_size;\n\n\n\n    if (!type) {\n\n        *laces = 1;\n\n        *lace_buf = av_mallocz(sizeof(int));\n\n        if (!*lace_buf)\n\n            return AVERROR(ENOMEM);\n\n\n\n        *lace_buf[0] = size;\n\n        return 0;\n\n    }\n\n\n\n    assert(size > 0);\n\n    *laces = *data + 1;\n\n    data += 1;\n\n    size -= 1;\n\n    lace_size = av_mallocz(*laces * sizeof(int));\n\n    if (!lace_size)\n\n        return AVERROR(ENOMEM);\n\n\n\n    switch (type) {\n\n    case 0x1: /* Xiph lacing */ {\n\n        uint8_t temp;\n\n        uint32_t total = 0;\n\n        for (n = 0; res == 0 && n < *laces - 1; n++) {\n\n            while (1) {\n\n                if (size == 0) {\n\n                    res = AVERROR_EOF;\n\n                    break;\n\n                }\n\n                temp = *data;\n\n                lace_size[n] += temp;\n\n                data += 1;\n\n                size -= 1;\n\n                if (temp != 0xff)\n\n                    break;\n\n            }\n\n            total += lace_size[n];\n\n        }\n\n        if (size <= total) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        lace_size[n] = size - total;\n\n        break;\n\n    }\n\n\n\n    case 0x2: /* fixed-size lacing */\n\n        if (size != (size / *laces) * size) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n        for (n = 0; n < *laces; n++)\n\n            lace_size[n] = size / *laces;\n\n        break;\n\n\n\n    case 0x3: /* EBML lacing */ {\n\n        uint64_t num;\n\n        uint32_t total;\n\n        n = matroska_ebmlnum_uint(matroska, data, size, &num);\n\n        if (n < 0) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"EBML block data error\\n\");\n\n            res = n;\n\n            break;\n\n        }\n\n        data += n;\n\n        size -= n;\n\n        total = lace_size[0] = num;\n\n        for (n = 1; res == 0 && n < *laces - 1; n++) {\n\n            int64_t snum;\n\n            int r;\n\n            r = matroska_ebmlnum_sint(matroska, data, size, &snum);\n\n            if (r < 0) {\n\n                av_log(matroska->ctx, AV_LOG_INFO,\n\n                       \"EBML block data error\\n\");\n\n                res = r;\n\n                break;\n\n            }\n\n            data += r;\n\n            size -= r;\n\n            lace_size[n] = lace_size[n - 1] + snum;\n\n            total += lace_size[n];\n\n        }\n\n        if (size <= total) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n        lace_size[*laces - 1] = size - total;\n\n        break;\n\n    }\n\n    }\n\n\n\n    *buf      = data;\n\n    *lace_buf = lace_size;\n\n\n\n    return res;\n\n}\n", "target": true}
{"task_id": "defect/train/33", "input": "static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    /* skip 3 unknown bytes: Object ID (2 bytes), Version Number */\n\n    buf += 3;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/34", "input": "void hmp_info_io_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_ioapic_dump_state(mon, qdict);\n\n    } else {\n\n        ioapic_dump_state(mon, qdict);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/35", "input": "static av_cold int split_init(AVFilterContext *ctx)\n\n{\n\n    SplitContext *s = ctx->priv;\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_outputs; i++) {\n\n        char name[32];\n\n        AVFilterPad pad = { 0 };\n\n\n\n        snprintf(name, sizeof(name), \"output%d\", i);\n\n        pad.type = ctx->filter->inputs[0].type;\n\n        pad.name = av_strdup(name);\n\n        if (!pad.name)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ff_insert_outpad(ctx, i, &pad);\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/36", "input": "static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; /* clear head */\n\n    /* put signature */\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/37", "input": "void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n", "target": false}
{"task_id": "defect/train/38", "input": "static int find_allocation(BlockDriverState *bs, off_t start,\n\n                           off_t *data, off_t *hole)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    off_t offs;\n\n\n\n    if (!s->supports_seek_data) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /*\n\n     * SEEK_DATA cases:\n\n     * D1. offs == start: start is in data\n\n     * D2. offs > start: start is in a hole, next data at offs\n\n     * D3. offs < 0, errno = ENXIO: either start is in a trailing hole\n\n     *                              or start is beyond EOF\n\n     *     If the latter happens, the file has been truncated behind\n\n     *     our back since we opened it.  All bets are off then.\n\n     *     Treating like a trailing hole is simplest.\n\n     * D4. offs < 0, errno != ENXIO: we learned nothing\n\n     */\n\n    offs = glfs_lseek(s->fd, start, SEEK_DATA);\n\n    if (offs < 0) {\n\n        return -errno;          /* D3 or D4 */\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        /* D2: in hole, next data at offs */\n\n        *hole = start;\n\n        *data = offs;\n\n        return 0;\n\n    }\n\n\n\n    /* D1: in data, end not yet known */\n\n\n\n    /*\n\n     * SEEK_HOLE cases:\n\n     * H1. offs == start: start is in a hole\n\n     *     If this happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H2. offs > start: either start is in data, next hole at offs,\n\n     *                   or start is in trailing hole, EOF at offs\n\n     *     Linux treats trailing holes like any other hole: offs ==\n\n     *     start.  Solaris seeks to EOF instead: offs > start (blech).\n\n     *     If that happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H3. offs < 0, errno = ENXIO: start is beyond EOF\n\n     *     If this happens, the file has been truncated behind our\n\n     *     back since we opened it.  Treat it like a trailing hole.\n\n     * H4. offs < 0, errno != ENXIO: we learned nothing\n\n     *     Pretend we know nothing at all, i.e. \"forget\" about D1.\n\n     */\n\n    offs = glfs_lseek(s->fd, start, SEEK_HOLE);\n\n    if (offs < 0) {\n\n        return -errno;          /* D1 and (H3 or H4) */\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        /*\n\n         * D1 and H2: either in data, next hole at offs, or it was in\n\n         * data but is now in a trailing hole.  In the latter case,\n\n         * all bets are off.  Treating it as if it there was data all\n\n         * the way to EOF is safe, so simply do that.\n\n         */\n\n        *data = start;\n\n        *hole = offs;\n\n        return 0;\n\n    }\n\n\n\n    /* D1 and H1 */\n\n    return -EBUSY;\n\n}\n", "target": false}
{"task_id": "defect/train/39", "input": "static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "target": false}
{"task_id": "defect/train/40", "input": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n", "target": false}
{"task_id": "defect/train/41", "input": "static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/42", "input": "static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/43", "input": "void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/44", "input": "uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n\n                       uint8_t lock)\n\n{\n\n    MapCacheEntry *entry, *pentry = NULL;\n\n    hwaddr address_index;\n\n    hwaddr address_offset;\n\n    hwaddr cache_size = size;\n\n    hwaddr test_bit_size;\n\n    bool translated = false;\n\n\n\ntryagain:\n\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n\n\n    trace_xen_map_cache(phys_addr);\n\n\n\n    /* test_bit_size is always a multiple of XC_PAGE_SIZE */\n\n    if (size) {\n\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n\n        }\n\n    } else {\n\n        test_bit_size = XC_PAGE_SIZE;\n\n    }\n\n\n\n    if (mapcache->last_entry != NULL &&\n\n        mapcache->last_entry->paddr_index == address_index &&\n\n        !lock && !size &&\n\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                  test_bit_size >> XC_PAGE_SHIFT,\n\n                  mapcache->last_entry->valid_mapping)) {\n\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n        return mapcache->last_entry->vaddr_base + address_offset;\n\n    }\n\n\n\n    /* size is always a multiple of MCACHE_BUCKET_SIZE */\n\n    if (size) {\n\n        cache_size = size + address_offset;\n\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n\n        }\n\n    } else {\n\n        cache_size = MCACHE_BUCKET_SIZE;\n\n    }\n\n\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n\n\n    while (entry && entry->lock && entry->vaddr_base &&\n\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                 test_bit_size >> XC_PAGE_SHIFT,\n\n                 entry->valid_mapping))) {\n\n        pentry = entry;\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        entry = g_malloc0(sizeof (MapCacheEntry));\n\n        pentry->next = entry;\n\n        xen_remap_bucket(entry, cache_size, address_index);\n\n    } else if (!entry->lock) {\n\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n\n                entry->size != cache_size ||\n\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                    test_bit_size >> XC_PAGE_SHIFT,\n\n                    entry->valid_mapping)) {\n\n            xen_remap_bucket(entry, cache_size, address_index);\n\n        }\n\n    }\n\n\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                test_bit_size >> XC_PAGE_SHIFT,\n\n                entry->valid_mapping)) {\n\n        mapcache->last_entry = NULL;\n\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n\n            translated = true;\n\n            goto tryagain;\n\n        }\n\n        trace_xen_map_cache_return(NULL);\n\n        return NULL;\n\n    }\n\n\n\n    mapcache->last_entry = entry;\n\n    if (lock) {\n\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n\n        entry->lock++;\n\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n\n        reventry->size = entry->size;\n\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n\n    }\n\n\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n    return mapcache->last_entry->vaddr_base + address_offset;\n\n}\n", "target": false}
{"task_id": "defect/train/45", "input": "static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n", "target": false}
{"task_id": "defect/train/46", "input": "static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        /* fallthrough */\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/47", "input": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n    if (*nb_clusters && *refcount_table == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n", "target": false}
{"task_id": "defect/train/48", "input": "void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n", "target": false}
{"task_id": "defect/train/49", "input": "static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n", "target": false}
{"task_id": "defect/train/50", "input": "void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n", "target": false}
{"task_id": "defect/train/51", "input": "static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size / 32, *data_size / 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        /* finally output decoded frame */\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}\n", "target": false}
{"task_id": "defect/train/52", "input": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "target": false}
{"task_id": "defect/train/53", "input": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 int flags, Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (offset > end_offset || ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n            s->image_backing_format = g_strdup(bs->backing_format);\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_CRYPTO_HEADER: {\n\n            unsigned int cflags = 0;\n\n            if (s->crypt_method_header != QCOW_CRYPT_LUKS) {\n\n                error_setg(errp, \"CRYPTO header extension only \"\n\n                           \"expected with LUKS encryption method\");\n\n                return -EINVAL;\n\n            }\n\n            if (ext.len != sizeof(Qcow2CryptoHeaderExtension)) {\n\n                error_setg(errp, \"CRYPTO header extension size %u, \"\n\n                           \"but expected size %zu\", ext.len,\n\n                           sizeof(Qcow2CryptoHeaderExtension));\n\n                return -EINVAL;\n\n            }\n\n\n\n            ret = bdrv_pread(bs->file, offset, &s->crypto_header, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret,\n\n                                 \"Unable to read CRYPTO header extension\");\n\n                return ret;\n\n            }\n\n            be64_to_cpus(&s->crypto_header.offset);\n\n            be64_to_cpus(&s->crypto_header.length);\n\n\n\n            if ((s->crypto_header.offset % s->cluster_size) != 0) {\n\n                error_setg(errp, \"Encryption header offset '%\" PRIu64 \"' is \"\n\n                           \"not a multiple of cluster size '%u'\",\n\n                           s->crypto_header.offset, s->cluster_size);\n\n                return -EINVAL;\n\n            }\n\n\n\n            if (flags & BDRV_O_NO_IO) {\n\n                cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;\n\n            }\n\n            s->crypto = qcrypto_block_open(s->crypto_opts, \"encrypt.\",\n\n                                           qcow2_crypto_hdr_read_func,\n\n                                           bs, cflags, errp);\n\n            if (!s->crypto) {\n\n                return -EINVAL;\n\n            }\n\n        }   break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/54", "input": "static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/55", "input": "long do_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int d0, i;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* set blocked signals */\n\n\n\n    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    /* restore registers */\n\n\n\n    if (restore_sigcontext(env, &frame->sc, &d0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return d0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/56", "input": "static int tcg_match_cmpi(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        /* The COMPARE IMMEDIATE instruction is available.  */\n\n        if (type == TCG_TYPE_I32) {\n\n            /* We have a 32-bit immediate and can compare against anything.  */\n\n            return 1;\n\n        } else {\n\n            /* ??? We have no insight here into whether the comparison is\n\n               signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit\n\n               signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses\n\n               a 32-bit unsigned immediate.  If we were to use the (semi)\n\n               obvious \"val == (int32_t)val\" we would be enabling unsigned\n\n               comparisons vs very large numbers.  The only solution is to\n\n               take the intersection of the ranges.  */\n\n            /* ??? Another possible solution is to simply lie and allow all\n\n               constants here and force the out-of-range values into a temp\n\n               register in tgen_cmp when we have knowledge of the actual\n\n               comparison code in use.  */\n\n            return val >= 0 && val <= 0x7fffffff;\n\n        }\n\n    } else {\n\n        /* Only the LOAD AND TEST instruction is available.  */\n\n        return val == 0;\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/57", "input": "static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)\n\n{\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        return false;\n\n    }\n\n#ifdef TARGET_IS_BIENDIAN\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    return !virtio_is_big_endian(vdev);\n\n#else\n\n    return virtio_is_big_endian(vdev);\n\n#endif\n\n#else\n\n    return false;\n\n#endif\n\n}\n", "target": false}
{"task_id": "defect/train/58", "input": "int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!cmd) {\n\n        return 1;\n\n    }\n\n\n\n    if (!dpy_cursor_define_supported(qxl->vga.con)) {\n\n        return 0;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (!cursor) {\n\n            return 1;\n\n        }\n\n        c = qxl_cursor(qxl, cursor, ext->group_id);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/59", "input": "static int decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y, *src[4];\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkx, cblky, cblkno=0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        int i, j;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        /* Manage band offsets */\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        ff_dwt_decode(&comp->dwt, comp->data);\n\n        src[compno] = comp->data;\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * s->ncomponents + compno;\n\n\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s->cdx[compno]) {\n\n                    int val = *src[compno]++ << (8 - s->cbps[compno]);\n\n                    val += 1 << 7;\n\n                    val = av_clip(val, 0, (1 << 8) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = (uint16_t *)(line + (x * s->ncomponents + compno) * 2);\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s-> cdx[compno]) {\n\n                    int32_t val;\n\n\n\n                    val = *src[compno]++ << (16 - s->cbps[compno]);\n\n                    val += 1 << 15;\n\n                    val = av_clip(val, 0, (1 << 16) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/60", "input": "static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}\n", "target": false}
{"task_id": "defect/train/61", "input": "static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "target": false}
{"task_id": "defect/train/62", "input": "static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n", "target": false}
{"task_id": "defect/train/63", "input": "static int rndis_set_response(USBNetState *s,\n\n                rndis_set_msg_type *buf, unsigned int length)\n\n{\n\n    rndis_set_cmplt_type *resp =\n\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n\n    uint32_t bufoffs, buflen;\n\n    int ret;\n\n\n\n    if (!resp)\n\n        return USB_RET_STALL;\n\n\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n\n    if (bufoffs + buflen > length)\n\n        return USB_RET_STALL;\n\n\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n\n                    bufoffs + (uint8_t *) buf, buflen);\n\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n\n    if (ret < 0) {\n\n        /* OID not supported */\n\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\n        return 0;\n\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/64", "input": "SwsContext *sws_alloc_context(void)\n\n{\n\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n\n\n    c->av_class = &sws_context_class;\n\n    av_opt_set_defaults(c);\n\n\n\n    return c;\n\n}\n", "target": true}
{"task_id": "defect/train/65", "input": "static i2c_interface *musicpal_audio_init(qemu_irq irq)\n\n{\n\n    AudioState *audio;\n\n    musicpal_audio_state *s;\n\n    i2c_interface *i2c;\n\n    int iomemtype;\n\n\n\n    audio = AUD_init();\n\n    if (!audio) {\n\n        AUD_log(audio_name, \"No audio state\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(musicpal_audio_state));\n\n    s->irq = irq;\n\n\n\n    i2c = qemu_mallocz(sizeof(i2c_interface));\n\n    i2c->bus = i2c_init_bus();\n\n    i2c->current_addr = -1;\n\n\n\n    s->wm = wm8750_init(i2c->bus, audio);\n\n    if (!s->wm)\n\n        return NULL;\n\n    i2c_set_slave_address(s->wm, MP_WM_ADDR);\n\n    wm8750_data_req_set(s->wm, audio_callback, s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, musicpal_audio_readfn,\n\n                       musicpal_audio_writefn, s);\n\n    cpu_register_physical_memory(MP_AUDIO_BASE, MP_AUDIO_SIZE, iomemtype);\n\n\n\n    qemu_register_reset(musicpal_audio_reset, s);\n\n\n\n    return i2c;\n\n}\n", "target": true}
{"task_id": "defect/train/66", "input": "void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,\n\n                       bool is_read, int error)\n\n{\n\n    assert(error >= 0);\n\n    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);\n\n    if (action == BDRV_ACTION_STOP) {\n\n        vm_stop(RUN_STATE_IO_ERROR);\n\n        bdrv_iostatus_set_err(bs, error);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/67", "input": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,\n\n                     uint64_t max_mem)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "target": true}
{"task_id": "defect/train/68", "input": "int xics_alloc_block(XICSState *icp, int src, int num, bool lsi, bool align)\n\n{\n\n    int i, first = -1;\n\n    ICSState *ics = &icp->ics[src];\n\n\n\n    assert(src == 0);\n\n    /*\n\n     * MSIMesage::data is used for storing VIRQ so\n\n     * it has to be aligned to num to support multiple\n\n     * MSI vectors. MSI-X is not affected by this.\n\n     * The hint is used for the first IRQ, the rest should\n\n     * be allocated continuously.\n\n     */\n\n    if (align) {\n\n        assert((num == 1) || (num == 2) || (num == 4) ||\n\n               (num == 8) || (num == 16) || (num == 32));\n\n        first = ics_find_free_block(ics, num, num);\n\n    } else {\n\n        first = ics_find_free_block(ics, num, 1);\n\n    }\n\n\n\n    if (first >= 0) {\n\n        for (i = first; i < first + num; ++i) {\n\n            ics_set_irq_type(ics, i, lsi);\n\n        }\n\n    }\n\n    first += ics->offset;\n\n\n\n    trace_xics_alloc_block(src, first, num, lsi, align);\n\n\n\n    return first;\n\n}\n", "target": true}
{"task_id": "defect/train/69", "input": "void object_property_get_uint16List(Object *obj, const char *name,\n\n                                    uint16List **list, Error **errp)\n\n{\n\n    StringOutputVisitor *ov;\n\n    StringInputVisitor *iv;\n\n\n\n    ov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(ov),\n\n                        name, errp);\n\n    iv = string_input_visitor_new(string_output_get_string(ov));\n\n    visit_type_uint16List(string_input_get_visitor(iv),\n\n                          list, NULL, errp);\n\n    string_output_visitor_cleanup(ov);\n\n    string_input_visitor_cleanup(iv);\n\n}\n", "target": true}
{"task_id": "defect/train/70", "input": "static int raw_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int fd;\n\n    int64_t total_size = 0;\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n / 512;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\n              0644);\n\n    if (fd < 0)\n\n        return -EIO;\n\n    ftruncate(fd, total_size * 512);\n\n    close(fd);\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/71", "input": "static inline void RENAME(rgb24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    assert(src1==src2);\n\n    for (i=0; i<width; i++) {\n\n        int r= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int b= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/72", "input": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    QLIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "target": true}
{"task_id": "defect/train/73", "input": "void ff_xvmc_init_block(MpegEncContext *s)\n\n{\n\n    struct xvmc_render_state *render = (struct xvmc_render_state*)s->current_picture.data[2];\n\n    assert(render);\n\n    if (!render || render->magic != AV_XVMC_RENDER_MAGIC) {\n\n        assert(0);\n\n        return; // make sure that this is a render packet\n\n    }\n\n    s->block = (DCTELEM *)(render->data_blocks + render->next_free_data_block_num * 64);\n\n}\n", "target": true}
{"task_id": "defect/train/74", "input": "void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/75", "input": "static uint32_t ecc_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ECCState *s = opaque;\n\n    uint32_t ret = 0;\n\n\n\n    switch (addr & ECC_ADDR_MASK) {\n\n    case ECC_MER:\n\n        ret = s->regs[0];\n\n        DPRINTF(\"Read memory enable %08x\\n\", ret);\n\n        break;\n\n    case ECC_MDR:\n\n        ret = s->regs[1];\n\n        DPRINTF(\"Read memory delay %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFSR:\n\n        ret = s->regs[2];\n\n        DPRINTF(\"Read memory fault status %08x\\n\", ret);\n\n        break;\n\n    case ECC_VCR:\n\n        ret = s->regs[3];\n\n        DPRINTF(\"Read slot configuration %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR0:\n\n        ret = s->regs[4];\n\n        DPRINTF(\"Read memory fault address 0 %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR1:\n\n        ret = s->regs[5];\n\n        DPRINTF(\"Read memory fault address 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_DR:\n\n        ret = s->regs[6];\n\n        DPRINTF(\"Read diagnostic %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR0:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR1:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 2 %08x\\n\", ret);\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "target": true}
{"task_id": "defect/train/76", "input": "int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,\n                             int *got_sub_ptr,\n                             AVPacket *avpkt)\n{\n    int i, ret = 0;\n    if (!avpkt->data && avpkt->size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid packet: NULL data, size != 0\\n\");\n        return AVERROR(EINVAL);\n    if (!avctx->codec)\n        return AVERROR(EINVAL);\n    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid media type for subtitles\\n\");\n        return AVERROR(EINVAL);\n    *got_sub_ptr = 0;\n    avcodec_get_subtitle_defaults(sub);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size) {\n        AVPacket pkt_recoded;\n        AVPacket tmp = *avpkt;\n        int did_split = av_packet_split_side_data(&tmp);\n        //apply_param_change(avctx, &tmp);\n        pkt_recoded = tmp;\n        ret = recode_subtitle(avctx, &pkt_recoded, &tmp);\n        if (ret < 0) {\n            *got_sub_ptr = 0;\n        } else {\n            avctx->internal->pkt = &pkt_recoded;\n            if (avctx->pkt_timebase.den && avpkt->pts != AV_NOPTS_VALUE)\n                sub->pts = av_rescale_q(avpkt->pts,\n                                        avctx->pkt_timebase, AV_TIME_BASE_Q);\n            ret = avctx->codec->decode(avctx, sub, got_sub_ptr, &pkt_recoded);\n            av_assert1((ret >= 0) >= !!*got_sub_ptr &&\n                       !!*got_sub_ptr >= !!sub->num_rects);\n            if (sub->num_rects && !sub->end_display_time && avpkt->duration &&\n                avctx->pkt_timebase.num) {\n                AVRational ms = { 1, 1000 };\n                sub->end_display_time = av_rescale_q(avpkt->duration,\n                                                     avctx->pkt_timebase, ms);\n            for (i = 0; i < sub->num_rects; i++) {\n                if (sub->rects[i]->ass && !utf8_check(sub->rects[i]->ass)) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Invalid UTF-8 in decoded subtitles text; \"\n                           \"maybe missing -sub_charenc option\\n\");\n                    avsubtitle_free(sub);\n                    return AVERROR_INVALIDDATA;\n            if (tmp.data != pkt_recoded.data) { // did we recode?\n                /* prevent from destroying side data from original packet */\n                pkt_recoded.side_data = NULL;\n                pkt_recoded.side_data_elems = 0;\n                av_free_packet(&pkt_recoded);\n            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB)\n                sub->format = 0;\n            else if (avctx->codec_descriptor->props & AV_CODEC_PROP_TEXT_SUB)\n                sub->format = 1;\n            avctx->internal->pkt = NULL;\n            av_packet_free_side_data(&tmp);\n            if(ret == tmp.size)\n                ret = avpkt->size;\n        if (*got_sub_ptr)\n            avctx->frame_number++;\n    return ret;", "target": true}
{"task_id": "defect/train/77", "input": "static int mp_decode_frame(MPADecodeContext *s, \n\n                           short *samples)\n\n{\n\n    int i, nb_frames, ch;\n\n    short *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, \n\n                  s->inbuf_ptr - s->inbuf - HEADER_SIZE);\n\n    \n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        get_bits(&s->gb, 16);\n\n\n\n    dprintf(\"frame %d:\\n\", s->frame_count);\n\n    switch(s->layer) {\n\n    case 1:\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n        break;\n\n    }\n\n#if defined(DEBUG)\n\n    for(i=0;i<nb_frames;i++) {\n\n        for(ch=0;ch<s->nb_channels;ch++) {\n\n            int j;\n\n            printf(\"%d-%d:\", i, ch);\n\n            for(j=0;j<SBLIMIT;j++)\n\n                printf(\" %0.6f\", (double)s->sb_samples[ch][i][j] / FRAC_ONE);\n\n            printf(\"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    /* apply the synthesis filter */\n\n    for(ch=0;ch<s->nb_channels;ch++) {\n\n        samples_ptr = samples + ch;\n\n        for(i=0;i<nb_frames;i++) {\n\n            synth_filter(s, ch, samples_ptr, s->nb_channels,\n\n                         s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * s->nb_channels;\n\n        }\n\n    }\n\n#ifdef DEBUG\n\n    s->frame_count++;        \n\n#endif\n\n    return nb_frames * 32 * sizeof(short) * s->nb_channels;\n\n}\n", "target": false}
{"task_id": "defect/train/78", "input": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            const uint8_t *buf, int buf_size)\n\n{\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n;\n\n    short *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    uint8_t *dstu8;\n\n    int16_t *dst_int16_t;\n\n    int32_t *dst_int32_t;\n\n    int64_t *dst_int64_t;\n\n    uint16_t *dst_uint16_t;\n\n    uint32_t *dst_uint32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n        return -1;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n    *data_size=0;\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          *samples++ = ff_reverse[(v >> 8) & 0xff] +\n\n                       (ff_reverse[v & 0xff] << 8);\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++)\n\n                *samples++ = bytestream_get_le16(&src2[c]);\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        dstu8= (uint8_t*)samples;\n\n        for(;n>0;n--) {\n\n            *dstu8++ = *src++ + 128;\n\n        }\n\n        samples= (short*)dstu8;\n\n        break;\n\n#if WORDS_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* WORDS_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples = (short*)((uint8_t*)data + n*sample_size);\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            *samples++ = x << 8;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            *samples++ = s->table[*src++];\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n            break;\n\n        }\n\n        samples = (short *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "target": false}
{"task_id": "defect/train/79", "input": "static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/80", "input": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    /* virtio-1 compliant devices cannot change the alignment */\n\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    /* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     */\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n", "target": false}
{"task_id": "defect/train/81", "input": "static inline void RENAME(yuvPlanartouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                           long width, long height,\n\n                                           long lumStride, long chromStride, long dstStride, long vertLumPerChroma)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y++) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        //FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)\n\n        __asm__ volatile(\n\n            \"xor                %%\"REG_a\", %%\"REG_a\"    \\n\\t\"\n\n            \".p2align                   4               \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\"   32(%1, %%\"REG_a\", 2)            \\n\\t\"\n\n            PREFETCH\"   32(%2, %%\"REG_a\")               \\n\\t\"\n\n            PREFETCH\"   32(%3, %%\"REG_a\")               \\n\\t\"\n\n            \"movq         (%2, %%\"REG_a\"), %%mm0        \\n\\t\" // U(0)\n\n            \"movq                   %%mm0, %%mm2        \\n\\t\" // U(0)\n\n            \"movq         (%3, %%\"REG_a\"), %%mm1        \\n\\t\" // V(0)\n\n            \"punpcklbw              %%mm1, %%mm0        \\n\\t\" // UVUV UVUV(0)\n\n            \"punpckhbw              %%mm1, %%mm2        \\n\\t\" // UVUV UVUV(8)\n\n\n\n            \"movq       (%1, %%\"REG_a\",2), %%mm3        \\n\\t\" // Y(0)\n\n            \"movq      8(%1, %%\"REG_a\",2), %%mm5        \\n\\t\" // Y(8)\n\n            \"movq                   %%mm0, %%mm4        \\n\\t\" // Y(0)\n\n            \"movq                   %%mm2, %%mm6        \\n\\t\" // Y(8)\n\n            \"punpcklbw              %%mm3, %%mm0        \\n\\t\" // YUYV YUYV(0)\n\n            \"punpckhbw              %%mm3, %%mm4        \\n\\t\" // YUYV YUYV(4)\n\n            \"punpcklbw              %%mm5, %%mm2        \\n\\t\" // YUYV YUYV(8)\n\n            \"punpckhbw              %%mm5, %%mm6        \\n\\t\" // YUYV YUYV(12)\n\n\n\n            MOVNTQ\"                 %%mm0,   (%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm4,  8(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm2, 16(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm6, 24(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n\n\n            \"add                       $8, %%\"REG_a\"    \\n\\t\"\n\n            \"cmp                       %4, %%\"REG_a\"    \\n\\t\"\n\n            \" jb                       1b               \\n\\t\"\n\n            ::\"r\"(dst), \"r\"(ysrc), \"r\"(usrc), \"r\"(vsrc), \"g\" (chromWidth)\n\n            : \"%\"REG_a\n\n        );\n\n#else\n\n//FIXME adapt the Alpha ASM code from yv12->yuy2\n\n\n\n#if HAVE_FAST_64BIT\n\n        int i;\n\n        uint64_t *ldst = (uint64_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i += 2) {\n\n            uint64_t k, l;\n\n            k = uc[0] + (yc[0] << 8) +\n\n                (vc[0] << 16) + (yc[1] << 24);\n\n            l = uc[1] + (yc[2] << 8) +\n\n                (vc[1] << 16) + (yc[3] << 24);\n\n            *ldst++ = k + (l << 32);\n\n            yc += 4;\n\n            uc += 2;\n\n            vc += 2;\n\n        }\n\n\n\n#else\n\n        int i, *idst = (int32_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i++) {\n\n#if HAVE_BIGENDIAN\n\n            *idst++ = (uc[0] << 24)+ (yc[0] << 16) +\n\n                (vc[0] << 8) + (yc[1] << 0);\n\n#else\n\n            *idst++ = uc[0] + (yc[0] << 8) +\n\n               (vc[0] << 16) + (yc[1] << 24);\n\n#endif\n\n            yc += 2;\n\n            uc++;\n\n            vc++;\n\n        }\n\n#endif\n\n#endif\n\n        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {\n\n            usrc += chromStride;\n\n            vsrc += chromStride;\n\n        }\n\n        ysrc += lumStride;\n\n        dst += dstStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            :::\"memory\");\n\n#endif\n\n}\n", "target": false}
{"task_id": "defect/train/82", "input": "int qcrypto_init(Error **errp)\n\n{\n\n    int ret;\n\n    ret = gnutls_global_init();\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Unable to initialize GNUTLS library: %s\",\n\n                   gnutls_strerror(ret));\n\n        return -1;\n\n    }\n\n#ifdef DEBUG_GNUTLS\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n\n#endif\n\n\n\n#ifdef CONFIG_GNUTLS_GCRYPT\n\n    if (!gcry_check_version(GCRYPT_VERSION)) {\n\n        error_setg(errp, \"Unable to initialize gcrypt\");\n\n        return -1;\n\n    }\n\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS\n\n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n\n#endif /* QCRYPTO_INIT_GCRYPT_THREADS */\n\n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/83", "input": "static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,\n\n                                 int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_8|MO_SIGN:\n\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16|MO_SIGN:\n\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n    case MO_32|MO_SIGN:\n\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/84", "input": "static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}\n", "target": false}
{"task_id": "defect/train/85", "input": "static AddressSpace *q35_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    IntelIOMMUState *s = opaque;\n\n    VTDAddressSpace **pvtd_as;\n\n    int bus_num = pci_bus_num(bus);\n\n\n\n    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);\n\n    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);\n\n\n\n    pvtd_as = s->address_spaces[bus_num];\n\n    if (!pvtd_as) {\n\n        /* No corresponding free() */\n\n        pvtd_as = g_malloc0(sizeof(VTDAddressSpace *) * VTD_PCI_DEVFN_MAX);\n\n        s->address_spaces[bus_num] = pvtd_as;\n\n    }\n\n    if (!pvtd_as[devfn]) {\n\n        pvtd_as[devfn] = g_malloc0(sizeof(VTDAddressSpace));\n\n\n\n        pvtd_as[devfn]->bus_num = (uint8_t)bus_num;\n\n        pvtd_as[devfn]->devfn = (uint8_t)devfn;\n\n        pvtd_as[devfn]->iommu_state = s;\n\n        pvtd_as[devfn]->context_cache_entry.context_cache_gen = 0;\n\n        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s),\n\n                                 &s->iommu_ops, \"intel_iommu\", UINT64_MAX);\n\n        address_space_init(&pvtd_as[devfn]->as,\n\n                           &pvtd_as[devfn]->iommu, \"intel_iommu\");\n\n    }\n\n    return &pvtd_as[devfn]->as;\n\n}\n", "target": false}
{"task_id": "defect/train/86", "input": "static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}\n", "target": false}
{"task_id": "defect/train/87", "input": "static unsigned int dec_move_pr(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"move $p%u, $r%u\\n\", dc->op1, dc->op2));\n\n\tcris_cc_mask(dc, 0);\n\n\n\n\tif (dc->op2 == PR_CCS)\n\n\t\tcris_evaluate_flags(dc);\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_gen_mov_TN_preg(t0, dc->op2);\n\n\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t cpu_R[dc->op1], cpu_R[dc->op1], t0, preg_sizes[dc->op2]);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "target": false}
{"task_id": "defect/train/88", "input": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtio_balloon_init_pci;\n\n    k->exit = virtio_balloon_exit_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n\n    k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;\n\n    k->revision = VIRTIO_PCI_ABI_VERSION;\n\n    k->class_id = PCI_CLASS_MEMORY_RAM;\n\n    dc->alias = \"virtio-balloon\";\n\n    dc->reset = virtio_pci_reset;\n\n    dc->props = virtio_balloon_properties;\n\n}\n", "target": false}
{"task_id": "defect/train/89", "input": "static int fetch_active_ports_list(QEMUFile *f,\n\n                                   VirtIOSerial *s, uint32_t nr_active_ports)\n\n{\n\n    uint32_t i;\n\n\n\n    s->post_load = g_malloc0(sizeof(*s->post_load));\n\n    s->post_load->nr_active_ports = nr_active_ports;\n\n    s->post_load->connected =\n\n        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);\n\n\n\n    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                            virtio_serial_post_load_timer_cb,\n\n                                            s);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        VirtIOSerialPort *port;\n\n        uint32_t elem_popped;\n\n        uint32_t id;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        s->post_load->connected[i].port = port;\n\n        s->post_load->connected[i].host_connected = qemu_get_byte(f);\n\n\n\n        qemu_get_be32s(f, &elem_popped);\n\n        if (elem_popped) {\n\n            qemu_get_be32s(f, &port->iov_idx);\n\n            qemu_get_be64s(f, &port->iov_offset);\n\n\n\n            port->elem =\n\n                qemu_get_virtqueue_element(f, sizeof(VirtQueueElement));\n\n\n\n            /*\n\n             *  Port was throttled on source machine.  Let's\n\n             *  unthrottle it here so data starts flowing again.\n\n             */\n\n            virtio_serial_throttle_port(port, false);\n\n        }\n\n    }\n\n    timer_mod(s->post_load->timer, 1);\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/90", "input": "void HELPER(ucf64_cmps)(float32 a, float32 b, uint32_t c, CPUUniCore32State *env)\n\n{\n\n    int flag;\n\n    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);\n\n    env->CF = 0;\n\n    switch (c & 0x7) {\n\n    case 0: /* F */\n\n        break;\n\n    case 1: /* UN */\n\n        if (flag == 2) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 2: /* EQ */\n\n        if (flag == 0) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 3: /* UEQ */\n\n        if ((flag == 0) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 4: /* OLT */\n\n        if (flag == -1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 5: /* ULT */\n\n        if ((flag == -1) || (flag == 2)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 6: /* OLE */\n\n        if ((flag == -1) || (flag == 0)) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    case 7: /* ULE */\n\n        if (flag != 1) {\n\n            env->CF = 1;\n\n        }\n\n        break;\n\n    }\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)\n\n                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);\n\n}\n", "target": false}
{"task_id": "defect/train/91", "input": "static void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,\n\n                                  const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                  const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                  const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                  const uint16_t *abuf1, uint8_t *dest,\n\n                                  int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov %4, %%\"REG_b\"                        \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2PACKED(%%REGBP, %5)\n\n        WRITEYUY2(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither)\n\n    );\n\n}\n", "target": false}
{"task_id": "defect/train/92", "input": "static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)\n\n{\n\n    SCSIRequest *req = &r->req;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    bool start = req->cmd.buf[4] & 1;\n\n    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */\n\n\n\n    if (s->qdev.type == TYPE_ROM && loej) {\n\n        if (!start && !s->tray_open && s->tray_locked) {\n\n            scsi_check_condition(r,\n\n                                 bdrv_is_inserted(s->qdev.conf.bs)\n\n                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)\n\n                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));\n\n            return -1;\n\n        }\n\n\n\n        if (s->tray_open != !start) {\n\n            bdrv_eject(s->qdev.conf.bs, !start);\n\n            s->tray_open = !start;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/93", "input": "static void ecc_mem_writew(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %04x\\n\",\n\n           addr, val & 0xffff);\n\n}\n", "target": false}
{"task_id": "defect/train/94", "input": "int kvm_arch_debug(struct kvm_debug_exit_arch *arch_info)\n\n{\n\n    int handle = 0;\n\n    int n;\n\n\n\n    if (arch_info->exception == 1) {\n\n        if (arch_info->dr6 & (1 << 14)) {\n\n            if (cpu_single_env->singlestep_enabled)\n\n                handle = 1;\n\n        } else {\n\n            for (n = 0; n < 4; n++)\n\n                if (arch_info->dr6 & (1 << n))\n\n                    switch ((arch_info->dr7 >> (16 + n*4)) & 0x3) {\n\n                    case 0x0:\n\n                        handle = 1;\n\n                        break;\n\n                    case 0x1:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_WRITE;\n\n                        break;\n\n                    case 0x3:\n\n                        handle = 1;\n\n                        cpu_single_env->watchpoint_hit = &hw_watchpoint;\n\n                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;\n\n                        hw_watchpoint.flags = BP_MEM_ACCESS;\n\n                        break;\n\n                    }\n\n        }\n\n    } else if (kvm_find_sw_breakpoint(cpu_single_env, arch_info->pc))\n\n        handle = 1;\n\n\n\n    if (!handle) {\n\n        cpu_synchronize_state(cpu_single_env);\n\n        assert(cpu_single_env->exception_injected == -1);\n\n\n\n        cpu_single_env->exception_injected = arch_info->exception;\n\n        cpu_single_env->has_error_code = 0;\n\n    }\n\n\n\n    return handle;\n\n}\n", "target": false}
{"task_id": "defect/train/95", "input": "static void qemu_chr_parse_stdio(QemuOpts *opts, ChardevBackend *backend,\n\n                                 Error **errp)\n\n{\n\n    ChardevStdio *stdio;\n\n\n\n    stdio = backend->u.stdio = g_new0(ChardevStdio, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevStdio_base(stdio));\n\n    stdio->has_signal = true;\n\n    stdio->signal = qemu_opt_get_bool(opts, \"signal\", true);\n\n}\n", "target": false}
{"task_id": "defect/train/96", "input": "static void mirror_complete(BlockJob *job, Error **errp)\n\n{\n\n    MirrorBlockJob *s = container_of(job, MirrorBlockJob, common);\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    ret = bdrv_open_backing_file(s->target, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (!s->synced) {\n\n        error_setg(errp, QERR_BLOCK_JOB_NOT_READY,\n\n                   bdrv_get_device_name(job->bs));\n\n        return;\n\n    }\n\n\n\n    /* check the target bs is not blocked and block all operations on it */\n\n    if (s->replaces) {\n\n        AioContext *replace_aio_context;\n\n\n\n        s->to_replace = check_to_replace_node(s->replaces, &local_err);\n\n        if (!s->to_replace) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n\n\n        replace_aio_context = bdrv_get_aio_context(s->to_replace);\n\n        aio_context_acquire(replace_aio_context);\n\n\n\n        error_setg(&s->replace_blocker,\n\n                   \"block device is in use by block-job-complete\");\n\n        bdrv_op_block_all(s->to_replace, s->replace_blocker);\n\n        bdrv_ref(s->to_replace);\n\n\n\n        aio_context_release(replace_aio_context);\n\n    }\n\n\n\n    s->should_complete = true;\n\n    block_job_enter(&s->common);\n\n}\n", "target": false}
{"task_id": "defect/train/97", "input": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n\n\n    scsi_target_alloc_buf(&r->req, SCSI_INQUIRY_LEN);\n\n\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < r->buf_len);\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, SCSI_INQUIRY_LEN);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "target": false}
{"task_id": "defect/train/98", "input": "void OPPROTO op_movl_npc_T0(void)\n\n{\n\n    env->npc = T0;\n\n}\n", "target": false}
{"task_id": "defect/train/99", "input": "void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce)\n\n{\n\n    TemporalNoiseShaping *tns = &sce->tns;\n\n    int w, g, order, sfb_start, sfb_len, coef_start, shift[MAX_LPC_ORDER], count = 0;\n\n    const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;\n\n    const int tns_max_order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;\n\n    const float freq_mult = mpeg4audio_sample_rates[s->samplerate_index]/(1024.0f/sce->ics.num_windows)/2.0f;\n\n    float max_coef = 0.0f;\n\n\n\n    sce->tns.present = 0;\n\n    return;\n\n\n\n    for (coef_start = 0; coef_start < 1024; coef_start++)\n\n        max_coef = FFMAX(max_coef, sce->pcoeffs[coef_start]);\n\n\n\n    for (w = 0; w < sce->ics.num_windows; w++) {\n\n        int filters = 1, start = 0, coef_len = 0;\n\n        int32_t conv_coeff[1024] = {0};\n\n        int32_t coefs_t[MAX_LPC_ORDER][MAX_LPC_ORDER] = {{0}};\n\n\n\n        /* Determine start sfb + coef - excludes anything below threshold */\n\n        for (g = 0;  g < sce->ics.num_swb; g++) {\n\n            if (start*freq_mult > TNS_LOW_LIMIT) {\n\n                sfb_start = w*16+g;\n\n                sfb_len   = (w+1)*16 + g - sfb_start;\n\n                coef_start = sce->ics.swb_offset[sfb_start];\n\n                coef_len  = sce->ics.swb_offset[sfb_start + sfb_len] - coef_start;\n\n                break;\n\n            }\n\n            start += sce->ics.swb_sizes[g];\n\n        }\n\n\n\n        if (coef_len <= 0)\n\n            continue;\n\n\n\n        conv_to_int32(conv_coeff, &sce->pcoeffs[coef_start], coef_len, max_coef);\n\n\n\n        /* LPC */\n\n        order = ff_lpc_calc_coefs(&s->lpc, conv_coeff, coef_len,\n\n                                  TNS_MIN_PRED_ORDER, tns_max_order,\n\n                                  32, coefs_t, shift,\n\n                                  FF_LPC_TYPE_LEVINSON, 10,\n\n                                  ORDER_METHOD_EST, MAX_LPC_SHIFT, 0) - 1;\n\n\n\n        /* Works surprisingly well, remember to tweak MAX_LPC_SHIFT if you want to play around with this */\n\n        if (shift[order] > 3) {\n\n            int direction = 0;\n\n            float tns_coefs_raw[TNS_MAX_ORDER];\n\n            tns->n_filt[w] = filters++;\n\n            conv_to_float(tns_coefs_raw, coefs_t[order], order);\n\n            for (g = 0; g < tns->n_filt[w]; g++) {\n\n                process_tns_coeffs(tns, tns_coefs_raw, order, w, g);\n\n                apply_tns_filter(&sce->coeffs[coef_start], sce->pcoeffs, order, direction, tns->coef[w][g],\n\n                                 sce->ics.ltp.present, w, g, coef_start, coef_len);\n\n                tns->order[w][g]     = order;\n\n                tns->length[w][g]    = sfb_len;\n\n                tns->direction[w][g] = direction;\n\n            }\n\n            count++;\n\n        }\n\n    }\n\n\n\n    sce->tns.present = !!count;\n\n}\n", "target": false}
{"task_id": "defect/train/100", "input": "int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)\n\n{\n\n    _Bool exp = 0;\n\n    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)\n\n        return 0;\n\n\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n\n\n    if (atomic_fetch_add(&entangled_thread_counter, 1)) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Insufficient thread locking. At least %d threads are \"\n\n               \"calling avcodec_open2() at the same time right now.\\n\",\n\n               atomic_load(&entangled_thread_counter));\n\n        if (!lockmgr_cb)\n\n            av_log(log_ctx, AV_LOG_ERROR, \"No lock manager is set, please see av_lockmgr_register()\\n\");\n\n        atomic_store(&ff_avcodec_locked, 1);\n\n        ff_unlock_avcodec(codec);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_assert0(atomic_compare_exchange_strong(&ff_avcodec_locked, &exp, 1));\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/101", "input": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n\n\n    memset(block, 0, 16 * sizeof(dctcoef));\n\n}\n", "target": true}
{"task_id": "defect/train/102", "input": "static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque,\n\n                                         uint64_t flags)\n\n{\n\n    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),\n\n                               .type = RDMA_CONTROL_REGISTER_RESULT,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader unreg_resp = { .len = 0,\n\n                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,\n\n                                 .repeat = 1 };\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMAControlHeader head;\n\n    RDMARegister *reg, *registers;\n\n    RDMACompress *comp;\n\n    RDMARegisterResult *reg_result;\n\n    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];\n\n    RDMALocalBlock *block;\n\n    void *host_addr;\n\n    int ret = 0;\n\n    int idx = 0;\n\n    int count = 0;\n\n    int i = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    do {\n\n        DDDPRINTF(\"Waiting for next request %\" PRIu64 \"...\\n\", flags);\n\n\n\n        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n\n\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n\n            fprintf(stderr, \"rdma: Too many requests in this message (%d).\"\n\n                            \"Bailing.\\n\", head.repeat);\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n\n\n        switch (head.type) {\n\n        case RDMA_CONTROL_COMPRESS:\n\n            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;\n\n            network_to_compress(comp);\n\n\n\n            DDPRINTF(\"Zapping zero chunk: %\" PRId64\n\n                    \" bytes, index %d, offset %\" PRId64 \"\\n\",\n\n                    comp->length, comp->block_idx, comp->offset);\n\n            block = &(rdma->local_ram_blocks.block[comp->block_idx]);\n\n\n\n            host_addr = block->local_host_addr +\n\n                            (comp->offset - block->offset);\n\n\n\n            ram_handle_compressed(host_addr, comp->value, comp->length);\n\n            break;\n\n\n\n        case RDMA_CONTROL_REGISTER_FINISHED:\n\n            DDDPRINTF(\"Current registrations complete.\\n\");\n\n            goto out;\n\n\n\n        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:\n\n            DPRINTF(\"Initial setup info requested.\\n\");\n\n\n\n            if (rdma->pin_all) {\n\n                ret = qemu_rdma_reg_whole_ram_blocks(rdma);\n\n                if (ret) {\n\n                    fprintf(stderr, \"rdma migration: error dest \"\n\n                                    \"registering ram blocks!\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /*\n\n             * Dest uses this to prepare to transmit the RAMBlock descriptions\n\n             * to the source VM after connection setup.\n\n             * Both sides use the \"remote\" structure to communicate and update\n\n             * their \"local\" descriptions with what was sent.\n\n             */\n\n            for (i = 0; i < local->nb_blocks; i++) {\n\n                rdma->block[i].remote_host_addr =\n\n                    (uint64_t)(local->block[i].local_host_addr);\n\n\n\n                if (rdma->pin_all) {\n\n                    rdma->block[i].remote_rkey = local->block[i].mr->rkey;\n\n                }\n\n\n\n                rdma->block[i].offset = local->block[i].offset;\n\n                rdma->block[i].length = local->block[i].length;\n\n\n\n                remote_block_to_network(&rdma->block[i]);\n\n            }\n\n\n\n            blocks.len = rdma->local_ram_blocks.nb_blocks\n\n                                                * sizeof(RDMARemoteBlock);\n\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                                        (uint8_t *) rdma->block, &blocks);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"rdma migration: error sending remote info!\\n\");\n\n                goto out;\n\n            }\n\n\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d registration requests\\n\", head.repeat);\n\n\n\n            reg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                uint64_t chunk;\n\n                uint8_t *chunk_start, *chunk_end;\n\n\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                reg_result = &results[count];\n\n\n\n                DDPRINTF(\"Registration request (%d): index %d, current_addr %\"\n\n                         PRIu64 \" chunks: %\" PRIu64 \"\\n\", count,\n\n                         reg->current_index, reg->key.current_addr, reg->chunks);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n                if (block->is_ram_block) {\n\n                    host_addr = (block->local_host_addr +\n\n                                (reg->key.current_addr - block->offset));\n\n                    chunk = ram_chunk_index(block->local_host_addr,\n\n                                            (uint8_t *) host_addr);\n\n                } else {\n\n                    chunk = reg->key.chunk;\n\n                    host_addr = block->local_host_addr +\n\n                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));\n\n                }\n\n                chunk_start = ram_chunk_start(block, chunk);\n\n                chunk_end = ram_chunk_end(block, chunk + reg->chunks);\n\n                if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                            (uint8_t *)host_addr, NULL, &reg_result->rkey,\n\n                            chunk, chunk_start, chunk_end)) {\n\n                    fprintf(stderr, \"cannot get rkey!\\n\");\n\n                    ret = -EINVAL;\n\n                    goto out;\n\n                }\n\n\n\n                reg_result->host_addr = (uint64_t) block->local_host_addr;\n\n\n\n                DDPRINTF(\"Registered rkey for this request: %x\\n\",\n\n                                reg_result->rkey);\n\n\n\n                result_to_network(reg_result);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                            (uint8_t *) results, &reg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_UNREGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d unregistration requests\\n\", head.repeat);\n\n            unreg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                DDPRINTF(\"Unregistration request (%d): \"\n\n                         \" index %d, chunk %\" PRIu64 \"\\n\",\n\n                         count, reg->current_index, reg->key.chunk);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n\n\n                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);\n\n                block->pmr[reg->key.chunk] = NULL;\n\n\n\n                if (ret != 0) {\n\n                    perror(\"rdma unregistration chunk failed\");\n\n                    ret = -ret;\n\n                    goto out;\n\n                }\n\n\n\n                rdma->total_registrations--;\n\n\n\n                DDPRINTF(\"Unregistered chunk %\" PRIu64 \" successfully.\\n\",\n\n                            reg->key.chunk);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_RESULT:\n\n            fprintf(stderr, \"Invalid RESULT message at dest.\\n\");\n\n            ret = -EIO;\n\n            goto out;\n\n        default:\n\n            fprintf(stderr, \"Unknown control message %s\\n\",\n\n                                control_desc[head.type]);\n\n            ret = -EIO;\n\n            goto out;\n\n        }\n\n    } while (1);\n\nout:\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n    }\n\n    return ret;\n\n}\n", "target": true}
{"task_id": "defect/train/103", "input": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n\n{\n\n    struct playlist *v = opaque;\n\n    HLSContext *c = v->parent->priv_data;\n\n    int ret, i;\n\n    int just_opened = 0;\n\n\n\n\nrestart:\n\n    if (!v->needed)\n\n        return AVERROR_EOF;\n\n\n\n    if (!v->input) {\n\n        int64_t reload_interval;\n\n        struct segment *seg;\n\n\n\n        /* Check that the playlist is still needed before opening a new\n\n         * segment. */\n\n        if (v->ctx && v->ctx->nb_streams) {\n\n            v->needed = 0;\n\n            for (i = 0; i < v->n_main_streams; i++) {\n\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n\n                    v->needed = 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (!v->needed) {\n\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n\n                v->index);\n\n            return AVERROR_EOF;\n\n        }\n\n\n\n        /* If this is a live stream and the reload interval has elapsed since\n\n         * the last playlist reload, reload the playlists now. */\n\n        reload_interval = default_reload_interval(v);\n\n\n\nreload:\n\n        reload_count++;\n\n        if (reload_count > c->max_reload)\n\n            return AVERROR_EOF;\n\n        if (!v->finished &&\n\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n\n                       v->index);\n\n                return ret;\n\n            }\n\n            /* If we need to reload the playlist again below (if\n\n             * there's still no more segments), switch to a reload\n\n             * interval of half the target duration. */\n\n            reload_interval = v->target_duration / 2;\n\n        }\n\n        if (v->cur_seq_no < v->start_seq_no) {\n\n            av_log(NULL, AV_LOG_WARNING,\n\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n\n                   v->start_seq_no - v->cur_seq_no);\n\n            v->cur_seq_no = v->start_seq_no;\n\n        }\n\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n\n            if (v->finished)\n\n                return AVERROR_EOF;\n\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n\n                if (ff_check_interrupt(c->interrupt_callback))\n\n                    return AVERROR_EXIT;\n\n                av_usleep(100*1000);\n\n            }\n\n            /* Enough time has elapsed since the last reload */\n\n            goto reload;\n\n        }\n\n\n\n        seg = current_segment(v);\n\n\n\n        /* load/update Media Initialization Section, if any */\n\n        ret = update_init_section(v, seg);\n\n        if (ret)\n\n            return ret;\n\n\n\n        ret = open_input(c, v, seg);\n\n        if (ret < 0) {\n\n            if (ff_check_interrupt(c->interrupt_callback))\n\n                return AVERROR_EXIT;\n\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n\n                   v->index);\n\n            v->cur_seq_no += 1;\n\n            goto reload;\n\n        }\n\n        just_opened = 1;\n\n    }\n\n\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n\n        /* Push init section out first before first actual segment */\n\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n\n        memcpy(buf, v->init_sec_buf, copy_size);\n\n        v->init_sec_buf_read_offset += copy_size;\n\n        return copy_size;\n\n    }\n\n\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n\n    if (ret > 0) {\n\n        if (just_opened && v->is_id3_timestamped != 0) {\n\n            /* Intercept ID3 tags here, elementary audio streams are required\n\n             * to convey timestamps using them in the beginning of each segment. */\n\n            intercept_id3(v, buf, buf_size, &ret);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n    ff_format_io_close(v->parent, &v->input);\n\n    v->cur_seq_no++;\n\n\n\n    c->cur_seq_no = v->cur_seq_no;\n\n\n\n    goto restart;\n\n}", "target": true}
{"task_id": "defect/train/104", "input": "static void put_swf_matrix(ByteIOContext *pb,\n\n                           int a, int b, int c, int d, int tx, int ty)\n\n{\n\n    PutBitContext p;\n\n    uint8_t buf[256];\n\n\n\n    init_put_bits(&p, buf, sizeof(buf));\n\n    \n\n    put_bits(&p, 1, 1); /* a, d present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, a);\n\n    put_bits(&p, 20, d);\n\n    \n\n    put_bits(&p, 1, 1); /* b, c present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, c);\n\n    put_bits(&p, 20, b);\n\n\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, tx);\n\n    put_bits(&p, 20, ty);\n\n\n\n    flush_put_bits(&p);\n\n    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);\n\n}\n", "target": true}
{"task_id": "defect/train/105", "input": "int ff_nvdec_start_frame(AVCodecContext *avctx, AVFrame *frame)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    FrameDecodeData *fdd = (FrameDecodeData*)frame->private_ref->data;\n\n    NVDECFrame *cf = NULL;\n\n    int ret;\n\n\n\n    ctx->bitstream_len = 0;\n\n    ctx->nb_slices     = 0;\n\n\n\n    if (fdd->hwaccel_priv)\n\n        return 0;\n\n\n\n    cf = av_mallocz(sizeof(*cf));\n\n    if (!cf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    cf->decoder_ref = av_buffer_ref(ctx->decoder_ref);\n\n    if (!cf->decoder_ref)\n\n        goto fail;\n\n\n\n    cf->idx_ref = av_buffer_pool_get(ctx->decoder_pool);\n\n    if (!cf->idx_ref) {\n\n        av_log(avctx, AV_LOG_ERROR, \"No decoder surfaces left\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    cf->idx = *(unsigned int*)cf->idx_ref->data;\n\n\n\n    fdd->hwaccel_priv      = cf;\n\n    fdd->hwaccel_priv_free = nvdec_fdd_priv_free;\n\n    fdd->post_process      = nvdec_retrieve_data;\n\n\n\n    return 0;\n\nfail:\n\n    nvdec_fdd_priv_free(cf);\n\n    return ret;\n\n\n\n}\n", "target": false}
{"task_id": "defect/train/106", "input": "static int mov_read_trun(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    MOVFragment *frag = &c->fragment;\n\n    AVStream *st = c->fc->streams[frag->track_id-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    uint64_t offset;\n\n    int64_t dts;\n\n    int data_offset = 0;\n\n    unsigned entries, first_sample_flags = frag->flags;\n\n    int flags, distance, i;\n\n\n\n    if (sc->pseudo_stream_id+1 != frag->stsd_id)\n\n        return 0;\n\n    if (!st->nb_index_entries)\n\n        return -1;\n\n    get_byte(pb); /* version */\n\n    flags = get_be24(pb);\n\n    entries = get_be32(pb);\n\n    dprintf(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);\n\n    if (flags & 0x001) data_offset        = get_be32(pb);\n\n    if (flags & 0x004) first_sample_flags = get_be32(pb);\n\n    if (flags & 0x800) {\n\n        if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n\n            return -1;\n\n        sc->ctts_data = av_realloc(sc->ctts_data,\n\n                                   (entries+sc->ctts_count)*sizeof(*sc->ctts_data));\n\n        if (!sc->ctts_data)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    dts = st->duration;\n\n    offset = frag->base_data_offset + data_offset;\n\n    distance = 0;\n\n    dprintf(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);\n\n    for (i = 0; i < entries; i++) {\n\n        unsigned sample_size = frag->size;\n\n        int sample_flags = i ? frag->flags : first_sample_flags;\n\n        unsigned sample_duration = frag->duration;\n\n        int keyframe;\n\n\n\n        if (flags & 0x100) sample_duration = get_be32(pb);\n\n        if (flags & 0x200) sample_size     = get_be32(pb);\n\n        if (flags & 0x400) sample_flags    = get_be32(pb);\n\n        if (flags & 0x800) {\n\n            sc->ctts_data[sc->ctts_count].count = 1;\n\n            sc->ctts_data[sc->ctts_count].duration = get_be32(pb);\n\n            sc->ctts_count++;\n\n        }\n\n        if ((keyframe = st->codec->codec_type == CODEC_TYPE_AUDIO ||\n\n             (flags & 0x004 && !i && !sample_flags) || sample_flags & 0x2000000))\n\n            distance = 0;\n\n        av_add_index_entry(st, offset, dts, sample_size, distance,\n\n                           keyframe ? AVINDEX_KEYFRAME : 0);\n\n        dprintf(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n\n                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,\n\n                offset, dts, sample_size, distance, keyframe);\n\n        distance++;\n\n        assert(sample_duration % sc->time_rate == 0);\n\n        dts += sample_duration / sc->time_rate;\n\n        offset += sample_size;\n\n    }\n\n    frag->moof_offset = offset;\n\n    sc->sample_count = st->nb_index_entries;\n\n    st->duration = dts;\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/107", "input": "void mpv_decode_mb_internal(MpegEncContext *s, int16_t block[12][64],\n\n                            int is_mpeg12)\n\n{\n\n    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration){\n\n        ff_xvmc_decode_mb(s);//xvmc uses pblocks\n\n        return;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n       /* print DCT coefficients */\n\n       int i,j;\n\n       av_log(s->avctx, AV_LOG_DEBUG, \"DCT coeffs of MB at %dx%d:\\n\", s->mb_x, s->mb_y);\n\n       for(i=0; i<6; i++){\n\n           for(j=0; j<64; j++){\n\n               av_log(s->avctx, AV_LOG_DEBUG, \"%5d\",\n\n                      block[i][s->idsp.idct_permutation[j]]);\n\n           }\n\n           av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n       }\n\n    }\n\n\n\n    s->current_picture.qscale_table[mb_xy] = s->qscale;\n\n\n\n    /* update DC predictors for P macroblocks */\n\n    if (!s->mb_intra) {\n\n        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {\n\n            if(s->mbintra_table[mb_xy])\n\n                ff_clean_intra_table_entries(s);\n\n        } else {\n\n            s->last_dc[0] =\n\n            s->last_dc[1] =\n\n            s->last_dc[2] = 128 << s->intra_dc_precision;\n\n        }\n\n    }\n\n    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))\n\n        s->mbintra_table[mb_xy]=1;\n\n\n\n    if ((s->avctx->flags & AV_CODEC_FLAG_PSNR) ||\n\n        !(s->encoding && (s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&\n\n          s->avctx->mb_decision != FF_MB_DECISION_RD)) { // FIXME precalc\n\n        uint8_t *dest_y, *dest_cb, *dest_cr;\n\n        int dct_linesize, dct_offset;\n\n        op_pixels_func (*op_pix)[4];\n\n        qpel_mc_func (*op_qpix)[16];\n\n        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics\n\n        const int uvlinesize = s->current_picture.f->linesize[1];\n\n        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band;\n\n        const int block_size = 8;\n\n\n\n        /* avoid copy if macroblock skipped in last frame too */\n\n        /* skip only during decoding as we might trash the buffers during encoding a bit */\n\n        if(!s->encoding){\n\n            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];\n\n\n\n            if (s->mb_skipped) {\n\n                s->mb_skipped= 0;\n\n                assert(s->pict_type!=AV_PICTURE_TYPE_I);\n\n                *mbskip_ptr = 1;\n\n            } else if(!s->current_picture.reference) {\n\n                *mbskip_ptr = 1;\n\n            } else{\n\n                *mbskip_ptr = 0; /* not skipped */\n\n            }\n\n        }\n\n\n\n        dct_linesize = linesize << s->interlaced_dct;\n\n        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;\n\n\n\n        if(readable){\n\n            dest_y=  s->dest[0];\n\n            dest_cb= s->dest[1];\n\n            dest_cr= s->dest[2];\n\n        }else{\n\n            dest_y = s->sc.b_scratchpad;\n\n            dest_cb= s->sc.b_scratchpad+16*linesize;\n\n            dest_cr= s->sc.b_scratchpad+32*linesize;\n\n        }\n\n\n\n        if (!s->mb_intra) {\n\n            /* motion handling */\n\n            /* decoding or more than one mb_type (MC was already done otherwise) */\n\n            if(!s->encoding){\n\n\n\n                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {\n\n                    if (s->mv_dir & MV_DIR_FORWARD) {\n\n                        ff_thread_await_progress(&s->last_picture_ptr->tf,\n\n                                                 lowest_referenced_row(s, 0),\n\n                                                 0);\n\n                    }\n\n                    if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                        ff_thread_await_progress(&s->next_picture_ptr->tf,\n\n                                                 lowest_referenced_row(s, 1),\n\n                                                 0);\n\n                    }\n\n                }\n\n\n\n                op_qpix= s->me.qpel_put;\n\n                if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){\n\n                    op_pix = s->hdsp.put_pixels_tab;\n\n                }else{\n\n                    op_pix = s->hdsp.put_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_FORWARD) {\n\n                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);\n\n                    op_pix = s->hdsp.avg_pixels_tab;\n\n                    op_qpix= s->me.qpel_avg;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* skip dequant / idct if we are really late ;) */\n\n            if(s->avctx->skip_idct){\n\n                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)\n\n                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)\n\n                   || s->avctx->skip_idct >= AVDISCARD_ALL)\n\n                    goto skip_idct;\n\n            }\n\n\n\n            /* add dct residue */\n\n            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO\n\n                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){\n\n                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n\n                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n\n                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n\n                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if (s->chroma_y_shift){\n\n                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n\n                    }else{\n\n                        dct_linesize >>= 1;\n\n                        dct_offset >>=1;\n\n                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n\n                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n\n                    }\n\n                }\n\n            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){\n\n                add_dct(s, block[0], 0, dest_y                          , dct_linesize);\n\n                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);\n\n                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);\n\n                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if(s->chroma_y_shift){//Chroma420\n\n                        add_dct(s, block[4], 4, dest_cb, uvlinesize);\n\n                        add_dct(s, block[5], 5, dest_cr, uvlinesize);\n\n                    }else{\n\n                        //chroma422\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;\n\n\n\n                        add_dct(s, block[4], 4, dest_cb, dct_linesize);\n\n                        add_dct(s, block[5], 5, dest_cr, dct_linesize);\n\n                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);\n\n                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);\n\n                        if(!s->chroma_x_shift){//Chroma444\n\n                            add_dct(s, block[8], 8, dest_cb+8, dct_linesize);\n\n                            add_dct(s, block[9], 9, dest_cr+8, dct_linesize);\n\n                            add_dct(s, block[10], 10, dest_cb+8+dct_offset, dct_linesize);\n\n                            add_dct(s, block[11], 11, dest_cr+8+dct_offset, dct_linesize);\n\n                        }\n\n                    }\n\n                }//fi gray\n\n            }\n\n            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {\n\n                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);\n\n            }\n\n        } else {\n\n            /* dct only in intra block */\n\n            if(s->encoding || !(s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO)){\n\n                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);\n\n                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);\n\n                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);\n\n                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if(s->chroma_y_shift){\n\n                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);\n\n                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);\n\n                    }else{\n\n                        dct_offset >>=1;\n\n                        dct_linesize >>=1;\n\n                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);\n\n                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);\n\n                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);\n\n                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);\n\n                    }\n\n                }\n\n            }else{\n\n                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);\n\n                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);\n\n                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);\n\n                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);\n\n\n\n                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {\n\n                    if(s->chroma_y_shift){\n\n                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);\n\n                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);\n\n                    }else{\n\n\n\n                        dct_linesize = uvlinesize << s->interlaced_dct;\n\n                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;\n\n\n\n                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);\n\n                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);\n\n                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);\n\n                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);\n\n                        if(!s->chroma_x_shift){//Chroma444\n\n                            s->idsp.idct_put(dest_cb + 8,              dct_linesize, block[8]);\n\n                            s->idsp.idct_put(dest_cr + 8,              dct_linesize, block[9]);\n\n                            s->idsp.idct_put(dest_cb + 8 + dct_offset, dct_linesize, block[10]);\n\n                            s->idsp.idct_put(dest_cr + 8 + dct_offset, dct_linesize, block[11]);\n\n                        }\n\n                    }\n\n                }//gray\n\n            }\n\n        }\n\nskip_idct:\n\n        if(!readable){\n\n            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);\n\n            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);\n\n            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);\n\n        }\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/108", "input": "static void sha256_transform(uint32_t *state, const uint8_t buffer[64])\n\n{\n\n    unsigned int i, a, b, c, d, e, f, g, h;\n\n    uint32_t block[64];\n\n    uint32_t T1;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n    f = state[5];\n\n    g = state[6];\n\n    h = state[7];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 64; i++) {\n\n        uint32_t T2;\n\n        if (i < 16)\n\n            T1 = blk0(i);\n\n        else\n\n            T1 = blk(i);\n\n        T1 += h + Sigma1_256(e) + Ch(e, f, g) + K256[i];\n\n        T2 = Sigma0_256(a) + Maj(a, b, c);\n\n        h = g;\n\n        g = f;\n\n        f = e;\n\n        e = d + T1;\n\n        d = c;\n\n        c = b;\n\n        b = a;\n\n        a = T1 + T2;\n\n    }\n\n#else\n\n    for (i = 0; i < 16;) {\n\n        ROUND256_0_TO_15(a, b, c, d, e, f, g, h);\n\n        ROUND256_0_TO_15(h, a, b, c, d, e, f, g);\n\n        ROUND256_0_TO_15(g, h, a, b, c, d, e, f);\n\n        ROUND256_0_TO_15(f, g, h, a, b, c, d, e);\n\n        ROUND256_0_TO_15(e, f, g, h, a, b, c, d);\n\n        ROUND256_0_TO_15(d, e, f, g, h, a, b, c);\n\n        ROUND256_0_TO_15(c, d, e, f, g, h, a, b);\n\n        ROUND256_0_TO_15(b, c, d, e, f, g, h, a);\n\n    }\n\n\n\n    for (; i < 64;) {\n\n        ROUND256_16_TO_63(a, b, c, d, e, f, g, h);\n\n        ROUND256_16_TO_63(h, a, b, c, d, e, f, g);\n\n        ROUND256_16_TO_63(g, h, a, b, c, d, e, f);\n\n        ROUND256_16_TO_63(f, g, h, a, b, c, d, e);\n\n        ROUND256_16_TO_63(e, f, g, h, a, b, c, d);\n\n        ROUND256_16_TO_63(d, e, f, g, h, a, b, c);\n\n        ROUND256_16_TO_63(c, d, e, f, g, h, a, b);\n\n        ROUND256_16_TO_63(b, c, d, e, f, g, h, a);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n    state[5] += f;\n\n    state[6] += g;\n\n    state[7] += h;\n\n}\n", "target": false}
{"task_id": "defect/train/109", "input": "static void device_finalize(Object *obj)\n\n{\n\n    NamedGPIOList *ngl, *next;\n\n\n\n    DeviceState *dev = DEVICE(obj);\n\n    qemu_opts_del(dev->opts);\n\n\n\n    QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) {\n\n        QLIST_REMOVE(ngl, node);\n\n        qemu_free_irqs(ngl->in, ngl->num_in);\n\n        g_free(ngl->name);\n\n        g_free(ngl);\n\n        /* ngl->out irqs are owned by the other end and should not be freed\n\n         * here\n\n         */\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/110", "input": "static int vdi_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.signature != VDI_SIGNATURE) {\n\n        error_setg(errp, \"Image not in VDI format (bad signature %08x)\", header.signature);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else if (header.version != VDI_VERSION_1_1) {\n\n        error_setg(errp, \"unsupported VDI image (version %u.%u)\",\n\n                   header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned block map offset \"\n\n                   \"0x%x)\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned data offset 0x%x)\",\n\n                   header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.sector_size, SECTOR_SIZE);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.block_size, 1 * MiB);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        error_setg(errp, \"unsupported VDI image (disk size %\" PRIu64 \", \"\n\n                   \"image bitmap has room for %\" PRIu64 \")\",\n\n                   header.disk_size,\n\n                   (uint64_t)header.blocks_in_image * header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL link UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL parent UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "target": true}
{"task_id": "defect/train/111", "input": "static void i440fx_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = i440fx_initfn;\n\n    k->config_write = i440fx_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82441;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"Host bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_i440fx;\n\n}\n", "target": true}
{"task_id": "defect/train/112", "input": "int yuv2rgb_c_init_tables (SwsContext *c, const int inv_table[4], int fullRange, int brightness, int contrast, int saturation)\n\n{\n\n    const int isRgb = isBGR(c->dstFormat);\n\n    const int bpp = fmt_depth(c->dstFormat);\n\n    int i;\n\n    uint8_t table_Y[1024];\n\n    uint32_t *table_32 = 0;\n\n    uint16_t *table_16 = 0;\n\n    uint8_t *table_8 = 0;\n\n    uint8_t *table_332 = 0;\n\n    uint8_t *table_121 = 0;\n\n    uint8_t *table_1 = 0;\n\n    int entry_size = 0;\n\n    void *table_r = 0, *table_g = 0, *table_b = 0;\n\n    void *table_start;\n\n\n\n    int64_t crv =  inv_table[0];\n\n    int64_t cbu =  inv_table[1];\n\n    int64_t cgu = -inv_table[2];\n\n    int64_t cgv = -inv_table[3];\n\n    int64_t cy  = 1<<16;\n\n    int64_t oy  = 0;\n\n\n\n//printf(\"%lld %lld %lld %lld %lld\\n\", cy, crv, cbu, cgu, cgv);\n\n    if(!fullRange){\n\n\tcy= (cy*255) / 219;\n\n\toy= 16<<16;\n\n    }else{\n\n        crv= (crv*224) / 255;\n\n        cbu= (cbu*224) / 255;\n\n        cgu= (cgu*224) / 255;\n\n        cgv= (cgv*224) / 255;\n\n    }\n\n\n\n    cy = (cy *contrast             )>>16;\n\n    crv= (crv*contrast * saturation)>>32;\n\n    cbu= (cbu*contrast * saturation)>>32;\n\n    cgu= (cgu*contrast * saturation)>>32;\n\n    cgv= (cgv*contrast * saturation)>>32;\n\n//printf(\"%lld %lld %lld %lld %lld\\n\", cy, crv, cbu, cgu, cgv);\n\n    oy -= 256*brightness;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n\tint j;\n\n\n\n\tj= (cy*(((i - 384)<<16) - oy) + (1<<31))>>32;\n\n\tj = (j < 0) ? 0 : ((j > 255) ? 255 : j);\n\n\ttable_Y[i] = j;\n\n    }\n\n\n\n    switch (bpp) {\n\n    case 32:\n\n\ttable_start= table_32 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint32_t));\n\n\n\n\tentry_size = sizeof (uint32_t);\n\n\ttable_r = table_32 + 197;\n\n\ttable_b = table_32 + 197 + 685;\n\n\ttable_g = table_32 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++)\n\n\t    ((uint32_t *)table_r)[i] = table_Y[i+384] << (isRgb ? 16 : 0);\n\n\tfor (i = -132; i < 256+132; i++)\n\n\t    ((uint32_t *)table_g)[i] = table_Y[i+384] << 8;\n\n\tfor (i = -232; i < 256+232; i++)\n\n\t    ((uint32_t *)table_b)[i] = table_Y[i+384] << (isRgb ? 0 : 16);\n\n\tbreak;\n\n\n\n    case 24:\n\n\ttable_start= table_8 = av_malloc ((256 + 2*232) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_g = table_b = table_8 + 232;\n\n\n\n\tfor (i = -232; i < 256+232; i++)\n\n\t    ((uint8_t * )table_b)[i] = table_Y[i+384];\n\n\tbreak;\n\n\n\n    case 15:\n\n    case 16:\n\n\ttable_start= table_16 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint16_t));\n\n\n\n\tentry_size = sizeof (uint16_t);\n\n\ttable_r = table_16 + 197;\n\n\ttable_b = table_16 + 197 + 685;\n\n\ttable_g = table_16 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = table_Y[i+384] >> 3;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= ((bpp==16) ? 11 : 10);\n\n\n\n\t    ((uint16_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = table_Y[i+384] >> ((bpp==16) ? 2 : 3);\n\n\n\n\t    ((uint16_t *)table_g)[i] = j << 5;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j = table_Y[i+384] >> 3;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= ((bpp==16) ? 11 : 10);\n\n\n\n\t    ((uint16_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    case 8:\n\n\ttable_start= table_332 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_332 + 197;\n\n\ttable_b = table_332 + 197 + 685;\n\n\ttable_g = table_332 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = (table_Y[i+384 - 16] + 18)/36;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= 5;\n\n\n\n\t    ((uint8_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = (table_Y[i+384 - 16] + 18)/36;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 1;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j << 2;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j = (table_Y[i+384 - 37] + 43)/85;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 6;\n\n\n\n\t    ((uint8_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n    case 4:\n\n    case 4|128:\n\n\ttable_start= table_121 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_121 + 197;\n\n\ttable_b = table_121 + 197 + 685;\n\n\ttable_g = table_121 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = table_Y[i+384 - 110] >> 7;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= 3;\n\n\n\n\t    ((uint8_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = (table_Y[i+384 - 37]+ 43)/85;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j << 1;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j =table_Y[i+384 - 110] >> 7;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 3;\n\n\n\n\t    ((uint8_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    case 1:\n\n\ttable_start= table_1 = av_malloc (256*2 * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_g = table_1;\n\n\ttable_r = table_b = NULL;\n\n\n\n\tfor (i = 0; i < 256+256; i++) {\n\n\t    int j = table_Y[i + 384 - 110]>>7;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    default:\n\n\ttable_start= NULL;\n\n\tav_log(c, AV_LOG_ERROR, \"%ibpp not supported by yuv2rgb\\n\", bpp);\n\n\t//free mem?\n\n\treturn -1;\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n\tc->table_rV[i] = (uint8_t *)table_r + entry_size * div_round (crv * (i-128), 76309);\n\n\tc->table_gU[i] = (uint8_t *)table_g + entry_size * div_round (cgu * (i-128), 76309);\n\n\tc->table_gV[i] = entry_size * div_round (cgv * (i-128), 76309);\n\n\tc->table_bU[i] = (uint8_t *)table_b + entry_size * div_round (cbu * (i-128), 76309);\n\n    }\n\n\n\n    av_free(c->yuvTable);\n\n    c->yuvTable= table_start;\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/113", "input": "target_ulong helper_udiv(target_ulong a, target_ulong b)\n\n{\n\n    uint64_t x0;\n\n    uint32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if (x0 > 0xffffffff) {\n\n        env->cc_src2 = 1;\n\n        return 0xffffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/114", "input": "static direntry_t *create_short_filename(BDRVVVFATState *s,\n\n                                         const char *filename,\n\n                                         unsigned int directory_start)\n\n{\n\n    int i, j = 0;\n\n    direntry_t *entry = array_get_next(&(s->directory));\n\n    const gchar *p, *last_dot = NULL;\n\n    gunichar c;\n\n    bool lossy_conversion = false;\n\n    char tail[11];\n\n\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n    memset(entry->name, 0x20, sizeof(entry->name));\n\n\n\n    /* copy filename and search last dot */\n\n    for (p = filename; ; p = g_utf8_next_char(p)) {\n\n        c = g_utf8_get_char(p);\n\n        if (c == '\\0') {\n\n            break;\n\n        } else if (c == '.') {\n\n            if (j == 0) {\n\n                /* '.' at start of filename */\n\n                lossy_conversion = true;\n\n            } else {\n\n                if (last_dot) {\n\n                    lossy_conversion = true;\n\n                }\n\n                last_dot = p;\n\n            }\n\n        } else if (!last_dot) {\n\n            /* first part of the name; copy it */\n\n            uint8_t v = to_valid_short_char(c);\n\n            if (j < 8 && v) {\n\n                entry->name[j++] = v;\n\n            } else {\n\n                lossy_conversion = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* copy extension (if any) */\n\n    if (last_dot) {\n\n        j = 0;\n\n        for (p = g_utf8_next_char(last_dot); ; p = g_utf8_next_char(p)) {\n\n            c = g_utf8_get_char(p);\n\n            if (c == '\\0') {\n\n                break;\n\n            } else {\n\n                /* extension; copy it */\n\n                uint8_t v = to_valid_short_char(c);\n\n                if (j < 3 && v) {\n\n                    entry->name[8 + (j++)] = v;\n\n                } else {\n\n                    lossy_conversion = true;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (entry->name[0] == DIR_KANJI) {\n\n        entry->name[0] = DIR_KANJI_FAKE;\n\n    }\n\n\n\n    /* numeric-tail generation */\n\n    for (j = 0; j < 8; j++) {\n\n        if (entry->name[j] == ' ') {\n\n            break;\n\n        }\n\n    }\n\n    for (i = lossy_conversion ? 1 : 0; i < 999999; i++) {\n\n        direntry_t *entry1;\n\n        if (i > 0) {\n\n            int len = sprintf(tail, \"~%d\", i);\n\n            memcpy(entry->name + MIN(j, 8 - len), tail, len);\n\n        }\n\n        for (entry1 = array_get(&(s->directory), directory_start);\n\n             entry1 < entry; entry1++) {\n\n            if (!is_long_name(entry1) &&\n\n                !memcmp(entry1->name, entry->name, 11)) {\n\n                break; /* found dupe */\n\n            }\n\n        }\n\n        if (entry1 == entry) {\n\n            /* no dupe found */\n\n            return entry;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "target": true}
{"task_id": "defect/train/115", "input": "void ff_print_debug_info(MpegEncContext *s, Picture *p)\n\n{\n\n    AVFrame *pict;\n\n    if (s->avctx->hwaccel || !p || !p->mb_type)\n\n        return;\n\n    pict = &p->f;\n\n\n\n    if (s->avctx->debug & (FF_DEBUG_SKIP | FF_DEBUG_QP | FF_DEBUG_MB_TYPE)) {\n\n        int x,y;\n\n\n\n        av_log(s->avctx,AV_LOG_DEBUG,\"New frame, type: \");\n\n        switch (pict->pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"I\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"P\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"B\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_S:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"S\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_SI:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"SI\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_SP:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"SP\\n\");\n\n            break;\n\n        }\n\n        for (y = 0; y < s->mb_height; y++) {\n\n            for (x = 0; x < s->mb_width; x++) {\n\n                if (s->avctx->debug & FF_DEBUG_SKIP) {\n\n                    int count = s->mbskip_table[x + y * s->mb_stride];\n\n                    if (count > 9)\n\n                        count = 9;\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"%1d\", count);\n\n                }\n\n                if (s->avctx->debug & FF_DEBUG_QP) {\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"%2d\",\n\n                           p->qscale_table[x + y * s->mb_stride]);\n\n                }\n\n                if (s->avctx->debug & FF_DEBUG_MB_TYPE) {\n\n                    int mb_type = p->mb_type[x + y * s->mb_stride];\n\n                    // Type & MV direction\n\n                    if (IS_PCM(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"P\");\n\n                    else if (IS_INTRA(mb_type) && IS_ACPRED(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"A\");\n\n                    else if (IS_INTRA4x4(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"i\");\n\n                    else if (IS_INTRA16x16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"I\");\n\n                    else if (IS_DIRECT(mb_type) && IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"d\");\n\n                    else if (IS_DIRECT(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"D\");\n\n                    else if (IS_GMC(mb_type) && IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"g\");\n\n                    else if (IS_GMC(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"G\");\n\n                    else if (IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"S\");\n\n                    else if (!USES_LIST(mb_type, 1))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \">\");\n\n                    else if (!USES_LIST(mb_type, 0))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"<\");\n\n                    else {\n\n                        assert(USES_LIST(mb_type, 0) && USES_LIST(mb_type, 1));\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"X\");\n\n                    }\n\n\n\n                    // segmentation\n\n                    if (IS_8X8(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"+\");\n\n                    else if (IS_16X8(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"-\");\n\n                    else if (IS_8X16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"|\");\n\n                    else if (IS_INTRA(mb_type) || IS_16X16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \" \");\n\n                    else\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"?\");\n\n\n\n\n\n                    if (IS_INTERLACED(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"=\");\n\n                    else\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \" \");\n\n                }\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n        }\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/116", "input": "static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,\n\n    int dest_len)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    const unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetBitContext gb;\n\n\n\n    init_get_bits(&gb, ptr, 0); // FIXME: no src size available\n\n\n\n    while ( val != 0x16 ) {\n\n        val = src[val - 0x17 + get_bits1(&gb) * byte];\n\n\n\n        if ( val < 0x16 ) {\n\n            if (dest + 1 > dest_end)\n\n                return 0;\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/117", "input": "static int kvm_log_stop(CPUPhysMemoryClient *client,\n\n                        target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n    return kvm_dirty_pages_log_change(phys_addr, size, false);\n\n}\n", "target": true}
{"task_id": "defect/train/118", "input": "void MPV_common_end(MpegEncContext *s)\n\n{\n\n    int i;\n\n\n\n    if (s->motion_val)\n\n        free(s->motion_val);\n\n    if (s->h263_pred) {\n\n        free(s->dc_val[0]);\n\n        free(s->ac_val[0]);\n\n        free(s->coded_block);\n\n        free(s->mbintra_table);\n\n    }\n\n    if (s->mbskip_table)\n\n        free(s->mbskip_table);\n\n    for(i=0;i<3;i++) {\n\n        free(s->last_picture_base[i]);\n\n        free(s->next_picture_base[i]);\n\n        if (s->has_b_frames)\n\n            free(s->aux_picture_base[i]);\n\n    }\n\n    s->context_initialized = 0;\n\n}\n", "target": true}
{"task_id": "defect/train/119", "input": "static void blkdebug_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QDict *opts;\n\n    const QDictEntry *e;\n\n    bool force_json = false;\n\n\n\n    for (e = qdict_first(options); e; e = qdict_next(options, e)) {\n\n        if (strcmp(qdict_entry_key(e), \"config\") &&\n\n            strcmp(qdict_entry_key(e), \"x-image\"))\n\n        {\n\n            force_json = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (force_json && !bs->file->bs->full_open_options) {\n\n        /* The config file cannot be recreated, so creating a plain filename\n\n         * is impossible */\n\n        return;\n\n    }\n\n\n\n    if (!force_json && bs->file->bs->exact_filename[0]) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"blkdebug:%s:%s\", s->config_file ?: \"\",\n\n                 bs->file->bs->exact_filename);\n\n    }\n\n\n\n    opts = qdict_new();\n\n    qdict_put_str(opts, \"driver\", \"blkdebug\");\n\n\n\n    QINCREF(bs->file->bs->full_open_options);\n\n    qdict_put(opts, \"image\", bs->file->bs->full_open_options);\n\n\n\n    for (e = qdict_first(options); e; e = qdict_next(options, e)) {\n\n        if (strcmp(qdict_entry_key(e), \"x-image\")) {\n\n            qobject_incref(qdict_entry_value(e));\n\n            qdict_put_obj(opts, qdict_entry_key(e), qdict_entry_value(e));\n\n        }\n\n    }\n\n\n\n    bs->full_open_options = opts;\n\n}\n", "target": true}
{"task_id": "defect/train/120", "input": "static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,\n\n                USBPacket *p)\n\n{\n\n    int len;\n\n\n\n    if (likely(!fifo->len))\n\n        return USB_RET_STALL;\n\n\n\n    len = MIN(p->len, fifo->fifo[fifo->start].len);\n\n    memcpy(p->data, fifo->fifo[fifo->start].data, len);\n\n    if (len == p->len) {\n\n        fifo->fifo[fifo->start].len -= len;\n\n        fifo->fifo[fifo->start].data += len;\n\n    } else {\n\n        fifo->start ++;\n\n        fifo->start &= CFIFO_LEN_MASK;\n\n        fifo->len --;\n\n    }\n\n\n\n    fifo->dstart += len;\n\n    fifo->dlen -= len;\n\n    if (fifo->dstart >= fifo->dsize) {\n\n        fifo->dstart = 0;\n\n        fifo->dsize = DFIFO_LEN_MASK + 1;\n\n    }\n\n\n\n    return len;\n\n}\n", "target": true}
{"task_id": "defect/train/121", "input": "static int block_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    static int banner_printed;\n\n    int len, flags;\n\n    char device_name[256];\n\n    int64_t addr;\n\n    BlockDriverState *bs;\n\n    uint8_t *buf;\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~BDRV_SECTOR_MASK;\n\n        addr >>= BDRV_SECTOR_BITS;\n\n\n\n        if (flags & BLK_MIG_FLAG_DEVICE_BLOCK) {\n\n            int ret;\n\n            /* get device name */\n\n            len = qemu_get_byte(f);\n\n            qemu_get_buffer(f, (uint8_t *)device_name, len);\n\n            device_name[len] = '\\0';\n\n\n\n            bs = bdrv_find(device_name);\n\n            if (!bs) {\n\n                fprintf(stderr, \"Error unknown block device %s\\n\",\n\n                        device_name);\n\n                return -EINVAL;\n\n            }\n\n\n\n            buf = qemu_malloc(BLOCK_SIZE);\n\n\n\n            qemu_get_buffer(f, buf, BLOCK_SIZE);\n\n            ret = bdrv_write(bs, addr, buf, BDRV_SECTORS_PER_DIRTY_CHUNK);\n\n\n\n            qemu_free(buf);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n        } else if (flags & BLK_MIG_FLAG_PROGRESS) {\n\n            if (!banner_printed) {\n\n                printf(\"Receiving block device images\\n\");\n\n                banner_printed = 1;\n\n            }\n\n            printf(\"Completed %d %%%c\", (int)addr,\n\n                   (addr == 100) ? '\\n' : '\\r');\n\n            fflush(stdout);\n\n        } else if (!(flags & BLK_MIG_FLAG_EOS)) {\n\n            fprintf(stderr, \"Unknown flags\\n\");\n\n            return -EINVAL;\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & BLK_MIG_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/122", "input": "static int alsa_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceIn *alsa = (ALSAVoiceIn *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_in;\n\n    req.buffer_size = conf.buffer_size_in;\n\n    req.size_in_usec = conf.size_in_usec_in;\n\n    req.override_mask =\n\n        (conf.period_size_in_overridden ? 1 : 0) |\n\n        (conf.buffer_size_in_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (1, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate ADC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/123", "input": "static uint32_t m5206_mbar_readb(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    if (m5206_mbar_width[offset >> 2] > 1) {\n\n        uint16_t val;\n\n        val = m5206_mbar_readw(opaque, offset & ~1);\n\n        if ((offset & 1) == 0) {\n\n            val >>= 8;\n\n        }\n\n        return val & 0xff;\n\n    }\n\n    return m5206_mbar_read(s, offset, 1);\n\n}\n", "target": true}
{"task_id": "defect/train/124", "input": "static int vnc_zlib_stop(VncState *vs, int stream_id)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream[stream_id];\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream %d\\n\", stream_id);\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = Z_NULL;\n\n        zstream->zfree = Z_NULL;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    // XXX what to do if tight_compression changed in between?\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "target": true}
{"task_id": "defect/train/125", "input": "static int flac_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    FLACParseContext *fpc = s->priv_data;\n\n    FLACHeaderMarker *curr;\n\n    int nb_headers;\n\n    const uint8_t *read_end   = buf;\n\n    const uint8_t *read_start = buf;\n\n\n\n    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {\n\n        FLACFrameInfo fi;\n\n        if (frame_header_is_valid(avctx, buf, &fi)) {\n\n            s->duration = fi.blocksize;\n\n            if (!avctx->sample_rate)\n\n                avctx->sample_rate = fi.samplerate;\n\n            if (fpc->pc->flags & PARSER_FLAG_USE_CODEC_TS){\n\n                fpc->pc->pts = fi.frame_or_sample_num;\n\n                if (!fi.is_var_size)\n\n                  fpc->pc->pts *= fi.blocksize;\n\n            }\n\n        }\n\n        *poutbuf      = buf;\n\n        *poutbuf_size = buf_size;\n\n        return buf_size;\n\n    }\n\n\n\n    fpc->avctx = avctx;\n\n    if (fpc->best_header_valid)\n\n        return get_best_header(fpc, poutbuf, poutbuf_size);\n\n\n\n    /* If a best_header was found last call remove it with the buffer data. */\n\n    if (fpc->best_header && fpc->best_header->best_child) {\n\n        FLACHeaderMarker *temp;\n\n        FLACHeaderMarker *best_child = fpc->best_header->best_child;\n\n\n\n        /* Remove headers in list until the end of the best_header. */\n\n        for (curr = fpc->headers; curr != best_child; curr = temp) {\n\n            if (curr != fpc->best_header) {\n\n                av_log(avctx, AV_LOG_DEBUG,\n\n                       \"dropping low score %i frame header from offset %i to %i\\n\",\n\n                       curr->max_score, curr->offset, curr->next->offset);\n\n            }\n\n            temp = curr->next;\n\n            av_freep(&curr->link_penalty);\n\n            av_free(curr);\n\n\n        }\n\n        /* Release returned data from ring buffer. */\n\n        av_fifo_drain(fpc->fifo_buf, best_child->offset);\n\n\n\n        /* Fix the offset for the headers remaining to match the new buffer. */\n\n        for (curr = best_child->next; curr; curr = curr->next)\n\n            curr->offset -= best_child->offset;\n\n\n\n\n        best_child->offset = 0;\n\n        fpc->headers       = best_child;\n\n        if (fpc->nb_headers_buffered >= FLAC_MIN_HEADERS) {\n\n            fpc->best_header = best_child;\n\n            return get_best_header(fpc, poutbuf, poutbuf_size);\n\n        }\n\n        fpc->best_header   = NULL;\n\n    } else if (fpc->best_header) {\n\n        /* No end frame no need to delete the buffer; probably eof */\n\n        FLACHeaderMarker *temp;\n\n\n\n        for (curr = fpc->headers; curr != fpc->best_header; curr = temp) {\n\n            temp = curr->next;\n\n            av_freep(&curr->link_penalty);\n\n            av_free(curr);\n\n\n        }\n\n        fpc->headers = fpc->best_header->next;\n\n        av_freep(&fpc->best_header->link_penalty);\n\n        av_freep(&fpc->best_header);\n\n\n    }\n\n\n\n    /* Find and score new headers.                                     */\n\n    /* buf_size is to zero when padding, so check for this since we do */\n\n    /* not want to try to read more input once we have found the end.  */\n\n    /* Note that as (non-modified) parameters, buf can be non-NULL,    */\n\n    /* while buf_size is 0.                                            */\n\n    while ((buf && buf_size && read_end < buf + buf_size &&\n\n            fpc->nb_headers_buffered < FLAC_MIN_HEADERS)\n\n           || ((!buf || !buf_size) && !fpc->end_padded)) {\n\n        int start_offset;\n\n\n\n        /* Pad the end once if EOF, to check the final region for headers. */\n\n        if (!buf || !buf_size) {\n\n            fpc->end_padded      = 1;\n\n            buf_size = MAX_FRAME_HEADER_SIZE;\n\n            read_end = read_start + MAX_FRAME_HEADER_SIZE;\n\n        } else {\n\n            /* The maximum read size is the upper-bound of what the parser\n\n               needs to have the required number of frames buffered */\n\n            int nb_desired = FLAC_MIN_HEADERS - fpc->nb_headers_buffered + 1;\n\n            read_end       = read_end + FFMIN(buf + buf_size - read_end,\n\n                                              nb_desired * FLAC_AVG_FRAME_SIZE);\n\n        }\n\n\n\n        if (!av_fifo_space(fpc->fifo_buf) &&\n\n            av_fifo_size(fpc->fifo_buf) / FLAC_AVG_FRAME_SIZE >\n\n            fpc->nb_headers_buffered * 20) {\n\n            /* There is less than one valid flac header buffered for 20 headers\n\n             * buffered. Therefore the fifo is most likely filled with invalid\n\n             * data and the input is not a flac file. */\n\n            goto handle_error;\n\n        }\n\n\n\n        /* Fill the buffer. */\n\n        if (   av_fifo_space(fpc->fifo_buf) < read_end - read_start\n\n            && av_fifo_realloc2(fpc->fifo_buf, (read_end - read_start) + 2*av_fifo_size(fpc->fifo_buf)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't reallocate buffer of size %\"PTRDIFF_SPECIFIER\"\\n\",\n\n                   (read_end - read_start) + av_fifo_size(fpc->fifo_buf));\n\n            goto handle_error;\n\n        }\n\n\n\n        if (buf && buf_size) {\n\n            av_fifo_generic_write(fpc->fifo_buf, (void*) read_start,\n\n                                  read_end - read_start, NULL);\n\n        } else {\n\n            int8_t pad[MAX_FRAME_HEADER_SIZE] = { 0 };\n\n            av_fifo_generic_write(fpc->fifo_buf, (void*) pad, sizeof(pad), NULL);\n\n        }\n\n\n\n        /* Tag headers and update sequences. */\n\n        start_offset = av_fifo_size(fpc->fifo_buf) -\n\n                       ((read_end - read_start) + (MAX_FRAME_HEADER_SIZE - 1));\n\n        start_offset = FFMAX(0, start_offset);\n\n        nb_headers   = find_new_headers(fpc, start_offset);\n\n\n\n        if (nb_headers < 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"find_new_headers couldn't allocate FLAC header\\n\");\n\n            goto handle_error;\n\n        }\n\n\n\n        fpc->nb_headers_buffered = nb_headers;\n\n        /* Wait till FLAC_MIN_HEADERS to output a valid frame. */\n\n        if (!fpc->end_padded && fpc->nb_headers_buffered < FLAC_MIN_HEADERS) {\n\n            if (buf && read_end < buf + buf_size) {\n\n                read_start = read_end;\n\n                continue;\n\n            } else {\n\n                goto handle_error;\n\n            }\n\n        }\n\n\n\n        /* If headers found, update the scores since we have longer chains. */\n\n        if (fpc->end_padded || fpc->nb_headers_found)\n\n            score_sequences(fpc);\n\n\n\n        /* restore the state pre-padding */\n\n        if (fpc->end_padded) {\n\n            int warp = fpc->fifo_buf->wptr - fpc->fifo_buf->buffer < MAX_FRAME_HEADER_SIZE;\n\n            /* HACK: drain the tail of the fifo */\n\n            fpc->fifo_buf->wptr -= MAX_FRAME_HEADER_SIZE;\n\n            fpc->fifo_buf->wndx -= MAX_FRAME_HEADER_SIZE;\n\n            if (warp) {\n\n                fpc->fifo_buf->wptr += fpc->fifo_buf->end -\n\n                    fpc->fifo_buf->buffer;\n\n            }\n\n            buf_size = 0;\n\n            read_start = read_end = NULL;\n\n        }\n\n    }\n\n\n\n    for (curr = fpc->headers; curr; curr = curr->next) {\n\n        if (curr->max_score > 0 &&\n\n            (!fpc->best_header || curr->max_score > fpc->best_header->max_score)) {\n\n            fpc->best_header = curr;\n\n        }\n\n    }\n\n\n\n    if (fpc->best_header) {\n\n        fpc->best_header_valid = 1;\n\n        if (fpc->best_header->offset > 0) {\n\n            /* Output a junk frame. */\n\n            av_log(avctx, AV_LOG_DEBUG, \"Junk frame till offset %i\\n\",\n\n                   fpc->best_header->offset);\n\n\n\n            /* Set duration to 0. It is unknown or invalid in a junk frame. */\n\n            s->duration = 0;\n\n            *poutbuf_size     = fpc->best_header->offset;\n\n            *poutbuf          = flac_fifo_read_wrap(fpc, 0, *poutbuf_size,\n\n                                                    &fpc->wrap_buf,\n\n                                                    &fpc->wrap_buf_allocated_size);\n\n            return buf_size ? (read_end - buf) : (fpc->best_header->offset -\n\n                                           av_fifo_size(fpc->fifo_buf));\n\n        }\n\n        if (!buf_size)\n\n            return get_best_header(fpc, poutbuf, poutbuf_size);\n\n    }\n\n\n\nhandle_error:\n\n    *poutbuf      = NULL;\n\n    *poutbuf_size = 0;\n\n    return buf_size ? read_end - buf : 0;\n\n}", "target": true}
{"task_id": "defect/train/126", "input": "int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,\n\n             const void *bits, int bits_wrap, int bits_size,\n\n             const void *codes, int codes_wrap, int codes_size,\n\n             const void *symbols, int symbols_wrap, int symbols_size,\n\n             int flags)\n\n{\n\n    VLCcode *buf;\n\n    int i, j, ret;\n\n\n\n    vlc->bits = nb_bits;\n\n    if(flags & INIT_VLC_USE_NEW_STATIC){\n\n        VLC dyn_vlc = *vlc;\n\n\n\n        if (vlc->table_size)\n\n            return 0;\n\n\n\n        ret = ff_init_vlc_sparse(&dyn_vlc, nb_bits, nb_codes,\n\n                                 bits, bits_wrap, bits_size,\n\n                                 codes, codes_wrap, codes_size,\n\n                                 symbols, symbols_wrap, symbols_size,\n\n                                 flags & ~INIT_VLC_USE_NEW_STATIC);\n\n        av_assert0(ret >= 0);\n\n        av_assert0(dyn_vlc.table_size <= vlc->table_allocated);\n\n        if(dyn_vlc.table_size < vlc->table_allocated)\n\n            av_log(NULL, AV_LOG_ERROR, \"needed %d had %d\\n\", dyn_vlc.table_size, vlc->table_allocated);\n\n        memcpy(vlc->table, dyn_vlc.table, dyn_vlc.table_size * sizeof(*vlc->table));\n\n        vlc->table_size = dyn_vlc.table_size;\n\n        ff_free_vlc(&dyn_vlc);\n\n        return 0;\n\n    }else {\n\n        vlc->table = NULL;\n\n        vlc->table_allocated = 0;\n\n        vlc->table_size = 0;\n\n    }\n\n\n\n    av_dlog(NULL, \"build table nb_codes=%d\\n\", nb_codes);\n\n\n\n    buf = av_malloc((nb_codes+1)*sizeof(VLCcode));\n\n\n\n    av_assert0(symbols_size <= 2 || !symbols);\n\n    j = 0;\n\n#define COPY(condition)\\\n\n    for (i = 0; i < nb_codes; i++) {\\\n\n        GET_DATA(buf[j].bits, bits, i, bits_wrap, bits_size);\\\n\n        if (!(condition))\\\n\n            continue;\\\n\n        if (buf[j].bits > 3*nb_bits || buf[j].bits>32) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Too long VLC in init_vlc\\n\");\\\n\n\n            return -1;\\\n\n        }\\\n\n        GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);\\\n\n        if (buf[j].code >= (1LL<<buf[j].bits)) {\\\n\n            av_log(NULL, AV_LOG_ERROR, \"Invalid code in init_vlc\\n\");\\\n\n\n            return -1;\\\n\n        }\\\n\n        if (flags & INIT_VLC_LE)\\\n\n            buf[j].code = bitswap_32(buf[j].code);\\\n\n        else\\\n\n            buf[j].code <<= 32 - buf[j].bits;\\\n\n        if (symbols)\\\n\n            GET_DATA(buf[j].symbol, symbols, i, symbols_wrap, symbols_size)\\\n\n        else\\\n\n            buf[j].symbol = i;\\\n\n        j++;\\\n\n    }\n\n    COPY(buf[j].bits > nb_bits);\n\n    // qsort is the slowest part of init_vlc, and could probably be improved or avoided\n\n    qsort(buf, j, sizeof(VLCcode), compare_vlcspec);\n\n    COPY(buf[j].bits && buf[j].bits <= nb_bits);\n\n    nb_codes = j;\n\n\n\n    ret = build_table(vlc, nb_bits, nb_codes, buf, flags);\n\n\n\n    av_free(buf);\n\n    if (ret < 0) {\n\n        av_freep(&vlc->table);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}", "target": true}
{"task_id": "defect/train/127", "input": "static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= 0;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb=\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n", "target": true}
{"task_id": "defect/train/128", "input": "static void cg3_initfn(Object *obj)\n\n{\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    CG3State *s = CG3(obj);\n\n\n\n    memory_region_init_ram(&s->rom, NULL, \"cg3.prom\", FCODE_MAX_ROM_SIZE,\n\n                           &error_abort);\n\n    memory_region_set_readonly(&s->rom, true);\n\n    sysbus_init_mmio(sbd, &s->rom);\n\n\n\n    memory_region_init_io(&s->reg, NULL, &cg3_reg_ops, s, \"cg3.reg\",\n\n                          CG3_REG_SIZE);\n\n    sysbus_init_mmio(sbd, &s->reg);\n\n}\n", "target": true}
{"task_id": "defect/train/129", "input": "int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)\n\n{\n\n    int id, sr, ch, ba, tag, bps;\n\n\n\n    id  = avctx->codec_id;\n\n    sr  = avctx->sample_rate;\n\n    ch  = avctx->channels;\n\n    ba  = avctx->block_align;\n\n    tag = avctx->codec_tag;\n\n    bps = av_get_exact_bits_per_sample(avctx->codec_id);\n\n\n\n    /* codecs with an exact constant bits per sample */\n\n    if (bps > 0 && ch > 0 && frame_bytes > 0)\n\n        return (frame_bytes * 8) / (bps * ch);\n\n    bps = avctx->bits_per_coded_sample;\n\n\n\n    /* codecs with a fixed packet duration */\n\n    switch (id) {\n\n    case CODEC_ID_ADPCM_ADX:    return   32;\n\n    case CODEC_ID_ADPCM_IMA_QT: return   64;\n\n    case CODEC_ID_ADPCM_EA_XAS: return  128;\n\n    case CODEC_ID_AMR_NB:\n\n    case CODEC_ID_GSM:\n\n    case CODEC_ID_QCELP:\n\n    case CODEC_ID_RA_144:\n\n    case CODEC_ID_RA_288:       return  160;\n\n    case CODEC_ID_IMC:          return  256;\n\n    case CODEC_ID_AMR_WB:\n\n    case CODEC_ID_GSM_MS:       return  320;\n\n    case CODEC_ID_MP1:          return  384;\n\n    case CODEC_ID_ATRAC1:       return  512;\n\n    case CODEC_ID_ATRAC3:       return 1024;\n\n    case CODEC_ID_MP2:\n\n    case CODEC_ID_MUSEPACK7:    return 1152;\n\n    case CODEC_ID_AC3:          return 1536;\n\n    }\n\n\n\n    if (sr > 0) {\n\n        /* calc from sample rate */\n\n        if (id == CODEC_ID_TTA)\n\n            return 256 * sr / 245;\n\n\n\n        if (ch > 0) {\n\n            /* calc from sample rate and channels */\n\n            if (id == CODEC_ID_BINKAUDIO_DCT)\n\n                return (480 << (sr / 22050)) / ch;\n\n        }\n\n    }\n\n\n\n    if (ba > 0) {\n\n        /* calc from block_align */\n\n        if (id == CODEC_ID_SIPR) {\n\n            switch (ba) {\n\n            case 20: return 160;\n\n            case 19: return 144;\n\n            case 29: return 288;\n\n            case 37: return 480;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (frame_bytes > 0) {\n\n        /* calc from frame_bytes only */\n\n        if (id == CODEC_ID_TRUESPEECH)\n\n            return 240 * (frame_bytes / 32);\n\n        if (id == CODEC_ID_NELLYMOSER)\n\n            return 256 * (frame_bytes / 64);\n\n\n\n        if (bps > 0) {\n\n            /* calc from frame_bytes and bits_per_coded_sample */\n\n            if (id == CODEC_ID_ADPCM_G726)\n\n                return frame_bytes * 8 / bps;\n\n        }\n\n\n\n        if (ch > 0) {\n\n            /* calc from frame_bytes and channels */\n\n            switch (id) {\n\n            case CODEC_ID_ADPCM_4XM:\n\n            case CODEC_ID_ADPCM_IMA_ISS:\n\n                return (frame_bytes - 4 * ch) * 2 / ch;\n\n            case CODEC_ID_ADPCM_IMA_SMJPEG:\n\n                return (frame_bytes - 4) * 2 / ch;\n\n            case CODEC_ID_ADPCM_IMA_AMV:\n\n                return (frame_bytes - 8) * 2 / ch;\n\n            case CODEC_ID_ADPCM_XA:\n\n                return (frame_bytes / 128) * 224 / ch;\n\n            case CODEC_ID_INTERPLAY_DPCM:\n\n                return (frame_bytes - 6 - ch) / ch;\n\n            case CODEC_ID_ROQ_DPCM:\n\n                return (frame_bytes - 8) / ch;\n\n            case CODEC_ID_XAN_DPCM:\n\n                return (frame_bytes - 2 * ch) / ch;\n\n            case CODEC_ID_MACE3:\n\n                return 3 * frame_bytes / ch;\n\n            case CODEC_ID_MACE6:\n\n                return 6 * frame_bytes / ch;\n\n            case CODEC_ID_PCM_LXF:\n\n                return 2 * (frame_bytes / (5 * ch));\n\n            }\n\n\n\n            if (tag) {\n\n                /* calc from frame_bytes, channels, and codec_tag */\n\n                if (id == CODEC_ID_SOL_DPCM) {\n\n                    if (tag == 3)\n\n                        return frame_bytes / ch;\n\n                    else\n\n                        return frame_bytes * 2 / ch;\n\n                }\n\n            }\n\n\n\n            if (ba > 0) {\n\n                /* calc from frame_bytes, channels, and block_align */\n\n                int blocks = frame_bytes / ba;\n\n                switch (avctx->codec_id) {\n\n                case CODEC_ID_ADPCM_IMA_WAV:\n\n                    return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);\n\n                case CODEC_ID_ADPCM_IMA_DK3:\n\n                    return blocks * (((ba - 16) * 2 / 3 * 4) / ch);\n\n                case CODEC_ID_ADPCM_IMA_DK4:\n\n                    return blocks * (1 + (ba - 4 * ch) * 2 / ch);\n\n                case CODEC_ID_ADPCM_MS:\n\n                    return blocks * (2 + (ba - 7 * ch) * 2 / ch);\n\n                }\n\n            }\n\n\n\n            if (bps > 0) {\n\n                /* calc from frame_bytes, channels, and bits_per_coded_sample */\n\n                switch (avctx->codec_id) {\n\n                case CODEC_ID_PCM_DVD:\n\n                    return 2 * (frame_bytes / ((bps * 2 / 8) * ch));\n\n                case CODEC_ID_PCM_BLURAY:\n\n                    return frame_bytes / ((FFALIGN(ch, 2) * bps) / 8);\n\n                case CODEC_ID_S302M:\n\n                    return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/130", "input": "static void parse_context_init(SchroParseUnitContext *parse_ctx,\n\n                               const uint8_t *buf, int buf_size)\n\n{\n\n    parse_ctx->buf           = buf;\n\n    parse_ctx->buf_size      = buf_size;\n\n}\n", "target": true}
{"task_id": "defect/train/131", "input": "static int update_size(AVCodecContext *ctx, int w, int h)\n\n{\n\n    VP9Context *s = ctx->priv_data;\n\n    uint8_t *p;\n\n\n\n    if (s->above_partition_ctx && w == ctx->width && h == ctx->height)\n\n        return 0;\n\n\n\n    ctx->width  = w;\n\n    ctx->height = h;\n\n    s->sb_cols  = (w + 63) >> 6;\n\n    s->sb_rows  = (h + 63) >> 6;\n\n    s->cols     = (w + 7) >> 3;\n\n    s->rows     = (h + 7) >> 3;\n\n\n\n#define assign(var, type, n) var = (type) p; p += s->sb_cols * n * sizeof(*var)\n\n    av_free(s->above_partition_ctx);\n\n    p = av_malloc(s->sb_cols * (240 + sizeof(*s->lflvl) + 16 * sizeof(*s->above_mv_ctx) +\n\n                                64 * s->sb_rows * (1 + sizeof(*s->mv[0]) * 2)));\n\n    if (!p)\n\n        return AVERROR(ENOMEM);\n\n    assign(s->above_partition_ctx, uint8_t *,              8);\n\n    assign(s->above_skip_ctx,      uint8_t *,              8);\n\n    assign(s->above_txfm_ctx,      uint8_t *,              8);\n\n    assign(s->above_mode_ctx,      uint8_t *,             16);\n\n    assign(s->above_y_nnz_ctx,     uint8_t *,             16);\n\n    assign(s->above_uv_nnz_ctx[0], uint8_t *,              8);\n\n    assign(s->above_uv_nnz_ctx[1], uint8_t *,              8);\n\n    assign(s->intra_pred_data[0],  uint8_t *,             64);\n\n    assign(s->intra_pred_data[1],  uint8_t *,             32);\n\n    assign(s->intra_pred_data[2],  uint8_t *,             32);\n\n    assign(s->above_segpred_ctx,   uint8_t *,              8);\n\n    assign(s->above_intra_ctx,     uint8_t *,              8);\n\n    assign(s->above_comp_ctx,      uint8_t *,              8);\n\n    assign(s->above_ref_ctx,       uint8_t *,              8);\n\n    assign(s->above_filter_ctx,    uint8_t *,              8);\n\n    assign(s->lflvl,               struct VP9Filter *,     1);\n\n    assign(s->above_mv_ctx,        VP56mv(*)[2],          16);\n\n    assign(s->segmentation_map,    uint8_t *,             64 * s->sb_rows);\n\n    assign(s->mv[0],               struct VP9mvrefPair *, 64 * s->sb_rows);\n\n    assign(s->mv[1],               struct VP9mvrefPair *, 64 * s->sb_rows);\n\n#undef assign\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/132", "input": "static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    SmackerContext *smk = s->priv_data;\n\n    int flags;\n\n    int ret;\n\n    int i;\n\n    int frame_size = 0;\n\n    int palchange = 0;\n\n\n\n    if (s->pb->eof_reached || smk->cur_frame >= smk->frames)\n\n        return AVERROR_EOF;\n\n\n\n    /* if we demuxed all streams, pass another frame */\n\n    if(smk->curstream < 0) {\n\n        avio_seek(s->pb, smk->nextpos, 0);\n\n        frame_size = smk->frm_size[smk->cur_frame] & (~3);\n\n        flags = smk->frm_flags[smk->cur_frame];\n\n        /* handle palette change event */\n\n        if(flags & SMACKER_PAL){\n\n            int size, sz, t, off, j, pos;\n\n            uint8_t *pal = smk->pal;\n\n            uint8_t oldpal[768];\n\n\n\n            memcpy(oldpal, pal, 768);\n\n            size = avio_r8(s->pb);\n\n            size = size * 4 - 1;\n\n            frame_size -= size;\n\n            frame_size--;\n\n            sz = 0;\n\n            pos = avio_tell(s->pb) + size;\n\n            while(sz < 256){\n\n                t = avio_r8(s->pb);\n\n                if(t & 0x80){ /* skip palette entries */\n\n                    sz += (t & 0x7F) + 1;\n\n                    pal += ((t & 0x7F) + 1) * 3;\n\n                } else if(t & 0x40){ /* copy with offset */\n\n                    off = avio_r8(s->pb);\n\n                    j = (t & 0x3F) + 1;\n\n                    if (off + j > 0x100) {\n\n                        av_log(s, AV_LOG_ERROR,\n\n                               \"Invalid palette update, offset=%d length=%d extends beyond palette size\\n\",\n\n                               off, j);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    off *= 3;\n\n                    while(j-- && sz < 256) {\n\n                        *pal++ = oldpal[off + 0];\n\n                        *pal++ = oldpal[off + 1];\n\n                        *pal++ = oldpal[off + 2];\n\n                        sz++;\n\n                        off += 3;\n\n                    }\n\n                } else { /* new entries */\n\n                    *pal++ = smk_pal[t];\n\n                    *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];\n\n                    *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];\n\n                    sz++;\n\n                }\n\n            }\n\n            avio_seek(s->pb, pos, 0);\n\n            palchange |= 1;\n\n        }\n\n        flags >>= 1;\n\n        smk->curstream = -1;\n\n        /* if audio chunks are present, put them to stack and retrieve later */\n\n        for(i = 0; i < 7; i++) {\n\n            if(flags & 1) {\n\n                uint32_t size;\n\n                uint8_t *tmpbuf;\n\n\n\n                size = avio_rl32(s->pb) - 4;\n\n                if (!size || size > frame_size) {\n\n                    av_log(s, AV_LOG_ERROR, \"Invalid audio part size\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                frame_size -= size;\n\n                frame_size -= 4;\n\n                smk->curstream++;\n\n                tmpbuf = av_realloc(smk->bufs[smk->curstream], size);\n\n                if (!tmpbuf)\n\n                    return AVERROR(ENOMEM);\n\n                smk->bufs[smk->curstream] = tmpbuf;\n\n                smk->buf_sizes[smk->curstream] = size;\n\n                ret = avio_read(s->pb, smk->bufs[smk->curstream], size);\n\n                if(ret != size)\n\n                    return AVERROR(EIO);\n\n                smk->stream_id[smk->curstream] = smk->indexes[i];\n\n            }\n\n            flags >>= 1;\n\n        }\n\n        if (frame_size < 0)\n\n            return AVERROR_INVALIDDATA;\n\n        if (av_new_packet(pkt, frame_size + 769))\n\n            return AVERROR(ENOMEM);\n\n        if(smk->frm_size[smk->cur_frame] & 1)\n\n            palchange |= 2;\n\n        pkt->data[0] = palchange;\n\n        memcpy(pkt->data + 1, smk->pal, 768);\n\n        ret = avio_read(s->pb, pkt->data + 769, frame_size);\n\n        if(ret != frame_size)\n\n            return AVERROR(EIO);\n\n        pkt->stream_index = smk->videoindex;\n\n        pkt->pts          = smk->cur_frame;\n\n        pkt->size = ret + 769;\n\n        smk->cur_frame++;\n\n        smk->nextpos = avio_tell(s->pb);\n\n    } else {\n\n        if (smk->stream_id[smk->curstream] < 0)\n\n            return AVERROR_INVALIDDATA;\n\n        if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))\n\n            return AVERROR(ENOMEM);\n\n        memcpy(pkt->data, smk->bufs[smk->curstream], smk->buf_sizes[smk->curstream]);\n\n        pkt->size = smk->buf_sizes[smk->curstream];\n\n        pkt->stream_index = smk->stream_id[smk->curstream];\n\n        pkt->pts = smk->aud_pts[smk->curstream];\n\n        smk->aud_pts[smk->curstream] += AV_RL32(pkt->data);\n\n        smk->curstream--;\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/133", "input": "static void wm8750_audio_out_cb(void *opaque, int free_b)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n    wm8750_out_flush(s);\n\n\n\n    s->req_out = free_b;\n\n    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);\n\n}\n", "target": true}
{"task_id": "defect/train/134", "input": "static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg)\n{\n    TCPCharDriver *s = chr->opaque;\n    struct cmsghdr *cmsg;\n    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n        int fd;\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n            cmsg->cmsg_level != SOL_SOCKET ||\n            cmsg->cmsg_type != SCM_RIGHTS)\n            continue;\n        fd = *((int *)CMSG_DATA(cmsg));\n        if (fd < 0)\n            continue;\n#ifndef MSG_CMSG_CLOEXEC\n        qemu_set_cloexec(fd);\n#endif\n        if (s->msgfd != -1)\n            close(s->msgfd);\n        s->msgfd = fd;\n    }\n}", "target": true}
{"task_id": "defect/train/135", "input": "void ga_channel_free(GAChannel *c)\n\n{\n\n    if (c->method == GA_CHANNEL_UNIX_LISTEN\n\n        && c->listen_channel) {\n\n        ga_channel_listen_close(c);\n\n    }\n\n    if (c->client_channel) {\n\n        ga_channel_client_close(c);\n\n    }\n\n    g_free(c);\n\n}\n", "target": false}
{"task_id": "defect/train/136", "input": "ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n\n                                   MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    ram_addr_t addr;\n\n    Error *local_err = NULL;\n\n\n\n    size = TARGET_PAGE_ALIGN(size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    addr = ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return -1;\n\n    }\n\n    return addr;\n\n}\n", "target": false}
{"task_id": "defect/train/137", "input": "void kvm_s390_io_interrupt(S390CPU *cpu, uint16_t subchannel_id,\n\n                           uint16_t subchannel_nr, uint32_t io_int_parm,\n\n                           uint32_t io_int_word)\n\n{\n\n    uint32_t type;\n\n\n\n    if (io_int_word & IO_INT_WORD_AI) {\n\n        type = KVM_S390_INT_IO(1, 0, 0, 0);\n\n    } else {\n\n        type = ((subchannel_id & 0xff00) << 24) |\n\n            ((subchannel_id & 0x00060) << 22) | (subchannel_nr << 16);\n\n    }\n\n    kvm_s390_interrupt_internal(cpu, type,\n\n                                ((uint32_t)subchannel_id << 16) | subchannel_nr,\n\n                                ((uint64_t)io_int_parm << 32) | io_int_word, 1);\n\n}\n", "target": false}
{"task_id": "defect/train/138", "input": "static void elcr_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    s->elcr = val & s->elcr_mask;\n\n}\n", "target": false}
{"task_id": "defect/train/139", "input": "void nonono(const char* file, int line, const char* msg) {\n\n    fprintf(stderr, \"Nonono! %s:%d %s\\n\", file, line, msg);\n\n    exit(-5);\n\n}\n", "target": false}
{"task_id": "defect/train/140", "input": "static void spitz_i2c_setup(PXA2xxState *cpu)\n\n{\n\n    /* Attach the CPU on one end of our I2C bus.  */\n\n    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);\n\n\n\n#ifdef HAS_AUDIO\n\n    DeviceState *wm;\n\n\n\n    /* Attach a WM8750 to the bus */\n\n    wm = i2c_create_slave(bus, \"wm8750\", 0);\n\n\n\n    spitz_wm8750_addr(wm, 0, 0);\n\n    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_WM,\n\n                    qemu_allocate_irqs(spitz_wm8750_addr, wm, 1)[0]);\n\n    /* .. and to the sound interface.  */\n\n    cpu->i2s->opaque = wm;\n\n    cpu->i2s->codec_out = wm8750_dac_dat;\n\n    cpu->i2s->codec_in = wm8750_adc_dat;\n\n    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);\n\n#endif\n\n}\n", "target": false}
{"task_id": "defect/train/141", "input": "static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out)\n\n{\n\n    OutputStream *ost = ofilter->ost;\n\n    AVCodecContext *codec  = ost->st->codec;\n\n    AVFilterContext *last_filter = out->filter_ctx;\n\n    int pad_idx = out->pad_idx;\n\n    char *sample_fmts, *sample_rates, *channel_layouts;\n\n    char name[255];\n\n    int ret;\n\n\n\n\n\n    snprintf(name, sizeof(name), \"output stream %d:%d\", ost->file_index, ost->index);\n\n    ret = avfilter_graph_create_filter(&ofilter->filter,\n\n                                       avfilter_get_by_name(\"ffabuffersink\"),\n\n                                       name, NULL, NULL, fg->graph);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n#define AUTO_INSERT_FILTER(opt_name, filter_name, arg) do {                 \\\n\n    AVFilterContext *filt_ctx;                                              \\\n\n                                                                            \\\n\n    av_log(NULL, AV_LOG_INFO, opt_name \" is forwarded to lavfi \"            \\\n\n           \"similarly to -af \" filter_name \"=%s.\\n\", arg);                  \\\n\n                                                                            \\\n\n    ret = avfilter_graph_create_filter(&filt_ctx,                           \\\n\n                                       avfilter_get_by_name(filter_name),   \\\n\n                                       filter_name, arg, NULL, fg->graph);  \\\n\n    if (ret < 0)                                                            \\\n\n        return ret;                                                         \\\n\n                                                                            \\\n\n    ret = avfilter_link(last_filter, pad_idx, filt_ctx, 0);                 \\\n\n    if (ret < 0)                                                            \\\n\n        return ret;                                                         \\\n\n                                                                            \\\n\n    last_filter = filt_ctx;                                                 \\\n\n    pad_idx = 0;                                                            \\\n\n} while (0)\n\n    if (ost->audio_channels_mapped) {\n\n        int i;\n\n        AVBPrint pan_buf;\n\n        av_bprint_init(&pan_buf, 256, 8192);\n\n        av_bprintf(&pan_buf, \"0x%\"PRIx64,\n\n                   av_get_default_channel_layout(ost->audio_channels_mapped));\n\n        for (i = 0; i < ost->audio_channels_mapped; i++)\n\n            if (ost->audio_channels_map[i] != -1)\n\n                av_bprintf(&pan_buf, \":c%d=c%d\", i, ost->audio_channels_map[i]);\n\n\n\n        AUTO_INSERT_FILTER(\"-map_channel\", \"pan\", pan_buf.str);\n\n        av_bprint_finalize(&pan_buf, NULL);\n\n    }\n\n\n\n    if (codec->channels && !codec->channel_layout)\n\n        codec->channel_layout = av_get_default_channel_layout(codec->channels);\n\n\n\n    sample_fmts     = choose_sample_fmts(ost);\n\n    sample_rates    = choose_sample_rates(ost);\n\n    channel_layouts = choose_channel_layouts(ost);\n\n    if (sample_fmts || sample_rates || channel_layouts) {\n\n        AVFilterContext *format;\n\n        char args[256];\n\n        int len = 0;\n\n\n\n        if (sample_fmts)\n\n            len += snprintf(args + len, sizeof(args) - len, \"sample_fmts=%s:\",\n\n                            sample_fmts);\n\n        if (sample_rates)\n\n            len += snprintf(args + len, sizeof(args) - len, \"sample_rates=%s:\",\n\n                            sample_rates);\n\n        if (channel_layouts)\n\n            len += snprintf(args + len, sizeof(args) - len, \"channel_layouts=%s:\",\n\n                            channel_layouts);\n\n        args[len - 1] = 0;\n\n\n\n        av_freep(&sample_fmts);\n\n        av_freep(&sample_rates);\n\n        av_freep(&channel_layouts);\n\n\n\n        snprintf(name, sizeof(name), \"audio format for output stream %d:%d\",\n\n                 ost->file_index, ost->index);\n\n        ret = avfilter_graph_create_filter(&format,\n\n                                           avfilter_get_by_name(\"aformat\"),\n\n                                           name, args, NULL, fg->graph);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        ret = avfilter_link(last_filter, pad_idx, format, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        last_filter = format;\n\n        pad_idx = 0;\n\n    }\n\n\n\n    if (audio_volume != 256 && 0) {\n\n        char args[256];\n\n\n\n        snprintf(args, sizeof(args), \"%f\", audio_volume / 256.);\n\n        AUTO_INSERT_FILTER(\"-vol\", \"volume\", args);\n\n    }\n\n\n\n    if ((ret = avfilter_link(last_filter, pad_idx, ofilter->filter, 0)) < 0)\n\n        return ret;\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/142", "input": "void restore_boot_order(void *opaque)\n\n{\n\n    char *normal_boot_order = opaque;\n\n    static int first = 1;\n\n\n\n    /* Restore boot order and remove ourselves after the first boot */\n\n    if (first) {\n\n        first = 0;\n\n        return;\n\n    }\n\n\n\n    qemu_boot_set(normal_boot_order);\n\n\n\n    qemu_unregister_reset(restore_boot_order, normal_boot_order);\n\n    g_free(normal_boot_order);\n\n}\n", "target": false}
{"task_id": "defect/train/143", "input": "static int virtser_port_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    VirtIOSerialPort *port = DO_UPCAST(VirtIOSerialPort, dev, qdev);\n\n    VirtIOSerialPortInfo *info = DO_UPCAST(VirtIOSerialPortInfo, qdev, base);\n\n    VirtIOSerialBus *bus = DO_UPCAST(VirtIOSerialBus, qbus, qdev->parent_bus);\n\n    int ret, max_nr_ports;\n\n    bool plugging_port0;\n\n\n\n    port->vser = bus->vser;\n\n    port->bh = qemu_bh_new(flush_queued_data_bh, port);\n\n\n\n    /*\n\n     * Is the first console port we're seeing? If so, put it up at\n\n     * location 0. This is done for backward compatibility (old\n\n     * kernel, new qemu).\n\n     */\n\n    plugging_port0 = port->is_console && !find_port_by_id(port->vser, 0);\n\n\n\n    if (find_port_by_id(port->vser, port->id)) {\n\n        error_report(\"virtio-serial-bus: A port already exists at id %u\\n\",\n\n                     port->id);\n\n        return -1;\n\n    }\n\n\n\n    if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n\n        if (plugging_port0) {\n\n            port->id = 0;\n\n        } else {\n\n            port->id = find_free_port_id(port->vser);\n\n            if (port->id == VIRTIO_CONSOLE_BAD_ID) {\n\n                error_report(\"virtio-serial-bus: Maximum port limit for this device reached\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    max_nr_ports = tswap32(port->vser->config.max_nr_ports);\n\n    if (port->id >= max_nr_ports) {\n\n        error_report(\"virtio-serial-bus: Out-of-range port id specified, max. allowed: %u\\n\",\n\n                     max_nr_ports - 1);\n\n        return -1;\n\n    }\n\n\n\n    port->info = info;\n\n    ret = info->init(port);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (!use_multiport(port->vser)) {\n\n        /*\n\n         * Allow writes to guest in this case; we have no way of\n\n         * knowing if a guest port is connected.\n\n         */\n\n        port->guest_connected = true;\n\n    }\n\n\n\n    port->elem.out_num = 0;\n\n\n\n    QTAILQ_INSERT_TAIL(&port->vser->ports, port, next);\n\n    port->ivq = port->vser->ivqs[port->id];\n\n    port->ovq = port->vser->ovqs[port->id];\n\n\n\n    add_port(port->vser, port->id);\n\n\n\n    /* Send an update to the guest about this new port added */\n\n    virtio_notify_config(&port->vser->vdev);\n\n\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/144", "input": "void block_job_pause(BlockJob *job)\n\n{\n\n    job->paused = true;\n\n}\n", "target": false}
{"task_id": "defect/train/145", "input": "static void prop_get_fdt(Object *obj, Visitor *v, const char *name,\n\n                         void *opaque, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(obj);\n\n    Error *err = NULL;\n\n    int fdt_offset_next, fdt_offset, fdt_depth;\n\n    void *fdt;\n\n\n\n    if (!drc->fdt) {\n\n        visit_type_null(v, NULL, errp);\n\n        return;\n\n    }\n\n\n\n    fdt = drc->fdt;\n\n    fdt_offset = drc->fdt_start_offset;\n\n    fdt_depth = 0;\n\n\n\n    do {\n\n        const char *name = NULL;\n\n        const struct fdt_property *prop = NULL;\n\n        int prop_len = 0, name_len = 0;\n\n        uint32_t tag;\n\n\n\n        tag = fdt_next_tag(fdt, fdt_offset, &fdt_offset_next);\n\n        switch (tag) {\n\n        case FDT_BEGIN_NODE:\n\n            fdt_depth++;\n\n            name = fdt_get_name(fdt, fdt_offset, &name_len);\n\n            visit_start_struct(v, name, NULL, 0, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            break;\n\n        case FDT_END_NODE:\n\n            /* shouldn't ever see an FDT_END_NODE before FDT_BEGIN_NODE */\n\n            g_assert(fdt_depth > 0);\n\n            visit_check_struct(v, &err);\n\n            visit_end_struct(v);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            fdt_depth--;\n\n            break;\n\n        case FDT_PROP: {\n\n            int i;\n\n            prop = fdt_get_property_by_offset(fdt, fdt_offset, &prop_len);\n\n            name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));\n\n            visit_start_list(v, name, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                return;\n\n            }\n\n            for (i = 0; i < prop_len; i++) {\n\n                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], &err);\n\n                if (err) {\n\n                    error_propagate(errp, err);\n\n                    return;\n\n                }\n\n            }\n\n            visit_end_list(v);\n\n            break;\n\n        }\n\n        default:\n\n            error_setg(&error_abort, \"device FDT in unexpected state: %d\", tag);\n\n        }\n\n        fdt_offset = fdt_offset_next;\n\n    } while (fdt_depth != 0);\n\n}\n", "target": false}
{"task_id": "defect/train/146", "input": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf, int bytes)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base   = (void *) buf,\n\n        .iov_len    = bytes,\n\n    };\n\n\n\n    if (bytes < 0) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    return bdrv_pwritev(bs, offset, &qiov);\n\n}\n", "target": false}
{"task_id": "defect/train/147", "input": "static int ppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n\n\n    /* TCG doesn't (yet) emulate some groups of instructions that\n\n     * are implemented on some otherwise supported CPUs (e.g. VSX\n\n     * and decimal floating point instructions on POWER7).  We\n\n     * remove unsupported instruction groups from the cpu state's\n\n     * instruction masks and hope the guest can cope.  For at\n\n     * least the pseries machine, the unavailability of these\n\n     * instructions can be advertised to the guest via the device\n\n     * tree. */\n\n    if ((env->insns_flags & ~PPC_TCG_INSNS)\n\n        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {\n\n        fprintf(stderr, \"Warning: Disabling some instructions which are not \"\n\n                \"emulated by TCG (0x%\" PRIx64 \", 0x%\" PRIx64 \")\\n\",\n\n                env->insns_flags & ~PPC_TCG_INSNS,\n\n                env->insns_flags2 & ~PPC_TCG_INSNS2);\n\n    }\n\n    env->insns_flags &= PPC_TCG_INSNS;\n\n    env->insns_flags2 &= PPC_TCG_INSNS2;\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/148", "input": "void main_loop_wait(int timeout)\n\n{\n\n    IOHandlerRecord *ioh;\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n\n\n    qemu_bh_update_timeout(&timeout);\n\n\n\n    host_main_loop_wait(&timeout);\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {\n\n        if (ioh->deleted)\n\n            continue;\n\n        if (ioh->fd_read &&\n\n            (!ioh->fd_read_poll ||\n\n             ioh->fd_read_poll(ioh->opaque) != 0)) {\n\n            FD_SET(ioh->fd, &rfds);\n\n            if (ioh->fd > nfds)\n\n                nfds = ioh->fd;\n\n        }\n\n        if (ioh->fd_write) {\n\n            FD_SET(ioh->fd, &wfds);\n\n            if (ioh->fd > nfds)\n\n                nfds = ioh->fd;\n\n        }\n\n    }\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n    if (ret > 0) {\n\n        IOHandlerRecord **pioh;\n\n\n\n        for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {\n\n            if (!ioh->deleted && ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {\n\n                ioh->fd_read(ioh->opaque);\n\n            }\n\n            if (!ioh->deleted && ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {\n\n                ioh->fd_write(ioh->opaque);\n\n            }\n\n        }\n\n\n\n\t/* remove deleted IO handlers */\n\n\tpioh = &first_io_handler;\n\n\twhile (*pioh) {\n\n            ioh = *pioh;\n\n            if (ioh->deleted) {\n\n                *pioh = ioh->next;\n\n                qemu_free(ioh);\n\n            } else\n\n                pioh = &ioh->next;\n\n        }\n\n    }\n\n\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->flags & ALARM_FLAG_EXPIRED) {\n\n        alarm_timer->flags &= ~ALARM_FLAG_EXPIRED;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    if (vm_running) {\n\n        if (!cur_cpu || likely(!(cur_cpu->singlestep_enabled & SSTEP_NOTIMER)))\n\n            qemu_run_timers(&active_timers[QEMU_TIMER_VIRTUAL],\n\n                qemu_get_clock(vm_clock));\n\n    }\n\n\n\n    /* real time timers */\n\n    qemu_run_timers(&active_timers[QEMU_TIMER_REALTIME],\n\n                    qemu_get_clock(rt_clock));\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "target": false}
{"task_id": "defect/train/149", "input": "av_cold int ff_rate_control_init(MpegEncContext *s)\n\n{\n\n    RateControlContext *rcc = &s->rc_context;\n\n    int i, res;\n\n    static const char * const const_names[] = {\n\n        \"PI\",\n\n        \"E\",\n\n        \"iTex\",\n\n        \"pTex\",\n\n        \"tex\",\n\n        \"mv\",\n\n        \"fCode\",\n\n        \"iCount\",\n\n        \"mcVar\",\n\n        \"var\",\n\n        \"isI\",\n\n        \"isP\",\n\n        \"isB\",\n\n        \"avgQP\",\n\n        \"qComp\",\n\n#if 0\n\n        \"lastIQP\",\n\n        \"lastPQP\",\n\n        \"lastBQP\",\n\n        \"nextNonBQP\",\n\n#endif\n\n        \"avgIITex\",\n\n        \"avgPITex\",\n\n        \"avgPPTex\",\n\n        \"avgBPTex\",\n\n        \"avgTex\",\n\n        NULL\n\n    };\n\n    static double (* const func1[])(void *, double) = {\n\n        (void *)bits2qp,\n\n        (void *)qp2bits,\n\n        NULL\n\n    };\n\n    static const char * const func1_names[] = {\n\n        \"bits2qp\",\n\n        \"qp2bits\",\n\n        NULL\n\n    };\n\n    emms_c();\n\n\n\n    res = av_expr_parse(&rcc->rc_eq_eval,\n\n                        s->rc_eq ? s->rc_eq : \"tex^qComp\",\n\n                        const_names, func1_names, func1,\n\n                        NULL, NULL, 0, s->avctx);\n\n    if (res < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error parsing rc_eq \\\"%s\\\"\\n\", s->rc_eq);\n\n        return res;\n\n    }\n\n\n\n    for (i = 0; i < 5; i++) {\n\n        rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0;\n\n        rcc->pred[i].count = 1.0;\n\n        rcc->pred[i].decay = 0.4;\n\n\n\n        rcc->i_cplx_sum [i] =\n\n        rcc->p_cplx_sum [i] =\n\n        rcc->mv_bits_sum[i] =\n\n        rcc->qscale_sum [i] =\n\n        rcc->frame_count[i] = 1; // 1 is better because of 1/0 and such\n\n\n\n        rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5;\n\n    }\n\n    rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy;\n\n\n\n    if (s->avctx->flags & CODEC_FLAG_PASS2) {\n\n        int i;\n\n        char *p;\n\n\n\n        /* find number of pics */\n\n        p = s->avctx->stats_in;\n\n        for (i = -1; p; i++)\n\n            p = strchr(p + 1, ';');\n\n        i += s->max_b_frames;\n\n        if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry))\n\n            return -1;\n\n        rcc->entry       = av_mallocz(i * sizeof(RateControlEntry));\n\n        rcc->num_entries = i;\n\n\n\n        /* init all to skipped p frames\n\n         * (with b frames we might have a not encoded frame at the end FIXME) */\n\n        for (i = 0; i < rcc->num_entries; i++) {\n\n            RateControlEntry *rce = &rcc->entry[i];\n\n\n\n            rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;\n\n            rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;\n\n            rce->misc_bits  = s->mb_num + 10;\n\n            rce->mb_var_sum = s->mb_num * 100;\n\n        }\n\n\n\n        /* read stats */\n\n        p = s->avctx->stats_in;\n\n        for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n\n            RateControlEntry *rce;\n\n            int picture_number;\n\n            int e;\n\n            char *next;\n\n\n\n            next = strchr(p, ';');\n\n            if (next) {\n\n                (*next) = 0; // sscanf in unbelievably slow on looong strings // FIXME copy / do not write\n\n                next++;\n\n            }\n\n            e = sscanf(p, \" in:%d \", &picture_number);\n\n\n\n            assert(picture_number >= 0);\n\n            assert(picture_number < rcc->num_entries);\n\n            rce = &rcc->entry[picture_number];\n\n\n\n            e += sscanf(p, \" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d\",\n\n                        &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits,\n\n                        &rce->mv_bits, &rce->misc_bits,\n\n                        &rce->f_code, &rce->b_code,\n\n                        &rce->mc_mb_var_sum, &rce->mb_var_sum,\n\n                        &rce->i_count, &rce->skip_count, &rce->header_bits);\n\n            if (e != 14) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"statistics are damaged at line %d, parser out=%d\\n\",\n\n                       i, e);\n\n                return -1;\n\n            }\n\n\n\n            p = next;\n\n        }\n\n\n\n        if (init_pass2(s) < 0)\n\n            return -1;\n\n\n\n        // FIXME maybe move to end\n\n        if ((s->avctx->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {\n\n#if CONFIG_LIBXVID\n\n            return ff_xvid_rate_control_init(s);\n\n#else\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"Xvid ratecontrol requires libavcodec compiled with Xvid support.\\n\");\n\n            return -1;\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (!(s->avctx->flags & CODEC_FLAG_PASS2)) {\n\n        rcc->short_term_qsum   = 0.001;\n\n        rcc->short_term_qcount = 0.001;\n\n\n\n        rcc->pass1_rc_eq_output_sum = 0.001;\n\n        rcc->pass1_wanted_bits      = 0.001;\n\n\n\n        if (s->avctx->qblur > 1.0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"qblur too large\\n\");\n\n            return -1;\n\n        }\n\n        /* init stuff with the user specified complexity */\n\n        if (s->rc_initial_cplx) {\n\n            for (i = 0; i < 60 * 30; i++) {\n\n                double bits = s->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num;\n\n                RateControlEntry rce;\n\n\n\n                if (i % ((s->gop_size + 3) / 4) == 0)\n\n                    rce.pict_type = AV_PICTURE_TYPE_I;\n\n                else if (i % (s->max_b_frames + 1))\n\n                    rce.pict_type = AV_PICTURE_TYPE_B;\n\n                else\n\n                    rce.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n                rce.new_pict_type = rce.pict_type;\n\n                rce.mc_mb_var_sum = bits * s->mb_num / 100000;\n\n                rce.mb_var_sum    = s->mb_num;\n\n\n\n                rce.qscale    = FF_QP2LAMBDA * 2;\n\n                rce.f_code    = 2;\n\n                rce.b_code    = 1;\n\n                rce.misc_bits = 1;\n\n\n\n                if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n                    rce.i_count    = s->mb_num;\n\n                    rce.i_tex_bits = bits;\n\n                    rce.p_tex_bits = 0;\n\n                    rce.mv_bits    = 0;\n\n                } else {\n\n                    rce.i_count    = 0; // FIXME we do know this approx\n\n                    rce.i_tex_bits = 0;\n\n                    rce.p_tex_bits = bits * 0.9;\n\n                    rce.mv_bits    = bits * 0.1;\n\n                }\n\n                rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;\n\n                rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;\n\n                rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;\n\n                rcc->frame_count[rce.pict_type]++;\n\n\n\n                get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);\n\n\n\n                // FIXME misbehaves a little for variable fps\n\n                rcc->pass1_wanted_bits += s->bit_rate / (1 / av_q2d(s->avctx->time_base));\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/150", "input": "av_cold void ff_sws_init_swscale_x86(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_MMX_INLINE\n\n    if (INLINE_MMX(cpu_flags))\n\n        sws_init_swscale_mmx(c);\n\n#endif\n\n#if HAVE_MMXEXT_INLINE\n\n    if (INLINE_MMXEXT(cpu_flags))\n\n        sws_init_swscale_mmxext(c);\n\n#endif\n\n\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case AV_PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmxext, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case AV_PIX_FMT_YA8:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case AV_PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case AV_PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case AV_PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case AV_PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmxext, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case AV_PIX_FMT_YA8:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case AV_PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case AV_PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case AV_PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case AV_PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case AV_PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case AV_PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case AV_PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case AV_PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/151", "input": "static void libopus_write_header(AVCodecContext *avctx, int stream_count,\n\n                                 int coupled_stream_count,\n\n                                 const uint8_t *channel_mapping)\n\n{\n\n    uint8_t *p   = avctx->extradata;\n\n    int channels = avctx->channels;\n\n\n\n    bytestream_put_buffer(&p, \"OpusHead\", 8);\n\n    bytestream_put_byte(&p, 1); /* Version */\n\n    bytestream_put_byte(&p, channels);\n\n    bytestream_put_le16(&p, avctx->delay); /* Lookahead samples at 48kHz */\n\n    bytestream_put_le32(&p, avctx->sample_rate); /* Original sample rate */\n\n    bytestream_put_le16(&p, 0); /* Gain of 0dB is recommended. */\n\n\n\n    /* Channel mapping */\n\n    if (channels > 2) {\n\n        bytestream_put_byte(&p, channels <= 8 ? 1 : 255);\n\n        bytestream_put_byte(&p, stream_count);\n\n        bytestream_put_byte(&p, coupled_stream_count);\n\n        bytestream_put_buffer(&p, channel_mapping, channels);\n\n    } else {\n\n        bytestream_put_byte(&p, 0);\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/152", "input": "static int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n#if 1\n\n    int frame_duration = av_rescale(track->timescale, track->enc->time_base.num, track->enc->time_base.den);\n\n    int nb_frames = ROUNDED_DIV(track->enc->time_base.den, track->enc->time_base.num);\n\n    AVDictionaryEntry *t = NULL;\n\n\n\n    if (nb_frames > 255) {\n\n        av_log(NULL, AV_LOG_ERROR, \"fps %d is too large\\n\", nb_frames);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n\n    avio_wb32(pb, 0);                       /* Reserved */\n\n    avio_wb32(pb, 1);                       /* Data reference index */\n\n    avio_wb32(pb, 0);                       /* Flags */\n\n    avio_wb32(pb, track->timecode_flags);   /* Flags (timecode) */\n\n    avio_wb32(pb, track->timescale);        /* Timescale */\n\n    avio_wb32(pb, frame_duration);          /* Frame duration */\n\n    avio_w8(pb, nb_frames);                 /* Number of frames */\n\n    avio_w8(pb, 0);                         /* Reserved */\n\n\n\n    if (track->st)\n\n        t = av_dict_get(track->st->metadata, \"reel_name\", NULL, 0);\n\n\n\n    if (t && utf8len(t->value))\n\n        mov_write_source_reference_tag(pb, track, t->value);\n\n    else\n\n        avio_wb16(pb, 0); /* zero size */\n\n#else\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n\n    avio_wb32(pb, 0);                       /* Reserved */\n\n    avio_wb32(pb, 1);                       /* Data reference index */\n\n    if (track->enc->extradata_size)\n\n        avio_write(pb, track->enc->extradata, track->enc->extradata_size);\n\n#endif\n\n    return update_size(pb, pos);\n\n}\n", "target": false}
{"task_id": "defect/train/153", "input": "static void dv_decode_ac(DVVideoDecodeContext *s, \n\n                         BlockInfo *mb, DCTELEM *block, int last_index)\n\n{\n\n    int last_re_index;\n\n    int shift_offset = mb->shift_offset;\n\n    const UINT8 *scan_table = mb->scan_table;\n\n    const UINT8 *shift_table = mb->shift_table;\n\n    int pos = mb->pos;\n\n    int level, pos1, sign, run;\n\n    int partial_bit_count;\n\n\n\n    OPEN_READER(re, &s->gb);\n\n    \n\n#ifdef VLC_DEBUG\n\n    printf(\"start\\n\");\n\n#endif\n\n\n\n    /* if we must parse a partial vlc, we do it here */\n\n    partial_bit_count = mb->partial_bit_count;\n\n    if (partial_bit_count > 0) {\n\n        UINT8 buf[4];\n\n        UINT32 v;\n\n        int l, l1;\n\n        GetBitContext gb1;\n\n\n\n        /* build the dummy bit buffer */\n\n        l = 16 - partial_bit_count;\n\n        UPDATE_CACHE(re, &s->gb);\n\n#ifdef VLC_DEBUG\n\n        printf(\"show=%04x\\n\", SHOW_UBITS(re, &s->gb, 16));\n\n#endif\n\n        v = (mb->partial_bit_buffer << l) | SHOW_UBITS(re, &s->gb, l);\n\n        buf[0] = v >> 8;\n\n        buf[1] = v;\n\n#ifdef VLC_DEBUG\n\n        printf(\"v=%04x cnt=%d %04x\\n\", \n\n               v, partial_bit_count, (mb->partial_bit_buffer << l));\n\n#endif\n\n        /* try to read the codeword */\n\n        init_get_bits(&gb1, buf, 4);\n\n        {\n\n            OPEN_READER(re1, &gb1);\n\n            UPDATE_CACHE(re1, &gb1);\n\n            GET_RL_VLC(level, run, re1, &gb1, dv_rl_vlc[0], \n\n                       TEX_VLC_BITS, 2);\n\n            l = re1_index;\n\n            CLOSE_READER(re1, &gb1);\n\n        }\n\n#ifdef VLC_DEBUG\n\n        printf(\"****run=%d level=%d size=%d\\n\", run, level, l);\n\n#endif\n\n        /* compute codeword length */\n\n        l1 = (level != 256 && level != 0);\n\n        /* if too long, we cannot parse */\n\n        l -= partial_bit_count;\n\n        if ((re_index + l + l1) > last_index)\n\n            return;\n\n        /* skip read bits */\n\n        last_re_index = 0; /* avoid warning */\n\n        re_index += l;\n\n        /* by definition, if we can read the vlc, all partial bits\n\n           will be read (otherwise we could have read the vlc before) */\n\n        mb->partial_bit_count = 0;\n\n        UPDATE_CACHE(re, &s->gb);\n\n        goto handle_vlc;\n\n    }\n\n\n\n    /* get the AC coefficients until last_index is reached */\n\n    for(;;) {\n\n        UPDATE_CACHE(re, &s->gb);\n\n#ifdef VLC_DEBUG\n\n        printf(\"%2d: bits=%04x index=%d\\n\", \n\n               pos, SHOW_UBITS(re, &s->gb, 16), re_index);\n\n#endif\n\n        last_re_index = re_index;\n\n        GET_RL_VLC(level, run, re, &s->gb, dv_rl_vlc[0], \n\n                   TEX_VLC_BITS, 2);\n\n    handle_vlc:\n\n#ifdef VLC_DEBUG\n\n        printf(\"run=%d level=%d\\n\", run, level);\n\n#endif\n\n        if (level == 256) {\n\n            if (re_index > last_index) {\n\n            cannot_read:\n\n                /* put position before read code */\n\n                re_index = last_re_index;\n\n                mb->eob_reached = 0;\n\n                break;\n\n            }\n\n            /* EOB */\n\n            mb->eob_reached = 1;\n\n            break;\n\n        } else if (level != 0) {\n\n            if ((re_index + 1) > last_index)\n\n                goto cannot_read;\n\n            sign = SHOW_SBITS(re, &s->gb, 1);\n\n            level = (level ^ sign) - sign;\n\n            LAST_SKIP_BITS(re, &s->gb, 1);\n\n            pos += run;\n\n            /* error */\n\n            if (pos >= 64) {\n\n                goto read_error;\n\n            }\n\n            pos1 = scan_table[pos];\n\n            level = level << (shift_table[pos1] + shift_offset);\n\n            block[pos1] = level;\n\n            //            printf(\"run=%d level=%d shift=%d\\n\", run, level, shift_table[pos1]);\n\n        } else {\n\n            if (re_index > last_index)\n\n                goto cannot_read;\n\n            /* level is zero: means run without coding. No\n\n               sign is coded */\n\n            pos += run;\n\n            /* error */\n\n            if (pos >= 64) {\n\n            read_error:\n\n#if defined(VLC_DEBUG) || 1\n\n                printf(\"error pos=%d\\n\", pos);\n\n#endif\n\n                /* for errors, we consider the eob is reached */\n\n                mb->eob_reached = 1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n    mb->pos = pos;\n\n}\n", "target": false}
{"task_id": "defect/train/154", "input": "static int expand_rle_row16(SgiState *s, uint16_t *out_buf,\n\n                            int len, int pixelstride)\n\n{\n\n    unsigned short pixel;\n\n    unsigned char count;\n\n    unsigned short *orig = out_buf;\n\n    uint16_t *out_end = out_buf + len;\n\n\n\n    while (out_buf < out_end) {\n\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n\n            return AVERROR_INVALIDDATA;\n\n        pixel = bytestream2_get_be16u(&s->g);\n\n        if (!(count = (pixel & 0x7f)))\n\n            break;\n\n\n\n        /* Check for buffer overflow. */\n\n        if (pixelstride * (count - 1) >= len) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid pixel count.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (pixel & 0x80) {\n\n            while (count--) {\n\n                pixel = bytestream2_get_ne16(&s->g);\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        } else {\n\n            pixel = bytestream2_get_ne16(&s->g);\n\n\n\n            while (count--) {\n\n                AV_WN16A(out_buf, pixel);\n\n                out_buf += pixelstride;\n\n            }\n\n        }\n\n    }\n\n    return (out_buf - orig) / pixelstride;\n\n}\n", "target": false}
{"task_id": "defect/train/155", "input": "void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,\n\n              void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    CPUState *saved_env;\n\n    unsigned long pc;\n\n    int ret;\n\n\n\n    saved_env = env;\n\n\n    ret = cpu_arm_handle_mmu_fault(env, addr, is_write, mmu_idx);\n\n    if (unlikely(ret)) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc);\n\n            }\n\n        }\n\n        raise_exception(env->exception_index);\n\n    }\n\n    env = saved_env;\n\n}", "target": true}
{"task_id": "defect/train/156", "input": "static int webvtt_read_header(AVFormatContext *s)\n\n{\n\n    WebVTTContext *webvtt = s->priv_data;\n\n    AVBPrint header, cue;\n\n    int res = 0;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    st->codec->codec_id   = AV_CODEC_ID_WEBVTT;\n\n    st->disposition |= webvtt->kind;\n\n\n\n    av_bprint_init(&header, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n    av_bprint_init(&cue,    0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    for (;;) {\n\n        int i;\n\n        int64_t pos;\n\n        AVPacket *sub;\n\n        const char *p, *identifier, *settings;\n\n        int identifier_len, settings_len;\n\n        int64_t ts_start, ts_end;\n\n\n\n        ff_subtitles_read_chunk(s->pb, &cue);\n\n\n\n        if (!cue.len)\n\n            break;\n\n\n\n        p = identifier = cue.str;\n\n        pos = avio_tell(s->pb);\n\n\n\n        /* ignore header chunk */\n\n        if (!strncmp(p, \"\\xEF\\xBB\\xBFWEBVTT\", 9) ||\n\n            !strncmp(p, \"WEBVTT\", 6))\n\n            continue;\n\n\n\n        /* optional cue identifier (can be a number like in SRT or some kind of\n\n         * chaptering id) */\n\n        for (i = 0; p[i] && p[i] != '\\n' && p[i] != '\\r'; i++) {\n\n            if (!strncmp(p + i, \"-->\", 3)) {\n\n                identifier = NULL;\n\n                break;\n\n            }\n\n        }\n\n        if (!identifier)\n\n            identifier_len = 0;\n\n        else {\n\n            identifier_len = strcspn(p, \"\\r\\n\");\n\n            p += identifier_len;\n\n            if (*p == '\\r')\n\n                p++;\n\n            if (*p == '\\n')\n\n                p++;\n\n        }\n\n\n\n        /* cue timestamps */\n\n        if ((ts_start = read_ts(p)) == AV_NOPTS_VALUE)\n\n            break;\n\n        if (!(p = strstr(p, \"-->\")))\n\n            break;\n\n        p += 3;\n\n        do p++; while (*p == ' ' || *p == '\\t');\n\n        if ((ts_end = read_ts(p)) == AV_NOPTS_VALUE)\n\n            break;\n\n\n\n        /* optional cue settings */\n\n        p += strcspn(p, \"\\n\\t \");\n\n        while (*p == '\\t' || *p == ' ')\n\n            p++;\n\n        settings = p;\n\n        settings_len = strcspn(p, \"\\r\\n\");\n\n        p += settings_len;\n\n        if (*p == '\\r')\n\n            p++;\n\n        if (*p == '\\n')\n\n            p++;\n\n\n\n        /* create packet */\n\n        sub = ff_subtitles_queue_insert(&webvtt->q, p, strlen(p), 0);\n\n        if (!sub) {\n\n            res = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        sub->pos = pos;\n\n        sub->pts = ts_start;\n\n        sub->duration = ts_end - ts_start;\n\n\n\n#define SET_SIDE_DATA(name, type) do {                                  \\\n\n    if (name##_len) {                                                   \\\n\n        uint8_t *buf = av_packet_new_side_data(sub, type, name##_len);  \\\n\n        if (!buf) {                                                     \\\n\n            res = AVERROR(ENOMEM);                                      \\\n\n            goto end;                                                   \\\n\n        }                                                               \\\n\n        memcpy(buf, name, name##_len);                                  \\\n\n    }                                                                   \\\n\n} while (0)\n\n\n\n        SET_SIDE_DATA(identifier, AV_PKT_DATA_WEBVTT_IDENTIFIER);\n\n        SET_SIDE_DATA(settings,   AV_PKT_DATA_WEBVTT_SETTINGS);\n\n    }\n\n\n\n    ff_subtitles_queue_finalize(&webvtt->q);\n\n\n\nend:\n\n    av_bprint_finalize(&cue,    NULL);\n\n    av_bprint_finalize(&header, NULL);\n\n    return res;\n\n}\n", "target": true}
{"task_id": "defect/train/157", "input": "int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length){\n\n    MpegEncContext * const s = &h->s;\n\n    unsigned int pps_id= get_ue_golomb(&s->gb);\n\n    PPS *pps;\n\n    const int qp_bd_offset = 6*(h->sps.bit_depth_luma-8);\n\n    int bits_left;\n\n\n\n    if(pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"pps_id (%d) out of range\\n\", pps_id);\n\n        return -1;\n\n    }\n\n\n\n    pps= av_mallocz(sizeof(PPS));\n\n    if(pps == NULL)\n\n        return -1;\n\n    pps->sps_id= get_ue_golomb_31(&s->gb);\n\n    if((unsigned)pps->sps_id>=MAX_SPS_COUNT || h->sps_buffers[pps->sps_id] == NULL){\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"sps_id out of range\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    pps->cabac= get_bits1(&s->gb);\n\n    pps->pic_order_present= get_bits1(&s->gb);\n\n    pps->slice_group_count= get_ue_golomb(&s->gb) + 1;\n\n    if(pps->slice_group_count > 1 ){\n\n        pps->mb_slice_group_map_type= get_ue_golomb(&s->gb);\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n\n        switch(pps->mb_slice_group_map_type){\n\n        case 0:\n\n#if 0\n\n|   for( i = 0; i <= num_slice_groups_minus1; i++ ) |   |        |\n\n|    run_length[ i ]                                |1  |ue(v)   |\n\n#endif\n\n            break;\n\n        case 2:\n\n#if 0\n\n|   for( i = 0; i < num_slice_groups_minus1; i++ )  |   |        |\n\n|{                                                  |   |        |\n\n|    top_left_mb[ i ]                               |1  |ue(v)   |\n\n|    bottom_right_mb[ i ]                           |1  |ue(v)   |\n\n|   }                                               |   |        |\n\n#endif\n\n            break;\n\n        case 3:\n\n        case 4:\n\n        case 5:\n\n#if 0\n\n|   slice_group_change_direction_flag               |1  |u(1)    |\n\n|   slice_group_change_rate_minus1                  |1  |ue(v)   |\n\n#endif\n\n            break;\n\n        case 6:\n\n#if 0\n\n|   slice_group_id_cnt_minus1                       |1  |ue(v)   |\n\n|   for( i = 0; i <= slice_group_id_cnt_minus1; i++ |   |        |\n\n|)                                                  |   |        |\n\n|    slice_group_id[ i ]                            |1  |u(v)    |\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n    pps->ref_count[0]= get_ue_golomb(&s->gb) + 1;\n\n    pps->ref_count[1]= get_ue_golomb(&s->gb) + 1;\n\n    if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    pps->weighted_pred= get_bits1(&s->gb);\n\n    pps->weighted_bipred_idc= get_bits(&s->gb, 2);\n\n    pps->init_qp= get_se_golomb(&s->gb) + 26 + qp_bd_offset;\n\n    pps->init_qs= get_se_golomb(&s->gb) + 26 + qp_bd_offset;\n\n    pps->chroma_qp_index_offset[0]= get_se_golomb(&s->gb);\n\n    pps->deblocking_filter_parameters_present= get_bits1(&s->gb);\n\n    pps->constrained_intra_pred= get_bits1(&s->gb);\n\n    pps->redundant_pic_cnt_present = get_bits1(&s->gb);\n\n\n\n    pps->transform_8x8_mode= 0;\n\n    h->dequant_coeff_pps= -1; //contents of sps/pps can change even if id doesn't, so reinit\n\n    memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));\n\n    memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));\n\n\n\n    bits_left = bit_length - get_bits_count(&s->gb);\n\n    if(bits_left > 0){\n\n        pps->transform_8x8_mode= get_bits1(&s->gb);\n\n        decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);\n\n        pps->chroma_qp_index_offset[1]= get_se_golomb(&s->gb); //second_chroma_qp_index_offset\n\n    } else {\n\n        pps->chroma_qp_index_offset[1]= pps->chroma_qp_index_offset[0];\n\n    }\n\n\n\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], h->sps.bit_depth_luma);\n\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], h->sps.bit_depth_luma);\n\n    if(pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n\n        pps->chroma_qp_diff= 1;\n\n\n\n    if(s->avctx->debug&FF_DEBUG_PICT_INFO){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"pps:%u sps:%u %s slice_groups:%d ref:%d/%d %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n\n               pps_id, pps->sps_id,\n\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n\n               pps->slice_group_count,\n\n               pps->ref_count[0], pps->ref_count[1],\n\n               pps->weighted_pred ? \"weighted\" : \"\",\n\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\"\n\n               );\n\n    }\n\n\n\n    av_free(h->pps_buffers[pps_id]);\n\n    h->pps_buffers[pps_id]= pps;\n\n    return 0;\n\nfail:\n\n    av_free(pps);\n\n    return -1;\n\n}\n", "target": false}
{"task_id": "defect/train/158", "input": "static int load_input_picture(MpegEncContext *s, AVFrame *pic_arg){\n\n    AVFrame *pic=NULL;\n\n    int i;\n\n    const int encoding_delay= s->max_b_frames;\n\n    int direct=1;\n\n    \n\n  if(pic_arg){\n\n    if(encoding_delay && !(s->flags&CODEC_FLAG_INPUT_PRESERVED)) direct=0;\n\n    if(pic_arg->linesize[0] != s->linesize) direct=0;\n\n    if(pic_arg->linesize[1] != s->uvlinesize) direct=0;\n\n    if(pic_arg->linesize[2] != s->uvlinesize) direct=0;\n\n  \n\n//    printf(\"%d %d %d %d\\n\",pic_arg->linesize[0], pic_arg->linesize[1], s->linesize, s->uvlinesize);\n\n    \n\n    if(direct){\n\n        i= find_unused_picture(s, 1);\n\n\n\n        pic= (AVFrame*)&s->picture[i];\n\n        pic->reference= 3;\n\n    \n\n        for(i=0; i<4; i++){\n\n            pic->data[i]= pic_arg->data[i];\n\n            pic->linesize[i]= pic_arg->linesize[i];\n\n        }\n\n        alloc_picture(s, (Picture*)pic, 1);\n\n    }else{\n\n        i= find_unused_picture(s, 0);\n\n\n\n        pic= (AVFrame*)&s->picture[i];\n\n        pic->reference= 3;\n\n\n\n        alloc_picture(s, (Picture*)pic, 0);\n\n        for(i=0; i<4; i++){\n\n            /* the input will be 16 pixels to the right relative to the actual buffer start\n\n             * and the current_pic, so the buffer can be reused, yes its not beatifull \n\n             */\n\n            pic->data[i]+= 16; \n\n        }\n\n\n\n        if(   pic->data[0] == pic_arg->data[0] \n\n           && pic->data[1] == pic_arg->data[1]\n\n           && pic->data[2] == pic_arg->data[2]){\n\n       // empty\n\n        }else{\n\n            int h_chroma_shift, v_chroma_shift;\n\n            avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &h_chroma_shift, &v_chroma_shift);\n\n        \n\n            for(i=0; i<3; i++){\n\n                int src_stride= pic_arg->linesize[i];\n\n                int dst_stride= i ? s->uvlinesize : s->linesize;\n\n                int h_shift= i ? h_chroma_shift : 0;\n\n                int v_shift= i ? v_chroma_shift : 0;\n\n                int w= s->width >>h_shift;\n\n                int h= s->height>>v_shift;\n\n                uint8_t *src= pic_arg->data[i];\n\n                uint8_t *dst= pic->data[i];\n\n            \n\n                if(src_stride==dst_stride)\n\n                    memcpy(dst, src, src_stride*h);\n\n                else{\n\n                    while(h--){\n\n                        memcpy(dst, src, w);\n\n                        dst += dst_stride;\n\n                        src += src_stride;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pic->quality= pic_arg->quality;\n\n    pic->pict_type= pic_arg->pict_type;\n\n    pic->pts = pic_arg->pts;\n\n    \n\n    if(s->input_picture[encoding_delay])\n\n        pic->display_picture_number= s->input_picture[encoding_delay]->display_picture_number + 1;\n\n    \n\n  }\n\n\n\n    /* shift buffer entries */\n\n    for(i=1; i<MAX_PICTURE_COUNT /*s->encoding_delay+1*/; i++)\n\n        s->input_picture[i-1]= s->input_picture[i];\n\n        \n\n    s->input_picture[encoding_delay]= (Picture*)pic;\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/159", "input": "int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)\n\n{\n\n    BufferSinkContext *s    = ctx->priv;\n\n    AVFilterLink      *link = ctx->inputs[0];\n\n    int ret;\n\n\n\n    if ((ret = ff_request_frame(link)) < 0)\n\n        return ret;\n\n\n\n    if (!s->cur_frame)\n\n        return AVERROR(EINVAL);\n\n\n\n    av_frame_move_ref(frame, s->cur_frame);\n\n    av_frame_free(&s->cur_frame);\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/160", "input": "static void nvic_writel(NVICState *s, uint32_t offset, uint32_t value,\n\n                        MemTxAttrs attrs)\n\n{\n\n    ARMCPU *cpu = s->cpu;\n\n\n\n    switch (offset) {\n\n    case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */\n\n    {\n\n        int startvec = 32 * (offset - 0x380) + NVIC_FIRST_IRQ;\n\n        int i;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            break;\n\n        }\n\n        for (i = 0; i < 32 && startvec + i < s->num_irq; i++) {\n\n            s->itns[startvec + i] = (value >> i) & 1;\n\n        }\n\n        nvic_irq_update(s);\n\n        break;\n\n    }\n\n    case 0xd04: /* Interrupt Control State (ICSR) */\n\n        if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {\n\n            if (value & (1 << 31)) {\n\n                armv7m_nvic_set_pending(s, ARMV7M_EXCP_NMI, false);\n\n            } else if (value & (1 << 30) &&\n\n                       arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n                /* PENDNMICLR didn't exist in v7M */\n\n                armv7m_nvic_clear_pending(s, ARMV7M_EXCP_NMI, false);\n\n            }\n\n        }\n\n        if (value & (1 << 28)) {\n\n            armv7m_nvic_set_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);\n\n        } else if (value & (1 << 27)) {\n\n            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);\n\n        }\n\n        if (value & (1 << 26)) {\n\n            armv7m_nvic_set_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);\n\n        } else if (value & (1 << 25)) {\n\n            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);\n\n        }\n\n        break;\n\n    case 0xd08: /* Vector Table Offset.  */\n\n        cpu->env.v7m.vecbase[attrs.secure] = value & 0xffffff80;\n\n        break;\n\n    case 0xd0c: /* Application Interrupt/Reset Control (AIRCR) */\n\n        if ((value >> R_V7M_AIRCR_VECTKEY_SHIFT) == 0x05fa) {\n\n            if (value & R_V7M_AIRCR_SYSRESETREQ_MASK) {\n\n                if (attrs.secure ||\n\n                    !(cpu->env.v7m.aircr & R_V7M_AIRCR_SYSRESETREQS_MASK)) {\n\n                    qemu_irq_pulse(s->sysresetreq);\n\n                }\n\n            }\n\n            if (value & R_V7M_AIRCR_VECTCLRACTIVE_MASK) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Setting VECTCLRACTIVE when not in DEBUG mode \"\n\n                              \"is UNPREDICTABLE\\n\");\n\n            }\n\n            if (value & R_V7M_AIRCR_VECTRESET_MASK) {\n\n                /* NB: this bit is RES0 in v8M */\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Setting VECTRESET when not in DEBUG mode \"\n\n                              \"is UNPREDICTABLE\\n\");\n\n            }\n\n            s->prigroup[attrs.secure] = extract32(value,\n\n                                                  R_V7M_AIRCR_PRIGROUP_SHIFT,\n\n                                                  R_V7M_AIRCR_PRIGROUP_LENGTH);\n\n            if (attrs.secure) {\n\n                /* These bits are only writable by secure */\n\n                cpu->env.v7m.aircr = value &\n\n                    (R_V7M_AIRCR_SYSRESETREQS_MASK |\n\n                     R_V7M_AIRCR_BFHFNMINS_MASK |\n\n                     R_V7M_AIRCR_PRIS_MASK);\n\n                /* BFHFNMINS changes the priority of Secure HardFault, and\n\n                 * allows a pending Non-secure HardFault to preempt (which\n\n                 * we implement by marking it enabled).\n\n                 */\n\n                if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {\n\n                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -3;\n\n                    s->vectors[ARMV7M_EXCP_HARD].enabled = 1;\n\n                } else {\n\n                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -1;\n\n                    s->vectors[ARMV7M_EXCP_HARD].enabled = 0;\n\n                }\n\n            }\n\n            nvic_irq_update(s);\n\n        }\n\n        break;\n\n    case 0xd10: /* System Control.  */\n\n        /* TODO: Implement control registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"NVIC: SCR unimplemented\\n\");\n\n        break;\n\n    case 0xd14: /* Configuration Control.  */\n\n        /* Enforce RAZ/WI on reserved and must-RAZ/WI bits */\n\n        value &= (R_V7M_CCR_STKALIGN_MASK |\n\n                  R_V7M_CCR_BFHFNMIGN_MASK |\n\n                  R_V7M_CCR_DIV_0_TRP_MASK |\n\n                  R_V7M_CCR_UNALIGN_TRP_MASK |\n\n                  R_V7M_CCR_USERSETMPEND_MASK |\n\n                  R_V7M_CCR_NONBASETHRDENA_MASK);\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* v8M makes NONBASETHRDENA and STKALIGN be RES1 */\n\n            value |= R_V7M_CCR_NONBASETHRDENA_MASK\n\n                | R_V7M_CCR_STKALIGN_MASK;\n\n        }\n\n        if (attrs.secure) {\n\n            /* the BFHFNMIGN bit is not banked; keep that in the NS copy */\n\n            cpu->env.v7m.ccr[M_REG_NS] =\n\n                (cpu->env.v7m.ccr[M_REG_NS] & ~R_V7M_CCR_BFHFNMIGN_MASK)\n\n                | (value & R_V7M_CCR_BFHFNMIGN_MASK);\n\n            value &= ~R_V7M_CCR_BFHFNMIGN_MASK;\n\n        }\n\n\n\n        cpu->env.v7m.ccr[attrs.secure] = value;\n\n        break;\n\n    case 0xd24: /* System Handler Control and State (SHCSR) */\n\n        if (attrs.secure) {\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;\n\n            /* Secure HardFault active bit cannot be written */\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_PENDSV].active =\n\n                (value & (1 << 10)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SYSTICK].active =\n\n                (value & (1 << 11)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].pending =\n\n                (value & (1 << 12)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_USAGE].enabled =\n\n                (value & (1 << 18)) != 0;\n\n            s->sec_vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;\n\n            /* SecureFault not banked, but RAZ/WI to NS */\n\n            s->vectors[ARMV7M_EXCP_SECURE].active = (value & (1 << 4)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SECURE].enabled = (value & (1 << 19)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SECURE].pending = (value & (1 << 20)) != 0;\n\n        } else {\n\n            s->vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;\n\n            if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n                /* HARDFAULTPENDED is not present in v7M */\n\n                s->vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;\n\n            }\n\n            s->vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;\n\n            s->vectors[ARMV7M_EXCP_PENDSV].active = (value & (1 << 10)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SYSTICK].active = (value & (1 << 11)) != 0;\n\n            s->vectors[ARMV7M_EXCP_USAGE].pending = (value & (1 << 12)) != 0;\n\n            s->vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;\n\n            s->vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;\n\n            s->vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;\n\n            s->vectors[ARMV7M_EXCP_USAGE].enabled = (value & (1 << 18)) != 0;\n\n        }\n\n        if (attrs.secure || (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK)) {\n\n            s->vectors[ARMV7M_EXCP_BUS].active = (value & (1 << 1)) != 0;\n\n            s->vectors[ARMV7M_EXCP_BUS].pending = (value & (1 << 14)) != 0;\n\n            s->vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;\n\n        }\n\n        /* NMIACT can only be written if the write is of a zero, with\n\n         * BFHFNMINS 1, and by the CPU in secure state via the NS alias.\n\n         */\n\n        if (!attrs.secure && cpu->env.v7m.secure &&\n\n            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&\n\n            (value & (1 << 5)) == 0) {\n\n            s->vectors[ARMV7M_EXCP_NMI].active = 0;\n\n        }\n\n        /* HARDFAULTACT can only be written if the write is of a zero\n\n         * to the non-secure HardFault state by the CPU in secure state.\n\n         * The only case where we can be targeting the non-secure HF state\n\n         * when in secure state is if this is a write via the NS alias\n\n         * and BFHFNMINS is 1.\n\n         */\n\n        if (!attrs.secure && cpu->env.v7m.secure &&\n\n            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&\n\n            (value & (1 << 2)) == 0) {\n\n            s->vectors[ARMV7M_EXCP_HARD].active = 0;\n\n        }\n\n\n\n        /* TODO: this is RAZ/WI from NS if DEMCR.SDME is set */\n\n        s->vectors[ARMV7M_EXCP_DEBUG].active = (value & (1 << 8)) != 0;\n\n        nvic_irq_update(s);\n\n        break;\n\n    case 0xd28: /* Configurable Fault Status.  */\n\n        cpu->env.v7m.cfsr[attrs.secure] &= ~value; /* W1C */\n\n        if (attrs.secure) {\n\n            /* The BFSR bits [15:8] are shared between security states\n\n             * and we store them in the NS copy.\n\n             */\n\n            cpu->env.v7m.cfsr[M_REG_NS] &= ~(value & R_V7M_CFSR_BFSR_MASK);\n\n        }\n\n        break;\n\n    case 0xd2c: /* Hard Fault Status.  */\n\n        cpu->env.v7m.hfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xd30: /* Debug Fault Status.  */\n\n        cpu->env.v7m.dfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xd34: /* Mem Manage Address.  */\n\n        cpu->env.v7m.mmfar[attrs.secure] = value;\n\n        return;\n\n    case 0xd38: /* Bus Fault Address.  */\n\n        cpu->env.v7m.bfar = value;\n\n        return;\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"NVIC: Aux fault status registers unimplemented\\n\");\n\n        break;\n\n    case 0xd90: /* MPU_TYPE */\n\n        return; /* RO */\n\n    case 0xd94: /* MPU_CTRL */\n\n        if ((value &\n\n             (R_V7M_MPU_CTRL_HFNMIENA_MASK | R_V7M_MPU_CTRL_ENABLE_MASK))\n\n            == R_V7M_MPU_CTRL_HFNMIENA_MASK) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"MPU_CTRL: HFNMIENA and !ENABLE is \"\n\n                          \"UNPREDICTABLE\\n\");\n\n        }\n\n        cpu->env.v7m.mpu_ctrl[attrs.secure]\n\n            = value & (R_V7M_MPU_CTRL_ENABLE_MASK |\n\n                       R_V7M_MPU_CTRL_HFNMIENA_MASK |\n\n                       R_V7M_MPU_CTRL_PRIVDEFENA_MASK);\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    case 0xd98: /* MPU_RNR */\n\n        if (value >= cpu->pmsav7_dregion) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"MPU region out of range %\"\n\n                          PRIu32 \"/%\" PRIu32 \"\\n\",\n\n                          value, cpu->pmsav7_dregion);\n\n        } else {\n\n            cpu->env.pmsav7.rnr[attrs.secure] = value;\n\n        }\n\n        break;\n\n    case 0xd9c: /* MPU_RBAR */\n\n    case 0xda4: /* MPU_RBAR_A1 */\n\n    case 0xdac: /* MPU_RBAR_A2 */\n\n    case 0xdb4: /* MPU_RBAR_A3 */\n\n    {\n\n        int region;\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR, and there is no 'region' field in the\n\n             * RBAR register.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return;\n\n            }\n\n            cpu->env.pmsav8.rbar[attrs.secure][region] = value;\n\n            tlb_flush(CPU(cpu));\n\n            return;\n\n        }\n\n\n\n        if (value & (1 << 4)) {\n\n            /* VALID bit means use the region number specified in this\n\n             * value and also update MPU_RNR.REGION with that value.\n\n             */\n\n            region = extract32(value, 0, 4);\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"MPU region out of range %u/%\" PRIu32 \"\\n\",\n\n                              region, cpu->pmsav7_dregion);\n\n                return;\n\n            }\n\n            cpu->env.pmsav7.rnr[attrs.secure] = region;\n\n        } else {\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return;\n\n        }\n\n\n\n        cpu->env.pmsav7.drbar[region] = value & ~0x1f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xda0: /* MPU_RASR (v7M), MPU_RLAR (v8M) */\n\n    case 0xda8: /* MPU_RASR_A1 (v7M), MPU_RLAR_A1 (v8M) */\n\n    case 0xdb0: /* MPU_RASR_A2 (v7M), MPU_RLAR_A2 (v8M) */\n\n    case 0xdb8: /* MPU_RASR_A3 (v7M), MPU_RLAR_A3 (v8M) */\n\n    {\n\n        int region = cpu->env.pmsav7.rnr[attrs.secure];\n\n\n\n        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            /* PMSAv8M handling of the aliases is different from v7M:\n\n             * aliases A1, A2, A3 override the low two bits of the region\n\n             * number in MPU_RNR.\n\n             */\n\n            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */\n\n\n\n            region = cpu->env.pmsav7.rnr[attrs.secure];\n\n            if (aliasno) {\n\n                region = deposit32(region, 0, 2, aliasno);\n\n            }\n\n            if (region >= cpu->pmsav7_dregion) {\n\n                return;\n\n            }\n\n            cpu->env.pmsav8.rlar[attrs.secure][region] = value;\n\n            tlb_flush(CPU(cpu));\n\n            return;\n\n        }\n\n\n\n        if (region >= cpu->pmsav7_dregion) {\n\n            return;\n\n        }\n\n\n\n        cpu->env.pmsav7.drsr[region] = value & 0xff3f;\n\n        cpu->env.pmsav7.dracr[region] = (value >> 16) & 0x173f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xdc0: /* MPU_MAIR0 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (cpu->pmsav7_dregion) {\n\n            /* Register is RES0 if no MPU regions are implemented */\n\n            cpu->env.pmsav8.mair0[attrs.secure] = value;\n\n        }\n\n        /* We don't need to do anything else because memory attributes\n\n         * only affect cacheability, and we don't implement caching.\n\n         */\n\n        break;\n\n    case 0xdc4: /* MPU_MAIR1 */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (cpu->pmsav7_dregion) {\n\n            /* Register is RES0 if no MPU regions are implemented */\n\n            cpu->env.pmsav8.mair1[attrs.secure] = value;\n\n        }\n\n        /* We don't need to do anything else because memory attributes\n\n         * only affect cacheability, and we don't implement caching.\n\n         */\n\n        break;\n\n    case 0xdd0: /* SAU_CTRL */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.sau.ctrl = value & 3;\n\n        break;\n\n    case 0xdd4: /* SAU_TYPE */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        break;\n\n    case 0xdd8: /* SAU_RNR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (value >= cpu->sau_sregion) {\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"SAU region out of range %\"\n\n                          PRIu32 \"/%\" PRIu32 \"\\n\",\n\n                          value, cpu->sau_sregion);\n\n        } else {\n\n            cpu->env.sau.rnr = value;\n\n        }\n\n        break;\n\n    case 0xddc: /* SAU_RBAR */\n\n    {\n\n        int region = cpu->env.sau.rnr;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (region >= cpu->sau_sregion) {\n\n            return;\n\n        }\n\n        cpu->env.sau.rbar[region] = value & ~0x1f;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xde0: /* SAU_RLAR */\n\n    {\n\n        int region = cpu->env.sau.rnr;\n\n\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        if (region >= cpu->sau_sregion) {\n\n            return;\n\n        }\n\n        cpu->env.sau.rlar[region] = value & ~0x1c;\n\n        tlb_flush(CPU(cpu));\n\n        break;\n\n    }\n\n    case 0xde4: /* SFSR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.v7m.sfsr &= ~value; /* W1C */\n\n        break;\n\n    case 0xde8: /* SFAR */\n\n        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {\n\n            goto bad_offset;\n\n        }\n\n        if (!attrs.secure) {\n\n            return;\n\n        }\n\n        cpu->env.v7m.sfsr = value;\n\n        break;\n\n    case 0xf00: /* Software Triggered Interrupt Register */\n\n    {\n\n        int excnum = (value & 0x1ff) + NVIC_FIRST_IRQ;\n\n        if (excnum < s->num_irq) {\n\n            armv7m_nvic_set_pending(s, excnum, false);\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n    bad_offset:\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"NVIC: Bad write offset 0x%x\\n\", offset);\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/161", "input": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    sPAPRTCE *tcep;\n\n\n\n    if (ioba >= tcet->window_size) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-boards IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcep = tcet->table + (ioba >> SPAPR_TCE_PAGE_SHIFT);\n\n    tcep->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "target": true}
{"task_id": "defect/train/162", "input": "static void gen_lq(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    int ra, rd;\n\n    TCGv EA;\n\n\n\n    /* Restore CPU state */\n\n    if (unlikely(ctx->mem_idx == 0)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    ra = rA(ctx->opcode);\n\n    rd = rD(ctx->opcode);\n\n    if (unlikely((rd & 1) || rd == ra)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);\n\n        return;\n\n    }\n\n    if (unlikely(ctx->le_mode)) {\n\n        /* Little-endian mode is not handled */\n\n        gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    EA = tcg_temp_new();\n\n    gen_addr_imm_index(ctx, EA, 0x0F);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd], EA);\n\n    gen_addr_add(ctx, EA, EA, 8);\n\n    gen_qemu_ld64(ctx, cpu_gpr[rd+1], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n", "target": true}
{"task_id": "defect/train/163", "input": "static uint32_t esp_mem_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ESPState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);\n\n    DPRINTF(\"read reg[%d]: 0x%2.2x\\n\", saddr, s->rregs[saddr]);\n\n    switch (saddr) {\n\n    case ESP_FIFO:\n\n        if (s->ti_size > 0) {\n\n            s->ti_size--;\n\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n                /* Data in/out.  */\n\n                fprintf(stderr, \"esp: PIO data read not implemented\\n\");\n\n                s->rregs[ESP_FIFO] = 0;\n\n            } else {\n\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n\n            }\n\n            esp_raise_irq(s);\n\n        }\n\n        if (s->ti_size == 0) {\n\n            s->ti_rptr = 0;\n\n            s->ti_wptr = 0;\n\n        }\n\n        break;\n\n    case ESP_RINTR:\n\n        // Clear interrupt/error status bits\n\n        s->rregs[ESP_RSTAT] &= ~(STAT_GE | STAT_PE);\n\n        esp_lower_irq(s);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return s->rregs[saddr];\n\n}\n", "target": true}
{"task_id": "defect/train/164", "input": "int av_vsrc_buffer_add_frame2(AVFilterContext *buffer_filter, AVFrame *frame,\n\n                              int64_t pts, AVRational pixel_aspect, int width,\n\n                              int height, enum PixelFormat  pix_fmt,\n\n                              const char *sws_param)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    int ret;\n\n\n\n    if (c->has_frame) {\n\n        av_log(buffer_filter, AV_LOG_ERROR,\n\n               \"Buffering several frames is not supported. \"\n\n               \"Please consume all available frames before adding a new one.\\n\"\n\n            );\n\n        //return -1;\n\n    }\n\n\n\n    if(width != c->w || height != c->h || pix_fmt != c->pix_fmt){\n\n        AVFilterContext *scale= buffer_filter->outputs[0]->dst;\n\n        AVFilterLink *link;\n\n\n\n        av_log(buffer_filter, AV_LOG_INFO, \"Changing filter graph input to accept %dx%d %d (%d %d)\\n\",\n\n               width,height,pix_fmt, c->pix_fmt, scale->outputs[0]->format);\n\n\n\n        if(!scale || strcmp(scale->filter->name,\"scale\")){\n\n            AVFilter *f= avfilter_get_by_name(\"scale\");\n\n\n\n            av_log(buffer_filter, AV_LOG_INFO, \"Inserting scaler filter\\n\");\n\n            if(avfilter_open(&scale, f, \"Input equalizer\") < 0)\n\n                return -1;\n\n\n\n            if((ret=avfilter_init_filter(scale, sws_param, NULL))<0){\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if((ret=avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0))<0){\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        }\n\n\n\n        c->pix_fmt= scale->inputs[0]->format= pix_fmt;\n\n        c->w= scale->inputs[0]->w= width;\n\n        c->h= scale->inputs[0]->h= height;\n\n\n\n        link= scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    memcpy(c->frame.data    , frame->data    , sizeof(frame->data));\n\n    memcpy(c->frame.linesize, frame->linesize, sizeof(frame->linesize));\n\n    c->frame.interlaced_frame= frame->interlaced_frame;\n\n    c->frame.top_field_first = frame->top_field_first;\n\n    c->frame.key_frame = frame->key_frame;\n\n    c->frame.pict_type = frame->pict_type;\n\n    c->pts = pts;\n\n    c->pixel_aspect = pixel_aspect;\n\n    c->has_frame = 1;\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/165", "input": "static void pcie_cap_slot_hotplug_common(PCIDevice *hotplug_dev,\n\n                                         DeviceState *dev,\n\n                                         uint8_t **exp_cap, Error **errp)\n\n{\n\n    *exp_cap = hotplug_dev->config + hotplug_dev->exp.exp_cap;\n\n    uint16_t sltsta = pci_get_word(*exp_cap + PCI_EXP_SLTSTA);\n\n\n\n    PCIE_DEV_PRINTF(PCI_DEVICE(dev), \"hotplug state: 0x%x\\n\", sltsta);\n\n    if (sltsta & PCI_EXP_SLTSTA_EIS) {\n\n        /* the slot is electromechanically locked.\n\n         * This error is propagated up to qdev and then to HMP/QMP.\n\n         */\n\n        error_setg_errno(errp, -EBUSY, \"slot is electromechanically locked\");\n\n    }\n\n}\n", "target": true}
{"task_id": "defect/train/166", "input": "void qmp_getfd(const char *fdname, Error **errp)\n\n{\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_fe_get_msgfd(cur_mon->chr);\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_FD_NOT_SUPPLIED);\n\n        return;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                  \"a name not starting with a digit\");\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return;\n\n    }\n\n\n\n    monfd = g_malloc0(sizeof(mon_fd_t));\n\n    monfd->name = g_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);\n\n}", "target": true}
{"task_id": "defect/train/167", "input": "static void qmp_deserialize(void **native_out, void *datap,\n\n                            VisitorFunc visit, Error **errp)\n\n{\n\n    QmpSerializeData *d = datap;\n\n    QString *output_json = qobject_to_json(qmp_output_get_qobject(d->qov));\n\n    QObject *obj = qobject_from_json(qstring_get_str(output_json));\n\n\n\n    QDECREF(output_json);\n\n    d->qiv = qmp_input_visitor_new(obj);\n\n    qobject_decref(obj);\n\n    visit(qmp_input_get_visitor(d->qiv), native_out, errp);\n\n}\n", "target": true}
{"task_id": "defect/train/168", "input": "static bool coroutine_fn yield_and_check(BackupBlockJob *job)\n\n{\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    /* we need to yield so that bdrv_drain_all() returns.\n\n     * (without, VM does not reboot)\n\n     */\n\n    if (job->common.speed) {\n\n        uint64_t delay_ns = ratelimit_calculate_delay(&job->limit,\n\n                                                      job->sectors_read);\n\n        job->sectors_read = 0;\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);\n\n    } else {\n\n        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);\n\n    }\n\n\n\n    if (block_job_is_cancelled(&job->common)) {\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n", "target": true}
{"task_id": "defect/train/169", "input": "static int virtio_scsi_do_tmf(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIDevice *d = virtio_scsi_device_find(s, req->req.tmf.lun);\n\n    SCSIRequest *r, *next;\n\n    BusChild *kid;\n\n    int target;\n\n    int ret = 0;\n\n\n\n    if (s->dataplane_started) {\n\n        assert(blk_get_aio_context(d->conf.blk) == s->ctx);\n\n    }\n\n    /* Here VIRTIO_SCSI_S_OK means \"FUNCTION COMPLETE\".  */\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_OK;\n\n\n\n    virtio_tswap32s(VIRTIO_DEVICE(s), &req->req.tmf.subtype);\n\n    switch (req->req.tmf.subtype) {\n\n    case VIRTIO_SCSI_T_TMF_ABORT_TASK:\n\n    case VIRTIO_SCSI_T_TMF_QUERY_TASK:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {\n\n            VirtIOSCSIReq *cmd_req = r->hba_private;\n\n            if (cmd_req && cmd_req->req.cmd.tag == req->req.tmf.tag) {\n\n                break;\n\n            }\n\n        }\n\n        if (r) {\n\n            /*\n\n             * Assert that the request has not been completed yet, we\n\n             * check for it in the loop above.\n\n             */\n\n            assert(r->hba_private);\n\n            if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK) {\n\n                /* \"If the specified command is present in the task set, then\n\n                 * return a service response set to FUNCTION SUCCEEDED\".\n\n                 */\n\n                req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\n            } else {\n\n                VirtIOSCSICancelNotifier *notifier;\n\n\n\n                req->remaining = 1;\n\n                notifier = g_new(VirtIOSCSICancelNotifier, 1);\n\n                notifier->tmf_req = req;\n\n                notifier->notifier.notify = virtio_scsi_cancel_notify;\n\n                scsi_req_cancel_async(r, &notifier->notifier);\n\n                ret = -EINPROGRESS;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n        s->resetting++;\n\n        qdev_reset_all(&d->qdev);\n\n        s->resetting--;\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_ABORT_TASK_SET:\n\n    case VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET:\n\n    case VIRTIO_SCSI_T_TMF_QUERY_TASK_SET:\n\n        if (!d) {\n\n            goto fail;\n\n        }\n\n        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {\n\n            goto incorrect_lun;\n\n        }\n\n\n\n        /* Add 1 to \"remaining\" until virtio_scsi_do_tmf returns.\n\n         * This way, if the bus starts calling back to the notifiers\n\n         * even before we finish the loop, virtio_scsi_cancel_notify\n\n         * will not complete the TMF too early.\n\n         */\n\n        req->remaining = 1;\n\n        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {\n\n            if (r->hba_private) {\n\n                if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK_SET) {\n\n                    /* \"If there is any command present in the task set, then\n\n                     * return a service response set to FUNCTION SUCCEEDED\".\n\n                     */\n\n                    req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\n                    break;\n\n                } else {\n\n                    VirtIOSCSICancelNotifier *notifier;\n\n\n\n                    req->remaining++;\n\n                    notifier = g_new(VirtIOSCSICancelNotifier, 1);\n\n                    notifier->notifier.notify = virtio_scsi_cancel_notify;\n\n                    notifier->tmf_req = req;\n\n                    scsi_req_cancel_async(r, &notifier->notifier);\n\n                }\n\n            }\n\n        }\n\n        if (--req->remaining > 0) {\n\n            ret = -EINPROGRESS;\n\n        }\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET:\n\n        target = req->req.tmf.lun[1];\n\n        s->resetting++;\n\n        QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n             d = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n             if (d->channel == 0 && d->id == target) {\n\n                qdev_reset_all(&d->qdev);\n\n             }\n\n        }\n\n        s->resetting--;\n\n        break;\n\n\n\n    case VIRTIO_SCSI_T_TMF_CLEAR_ACA:\n\n    default:\n\n        req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_REJECTED;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n\n\nincorrect_lun:\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_INCORRECT_LUN;\n\n    return ret;\n\n\n\nfail:\n\n    req->resp.tmf.response = VIRTIO_SCSI_S_BAD_TARGET;\n\n    return ret;\n\n}\n", "target": true}
{"task_id": "defect/train/170", "input": "int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)\n\n{\n\n    if (h->flags & AVIO_FLAG_WRITE)\n\n        return AVERROR(EIO);\n\n    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);\n\n}\n", "target": true}
{"task_id": "defect/train/171", "input": "int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,\n\n                            uint8_t bar_nr)\n\n{\n\n    int ret;\n\n    char *name;\n\n    uint32_t bar_size = 4096;\n\n    uint32_t bar_pba_offset = bar_size / 2;\n\n    uint32_t bar_pba_size = (nentries / 8 + 1) * 8;\n\n\n\n    /*\n\n     * Migration compatibility dictates that this remains a 4k\n\n     * BAR with the vector table in the lower half and PBA in\n\n     * the upper half for nentries which is lower or equal to 128.\n\n     * No need to care about using more than 65 entries for legacy\n\n     * machine types who has at most 64 queues.\n\n     */\n\n    if (nentries * PCI_MSIX_ENTRY_SIZE > bar_pba_offset) {\n\n        bar_pba_offset = nentries * PCI_MSIX_ENTRY_SIZE;\n\n    }\n\n\n\n    if (bar_pba_offset + bar_pba_size > 4096) {\n\n        bar_size = bar_pba_offset + bar_pba_size;\n\n    }\n\n\n\n    if (bar_size & (bar_size - 1)) {\n\n        bar_size = 1 << qemu_fls(bar_size);\n\n    }\n\n\n\n    name = g_strdup_printf(\"%s-msix\", dev->name);\n\n    memory_region_init(&dev->msix_exclusive_bar, OBJECT(dev), name, bar_size);\n\n    g_free(name);\n\n\n\n    ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,\n\n                    0, &dev->msix_exclusive_bar,\n\n                    bar_nr, bar_pba_offset,\n\n                    0);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    pci_register_bar(dev, bar_nr, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &dev->msix_exclusive_bar);\n\n\n\n    return 0;\n\n}\n", "target": true}
{"task_id": "defect/train/172", "input": "void qemu_del_timer(QEMUTimer *ts)\n\n{\n\n}\n", "target": false}
{"task_id": "defect/train/173", "input": "static void restore_native_fp_frstor(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    fp->fpuc = env->fpuc;\n\n    fp->fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;\n\n    fptag = 0;\n\n    for (i=7; i>=0; i--) {\n\n\tfptag <<= 2;\n\n\tif (env->fptags[i]) {\n\n            fptag |= 3;\n\n        } else {\n\n            /* the FPU automatically computes it */\n\n        }\n\n    }\n\n    fp->fptag = fptag;\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    asm volatile (\"frstor %0\" : \"=m\" (*fp));\n\n}\n", "target": false}
{"task_id": "defect/train/174", "input": "static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)\n\n{\n\n    unsigned long next_tb;\n\n    TranslationBlock *tb;\n\n\n\n    /* Should never happen.\n\n       We only end up here when an existing TB is too long.  */\n\n    if (max_cycles > CF_COUNT_MASK)\n\n        max_cycles = CF_COUNT_MASK;\n\n\n\n    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,\n\n                     max_cycles);\n\n    env->current_tb = tb;\n\n    /* execute the generated code */\n\n    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);\n\n    env->current_tb = NULL;\n\n\n\n    if ((next_tb & 3) == 2) {\n\n        /* Restore PC.  This may happen if async event occurs before\n\n           the TB starts executing.  */\n\n        cpu_pc_from_tb(env, tb);\n\n    }\n\n    tb_phys_invalidate(tb, -1);\n\n    tb_free(tb);\n\n}\n", "target": false}
{"task_id": "defect/train/175", "input": "static char *regname(uint32_t addr)\n\n{\n\n    static char buf[16];\n\n    if (addr < PCI_IO_SIZE) {\n\n        const char *r = reg[addr / 4];\n\n        if (r != 0) {\n\n            sprintf(buf, \"%s+%u\", r, addr % 4);\n\n        } else {\n\n            sprintf(buf, \"0x%02x\", addr);\n\n        }\n\n    } else {\n\n        sprintf(buf, \"??? 0x%08x\", addr);\n\n    }\n\n    return buf;\n\n}\n", "target": false}
{"task_id": "defect/train/176", "input": "static void handle_2misc_fcmp_zero(DisasContext *s, int opcode,\n\n                                   bool is_scalar, bool is_u, bool is_q,\n\n                                   int size, int rn, int rd)\n\n{\n\n    bool is_double = (size == 3);\n\n    TCGv_ptr fpst = get_fpstatus_ptr();\n\n\n\n    if (is_double) {\n\n        TCGv_i64 tcg_op = tcg_temp_new_i64();\n\n        TCGv_i64 tcg_zero = tcg_const_i64(0);\n\n        TCGv_i64 tcg_res = tcg_temp_new_i64();\n\n        NeonGenTwoDoubleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: /* FCMLT (zero) */\n\n            swap = true;\n\n            /* fallthrough */\n\n        case 0x2c: /* FCMGT (zero) */\n\n            genfn = gen_helper_neon_cgt_f64;\n\n            break;\n\n        case 0x2d: /* FCMEQ (zero) */\n\n            genfn = gen_helper_neon_ceq_f64;\n\n            break;\n\n        case 0x6d: /* FCMLE (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x6c: /* FCMGE (zero) */\n\n            genfn = gen_helper_neon_cge_f64;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        for (pass = 0; pass < (is_scalar ? 1 : 2); pass++) {\n\n            read_vec_element(s, tcg_op, rn, pass, MO_64);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            write_vec_element(s, tcg_res, rd, pass, MO_64);\n\n        }\n\n        if (is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n\n\n        tcg_temp_free_i64(tcg_res);\n\n        tcg_temp_free_i64(tcg_zero);\n\n        tcg_temp_free_i64(tcg_op);\n\n    } else {\n\n        TCGv_i32 tcg_op = tcg_temp_new_i32();\n\n        TCGv_i32 tcg_zero = tcg_const_i32(0);\n\n        TCGv_i32 tcg_res = tcg_temp_new_i32();\n\n        NeonGenTwoSingleOPFn *genfn;\n\n        bool swap = false;\n\n        int pass, maxpasses;\n\n\n\n        switch (opcode) {\n\n        case 0x2e: /* FCMLT (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x2c: /* FCMGT (zero) */\n\n            genfn = gen_helper_neon_cgt_f32;\n\n            break;\n\n        case 0x2d: /* FCMEQ (zero) */\n\n            genfn = gen_helper_neon_ceq_f32;\n\n            break;\n\n        case 0x6d: /* FCMLE (zero) */\n\n            swap = true;\n\n            /* fall through */\n\n        case 0x6c: /* FCMGE (zero) */\n\n            genfn = gen_helper_neon_cge_f32;\n\n            break;\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n\n\n        if (is_scalar) {\n\n            maxpasses = 1;\n\n        } else {\n\n            maxpasses = is_q ? 4 : 2;\n\n        }\n\n\n\n        for (pass = 0; pass < maxpasses; pass++) {\n\n            read_vec_element_i32(s, tcg_op, rn, pass, MO_32);\n\n            if (swap) {\n\n                genfn(tcg_res, tcg_zero, tcg_op, fpst);\n\n            } else {\n\n                genfn(tcg_res, tcg_op, tcg_zero, fpst);\n\n            }\n\n            if (is_scalar) {\n\n                write_fp_sreg(s, rd, tcg_res);\n\n            } else {\n\n                write_vec_element_i32(s, tcg_res, rd, pass, MO_32);\n\n            }\n\n        }\n\n        tcg_temp_free_i32(tcg_res);\n\n        tcg_temp_free_i32(tcg_zero);\n\n        tcg_temp_free_i32(tcg_op);\n\n        if (!is_q && !is_scalar) {\n\n            clear_vec_high(s, rd);\n\n        }\n\n    }\n\n\n\n    tcg_temp_free_ptr(fpst);\n\n}\n", "target": false}
{"task_id": "defect/train/177", "input": "static int on2avc_decode_band_scales(On2AVCContext *c, GetBitContext *gb)\n\n{\n\n    int w, w2, b, scale, first = 1;\n\n    int band_off = 0;\n\n\n\n    for (w = 0; w < c->num_windows; w++) {\n\n        if (!c->grouping[w]) {\n\n            memcpy(c->band_scales + band_off,\n\n                   c->band_scales + band_off - c->num_bands,\n\n                   c->num_bands * sizeof(*c->band_scales));\n\n            band_off += c->num_bands;\n\n            continue;\n\n        }\n\n        for (b = 0; b < c->num_bands; b++) {\n\n            if (!c->band_type[band_off]) {\n\n                int all_zero = 1;\n\n                for (w2 = w + 1; w2 < c->num_windows; w2++) {\n\n                    if (c->grouping[w2])\n\n                        break;\n\n                    if (c->band_type[w2 * c->num_bands + b]) {\n\n                        all_zero = 0;\n\n                        break;\n\n                    }\n\n                }\n\n                if (all_zero) {\n\n                    c->band_scales[band_off++] = 0;\n\n                    continue;\n\n                }\n\n            }\n\n            if (first) {\n\n                scale = get_bits(gb, 7);\n\n                first = 0;\n\n            } else {\n\n                scale += get_vlc2(gb, c->scale_diff.table, 9, 3) - 60;\n\n            }\n\n            if (scale < 0 || scale > 128) {\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Invalid scale value %d\\n\",\n\n                       scale);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            c->band_scales[band_off++] = c->scale_tab[scale];\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/178", "input": "static inline void writer_print_rational(WriterContext *wctx,\n\n                                         const char *key, AVRational q, char sep)\n\n{\n\n    AVBPrint buf;\n\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n    av_bprintf(&buf, \"%d%c%d\", q.num, sep, q.den);\n\n    wctx->writer->print_string(wctx, key, buf.str);\n\n    wctx->nb_item++;\n\n}\n", "target": false}
{"task_id": "defect/train/179", "input": "int cpu_watchpoint_insert(CPUState *env, target_ulong addr, target_ulong len,\n\n                          int flags, CPUWatchpoint **watchpoint)\n\n{\n\n    target_ulong len_mask = ~(len - 1);\n\n    CPUWatchpoint *wp;\n\n\n\n    /* sanity checks: allow power-of-2 lengths, deny unaligned watchpoints */\n\n    if ((len != 1 && len != 2 && len != 4 && len != 8) || (addr & ~len_mask)) {\n\n        fprintf(stderr, \"qemu: tried to set invalid watchpoint at \"\n\n                TARGET_FMT_lx \", len=\" TARGET_FMT_lu \"\\n\", addr, len);\n\n        return -EINVAL;\n\n    }\n\n    wp = qemu_malloc(sizeof(*wp));\n\n\n\n    wp->vaddr = addr;\n\n    wp->len_mask = len_mask;\n\n    wp->flags = flags;\n\n\n\n    /* keep all GDB-injected watchpoints in front */\n\n    if (flags & BP_GDB)\n\n        TAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);\n\n    else\n\n        TAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);\n\n\n\n    tlb_flush_page(env, addr);\n\n\n\n    if (watchpoint)\n\n        *watchpoint = wp;\n\n    return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/180", "input": "static off_t read_off(int fd, int64_t offset)\n\n{\n\n\tuint64_t buffer;\n\n\tif (pread(fd, &buffer, 8, offset) < 8)\n\n\t\treturn 0;\n\n\treturn be64_to_cpu(buffer);\n\n}\n", "target": false}
{"task_id": "defect/train/181", "input": "void pc_machine_done(Notifier *notifier, void *data)\n\n{\n\n    PCMachineState *pcms = container_of(notifier,\n\n                                        PCMachineState, machine_done);\n\n    PCIBus *bus = pcms->bus;\n\n\n\n    /* set the number of CPUs */\n\n    rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus);\n\n\n\n    if (bus) {\n\n        int extra_hosts = 0;\n\n\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            /* look for expander root buses */\n\n            if (pci_bus_is_root(bus)) {\n\n                extra_hosts++;\n\n            }\n\n        }\n\n        if (extra_hosts && pcms->fw_cfg) {\n\n            uint64_t *val = g_malloc(sizeof(*val));\n\n            *val = cpu_to_le64(extra_hosts);\n\n            fw_cfg_add_file(pcms->fw_cfg,\n\n                    \"etc/extra-pci-roots\", val, sizeof(*val));\n\n        }\n\n    }\n\n\n\n    acpi_setup();\n\n    if (pcms->fw_cfg) {\n\n        pc_build_smbios(pcms);\n\n        pc_build_feature_control_file(pcms);\n\n        /* update FW_CFG_NB_CPUS to account for -device added CPUs */\n\n        fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus);\n\n    }\n\n\n\n    if (pcms->apic_id_limit > 255) {\n\n        IntelIOMMUState *iommu = INTEL_IOMMU_DEVICE(x86_iommu_get_default());\n\n\n\n        if (!iommu || !iommu->x86_iommu.intr_supported ||\n\n            iommu->intr_eim != ON_OFF_AUTO_ON) {\n\n            error_report(\"current -smp configuration requires \"\n\n                         \"Extended Interrupt Mode enabled. \"\n\n                         \"You can add an IOMMU using: \"\n\n                         \"-device intel-iommu,intremap=on,eim=on\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/182", "input": "static void spapr_machine_reset(void)\n\n{\n\n    MachineState *machine = MACHINE(qdev_get_machine());\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    PowerPCCPU *first_ppc_cpu;\n\n    uint32_t rtas_limit;\n\n    hwaddr rtas_addr, fdt_addr;\n\n    void *fdt;\n\n    int rc;\n\n\n\n    /* Check for unknown sysbus devices */\n\n    foreach_dynamic_sysbus_device(find_unknown_sysbus_device, NULL);\n\n\n\n    spapr_caps_reset(spapr);\n\n\n\n    first_ppc_cpu = POWERPC_CPU(first_cpu);\n\n    if (kvm_enabled() && kvmppc_has_cap_mmu_radix() &&\n\n        ppc_check_compat(first_ppc_cpu, CPU_POWERPC_LOGICAL_3_00, 0,\n\n                         spapr->max_compat_pvr)) {\n\n        /* If using KVM with radix mode available, VCPUs can be started\n\n         * without a HPT because KVM will start them in radix mode.\n\n         * Set the GR bit in PATB so that we know there is no HPT. */\n\n        spapr->patb_entry = PATBE1_GR;\n\n    } else {\n\n        spapr_setup_hpt_and_vrma(spapr);\n\n    }\n\n\n\n    qemu_devices_reset();\n\n\n\n    /* DRC reset may cause a device to be unplugged. This will cause troubles\n\n     * if this device is used by another device (eg, a running vhost backend\n\n     * will crash QEMU if the DIMM holding the vring goes away). To avoid such\n\n     * situations, we reset DRCs after all devices have been reset.\n\n     */\n\n    object_child_foreach_recursive(object_get_root(), spapr_reset_drcs, NULL);\n\n\n\n    spapr_clear_pending_events(spapr);\n\n\n\n    /*\n\n     * We place the device tree and RTAS just below either the top of the RMA,\n\n     * or just below 2GB, whichever is lowere, so that it can be\n\n     * processed with 32-bit real mode code if necessary\n\n     */\n\n    rtas_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR);\n\n    rtas_addr = rtas_limit - RTAS_MAX_SIZE;\n\n    fdt_addr = rtas_addr - FDT_MAX_SIZE;\n\n\n\n    /* if this reset wasn't generated by CAS, we should reset our\n\n     * negotiated options and start from scratch */\n\n    if (!spapr->cas_reboot) {\n\n        spapr_ovec_cleanup(spapr->ov5_cas);\n\n        spapr->ov5_cas = spapr_ovec_new();\n\n\n\n        ppc_set_compat(first_ppc_cpu, spapr->max_compat_pvr, &error_fatal);\n\n    }\n\n\n\n    fdt = spapr_build_fdt(spapr, rtas_addr, spapr->rtas_size);\n\n\n\n    spapr_load_rtas(spapr, fdt, rtas_addr);\n\n\n\n    rc = fdt_pack(fdt);\n\n\n\n    /* Should only fail if we've built a corrupted tree */\n\n    assert(rc == 0);\n\n\n\n    if (fdt_totalsize(fdt) > FDT_MAX_SIZE) {\n\n        error_report(\"FDT too big ! 0x%x bytes (max is 0x%x)\",\n\n                     fdt_totalsize(fdt), FDT_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n\n\n    /* Load the fdt */\n\n    qemu_fdt_dumpdtb(fdt, fdt_totalsize(fdt));\n\n    cpu_physical_memory_write(fdt_addr, fdt, fdt_totalsize(fdt));\n\n    g_free(fdt);\n\n\n\n    /* Set up the entry state */\n\n    first_ppc_cpu->env.gpr[3] = fdt_addr;\n\n    first_ppc_cpu->env.gpr[5] = 0;\n\n    first_cpu->halted = 0;\n\n    first_ppc_cpu->env.nip = SPAPR_ENTRY_POINT;\n\n\n\n    spapr->cas_reboot = false;\n\n}\n", "target": false}
{"task_id": "defect/train/183", "input": "bool replay_next_event_is(int event)\n\n{\n\n    bool res = false;\n\n\n\n    /* nothing to skip - not all instructions used */\n\n    if (replay_state.instructions_count != 0) {\n\n        assert(replay_data_kind == EVENT_INSTRUCTION);\n\n        return event == EVENT_INSTRUCTION;\n\n    }\n\n\n\n    while (true) {\n\n        if (event == replay_data_kind) {\n\n            res = true;\n\n        }\n\n        switch (replay_data_kind) {\n\n        case EVENT_SHUTDOWN:\n\n            replay_finish_event();\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        default:\n\n            /* clock, time_t, checkpoint and other events */\n\n            return res;\n\n        }\n\n    }\n\n    return res;\n\n}\n", "target": false}
{"task_id": "defect/train/184", "input": "void kvm_init_irq_routing(KVMState *s)\n\n{\n\n    int gsi_count, i;\n\n\n\n    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING);\n\n    if (gsi_count > 0) {\n\n        unsigned int gsi_bits, i;\n\n\n\n        /* Round up so we can search ints using ffs */\n\n        gsi_bits = ALIGN(gsi_count, 32);\n\n        s->used_gsi_bitmap = g_malloc0(gsi_bits / 8);\n\n        s->gsi_count = gsi_count;\n\n\n\n        /* Mark any over-allocated bits as already in use */\n\n        for (i = gsi_count; i < gsi_bits; i++) {\n\n            set_gsi(s, i);\n\n        }\n\n    }\n\n\n\n    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));\n\n    s->nr_allocated_irq_routes = 0;\n\n\n\n    if (!s->direct_msi) {\n\n        for (i = 0; i < KVM_MSI_HASHTAB_SIZE; i++) {\n\n            QTAILQ_INIT(&s->msi_hashtab[i]);\n\n        }\n\n    }\n\n\n\n    kvm_arch_init_irq_routing(s);\n\n}\n", "target": false}
{"task_id": "defect/train/185", "input": "static uint16_t *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n\n{\n\n    PhysPageEntry *lp, *p;\n\n    int i, j;\n\n\n\n    lp = &phys_map;\n\n\n\n    /* Level 1..N.  */\n\n    for (i = P_L2_LEVELS - 1; i >= 0; i--) {\n\n        if (lp->u.node == NULL) {\n\n            if (!alloc) {\n\n                return NULL;\n\n            }\n\n            lp->u.node = p = g_malloc0(sizeof(PhysPageEntry) * L2_SIZE);\n\n            if (i == 0) {\n\n                for (j = 0; j < L2_SIZE; j++) {\n\n                    p[j].u.leaf = phys_section_unassigned;\n\n                }\n\n            }\n\n        }\n\n        lp = &lp->u.node[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    return &lp->u.leaf;\n\n}\n", "target": false}
{"task_id": "defect/train/186", "input": "void qemu_cpu_kick(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n\n\n    qemu_cond_broadcast(env->halt_cond);\n\n    if (!env->thread_kicked) {\n\n        qemu_cpu_kick_thread(env);\n\n        env->thread_kicked = true;\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/187", "input": "static int http_proxy_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    HTTPContext *s = h->priv_data;\n\n    char hostname[1024], hoststr[1024];\n\n    char auth[1024], pathbuf[1024], *path;\n\n    char lower_url[100];\n\n    int port, ret = 0, attempts = 0;\n\n    HTTPAuthType cur_auth_type;\n\n    char *authstr;\n\n    int new_loc;\n\n\n\n    h->is_streamed = 1;\n\n\n\n    av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &port,\n\n                 pathbuf, sizeof(pathbuf), uri);\n\n    ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);\n\n    path = pathbuf;\n\n    if (*path == '/')\n\n        path++;\n\n\n\n    ff_url_join(lower_url, sizeof(lower_url), \"tcp\", NULL, hostname, port,\n\n                NULL);\n\nredo:\n\n    ret = ffurl_open(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,\n\n                     &h->interrupt_callback, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    authstr = ff_http_auth_create_response(&s->proxy_auth_state, auth,\n\n                                           path, \"CONNECT\");\n\n    snprintf(s->buffer, sizeof(s->buffer),\n\n             \"CONNECT %s HTTP/1.1\\r\\n\"\n\n             \"Host: %s\\r\\n\"\n\n             \"Connection: close\\r\\n\"\n\n             \"%s%s\"\n\n             \"\\r\\n\",\n\n             path,\n\n             hoststr,\n\n             authstr ? \"Proxy-\" : \"\", authstr ? authstr : \"\");\n\n    av_freep(&authstr);\n\n\n\n    if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n\n        goto fail;\n\n\n\n    s->buf_ptr = s->buffer;\n\n    s->buf_end = s->buffer;\n\n    s->line_count = 0;\n\n    s->filesize = -1;\n\n    cur_auth_type = s->proxy_auth_state.auth_type;\n\n\n\n    /* Note: This uses buffering, potentially reading more than the\n\n     * HTTP header. If tunneling a protocol where the server starts\n\n     * the conversation, we might buffer part of that here, too.\n\n     * Reading that requires using the proper ffurl_read() function\n\n     * on this URLContext, not using the fd directly (as the tls\n\n     * protocol does). This shouldn't be an issue for tls though,\n\n     * since the client starts the conversation there, so there\n\n     * is no extra data that we might buffer up here.\n\n     */\n\n    ret = http_read_header(h, &new_loc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    attempts++;\n\n    if (s->http_code == 407 &&\n\n        (cur_auth_type == HTTP_AUTH_NONE || s->proxy_auth_state.stale) &&\n\n        s->proxy_auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) {\n\n        ffurl_closep(&s->hd);\n\n        goto redo;\n\n    }\n\n\n\n    if (s->http_code < 400)\n\n        return 0;\n\n    ret = AVERROR(EIO);\n\n\n\nfail:\n\n    http_proxy_close(h);\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/188", "input": "static int get_physical_address_data(CPUState *env,\n\n                                     target_phys_addr_t *physical, int *prot,\n\n                                     target_ulong address, int rw, int is_user)\n\n{\n\n    target_ulong mask;\n\n    unsigned int i;\n\n\n\n    if ((env->lsu & DMMU_E) == 0) { /* DMMU disabled */\n\n        *physical = address;\n\n        *prot = PAGE_READ | PAGE_WRITE;\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        switch ((env->dtlb_tte[i] >> 61) & 3) {\n\n        default:\n\n        case 0x0: // 8k\n\n            mask = 0xffffffffffffe000ULL;\n\n            break;\n\n        case 0x1: // 64k\n\n            mask = 0xffffffffffff0000ULL;\n\n            break;\n\n        case 0x2: // 512k\n\n            mask = 0xfffffffffff80000ULL;\n\n            break;\n\n        case 0x3: // 4M\n\n            mask = 0xffffffffffc00000ULL;\n\n            break;\n\n        }\n\n        // ctx match, vaddr match, valid?\n\n        if (env->dmmuregs[1] == (env->dtlb_tag[i] & 0x1fff) &&\n\n            (address & mask) == (env->dtlb_tag[i] & mask) &&\n\n            (env->dtlb_tte[i] & 0x8000000000000000ULL)) {\n\n            // access ok?\n\n            if (((env->dtlb_tte[i] & 0x4) && is_user) ||\n\n                (!(env->dtlb_tte[i] & 0x2) && (rw == 1))) {\n\n                if (env->dmmuregs[3]) /* Fault status register */\n\n                    env->dmmuregs[3] = 2; /* overflow (not read before\n\n                                             another fault) */\n\n                env->dmmuregs[3] |= (is_user << 3) | ((rw == 1) << 2) | 1;\n\n                env->dmmuregs[4] = address; /* Fault address register */\n\n                env->exception_index = TT_DFAULT;\n\n#ifdef DEBUG_MMU\n\n                printf(\"DFAULT at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n                return 1;\n\n            }\n\n            *physical = ((env->dtlb_tte[i] & mask) | (address & ~mask)) &\n\n                        0x1ffffffe000ULL;\n\n            *prot = PAGE_READ;\n\n            if (env->dtlb_tte[i] & 0x2)\n\n                *prot |= PAGE_WRITE;\n\n            return 0;\n\n        }\n\n    }\n\n#ifdef DEBUG_MMU\n\n    printf(\"DMISS at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n    env->dmmuregs[6] = (address & ~0x1fffULL) | (env->dmmuregs[1] & 0x1fff);\n\n    env->exception_index = TT_DMISS;\n\n    return 1;\n\n}\n", "target": false}
{"task_id": "defect/train/189", "input": "static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    char attr_dir[PATH_MAX];\n\n    char *tmp_path = g_strdup(path);\n\n\n\n    snprintf(attr_dir, PATH_MAX, \"%s/%s/%s\",\n\n             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);\n\n\n\n    err = mkdir(attr_dir, 0700);\n\n    if (err < 0 && errno == EEXIST) {\n\n        err = 0;\n\n    }\n\n    g_free(tmp_path);\n\n    return err;\n\n}\n", "target": false}
{"task_id": "defect/train/190", "input": "static inline void sync_jmpstate(DisasContext *dc)\n\n{\n\n    if (dc->jmp == JMP_DIRECT) {\n\n            dc->jmp = JMP_INDIRECT;\n\n            tcg_gen_movi_tl(env_btaken, 1);\n\n            tcg_gen_movi_tl(env_btarget, dc->jmp_pc);\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/191", "input": "void register_device_unmigratable(DeviceState *dev, const char *idstr,\n\n                                                            void *opaque)\n\n{\n\n    SaveStateEntry *se;\n\n    char id[256] = \"\";\n\n\n\n    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {\n\n        char *path = dev->parent_bus->info->get_dev_path(dev);\n\n        if (path) {\n\n            pstrcpy(id, sizeof(id), path);\n\n            pstrcat(id, sizeof(id), \"/\");\n\n            g_free(path);\n\n        }\n\n    }\n\n    pstrcat(id, sizeof(id), idstr);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {\n\n            se->no_migrate = 1;\n\n        }\n\n    }\n\n}\n", "target": false}
{"task_id": "defect/train/192", "input": "int css_do_rsch(SubchDev *sch)\n\n{\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    int ret;\n\n\n\n    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n\n        ret = -ENODEV;\n\n        goto out;\n\n    }\n\n\n\n    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {\n\n        ret = -EINPROGRESS;\n\n        goto out;\n\n    }\n\n\n\n    if (((s->ctrl & SCSW_CTRL_MASK_FCTL) != SCSW_FCTL_START_FUNC) ||\n\n        (s->ctrl & SCSW_ACTL_RESUME_PEND) ||\n\n        (!(s->ctrl & SCSW_ACTL_SUSP))) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* If monitoring is active, update counter. */\n\n    if (channel_subsys.chnmon_active) {\n\n        css_update_chnmon(sch);\n\n    }\n\n\n\n    s->ctrl |= SCSW_ACTL_RESUME_PEND;\n\n    do_subchannel_work(sch, NULL);\n\n    ret = 0;\n\n\n\nout:\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/193", "input": "CPUState *cpu_copy(CPUState *env)\n\n{\n\n    CPUState *new_env = cpu_init(env->cpu_model_str);\n\n    CPUState *next_cpu = new_env->next_cpu;\n\n    int cpu_index = new_env->cpu_index;\n\n#if defined(TARGET_HAS_ICE)\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n#endif\n\n\n\n    memcpy(new_env, env, sizeof(CPUState));\n\n\n\n    /* Preserve chaining and index. */\n\n    new_env->next_cpu = next_cpu;\n\n    new_env->cpu_index = cpu_index;\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    TAILQ_INIT(&env->breakpoints);\n\n    TAILQ_INIT(&env->watchpoints);\n\n#if defined(TARGET_HAS_ICE)\n\n    TAILQ_FOREACH(bp, &env->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_env, bp->pc, bp->flags, NULL);\n\n    }\n\n    TAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_env, wp->vaddr, (~wp->len_mask) + 1,\n\n                              wp->flags, NULL);\n\n    }\n\n#endif\n\n\n\n    return new_env;\n\n}\n", "target": false}
{"task_id": "defect/train/194", "input": "xilinx_axidma_data_stream_push(StreamSlave *obj, unsigned char *buf, size_t len,\n\n                               uint32_t *app)\n\n{\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(obj);\n\n    struct Stream *s = &ds->dma->streams[1];\n\n    size_t ret;\n\n\n\n    if (!app) {\n\n        hw_error(\"No stream app data!\\n\");\n\n    }\n\n    ret = stream_process_s2mem(s, buf, len, app);\n\n    stream_update_irq(s);\n\n    return ret;\n\n}\n", "target": false}
{"task_id": "defect/train/195", "input": "void *av_realloc(void *ptr, unsigned int size)\n\n{\n\n#ifdef MEMALIGN_HACK\n\n    int diff;\n\n#endif\n\n\n\n    /* let's disallow possible ambiguous cases */\n\n    if(size > INT_MAX)\n\n        return NULL;\n\n\n\n#ifdef MEMALIGN_HACK\n\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n\n    if(!ptr) return av_malloc(size);\n\n    diff= ((char*)ptr)[-1];\n\n    return realloc(ptr - diff, size + diff) + diff;\n\n#else\n\n    return realloc(ptr, size);\n\n#endif\n\n}\n", "target": false}
{"task_id": "defect/train/196", "input": "static int mmf_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 32)\n\n        return 0;\n\n    if (p->buf[0] == 'M' && p->buf[1] == 'M' &&\n\n        p->buf[2] == 'M' && p->buf[3] == 'D' &&\n\n        p->buf[8] == 'C' && p->buf[9] == 'N' &&\n\n        p->buf[10] == 'T' && p->buf[11] == 'I')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "target": false}
{"task_id": "defect/train/197", "input": "static XICSState *try_create_xics(const char *type, int nr_servers,\n\n                                  int nr_irqs)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(NULL, type);\n\n    qdev_prop_set_uint32(dev, \"nr_servers\", nr_servers);\n\n    qdev_prop_set_uint32(dev, \"nr_irqs\", nr_irqs);\n\n    if (qdev_init(dev) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    return XICS_COMMON(dev);\n\n}\n", "target": true}
{"task_id": "defect/train/198", "input": "static VncServerInfo *vnc_server_info_get(VncDisplay *vd)\n\n{\n\n    VncServerInfo *info;\n\n    Error *err = NULL;\n\n\n\n    info = g_malloc(sizeof(*info));\n\n    vnc_init_basic_info_from_server_addr(vd->lsock,\n\n                                         qapi_VncServerInfo_base(info), &err);\n\n    info->has_auth = true;\n\n    info->auth = g_strdup(vnc_auth_name(vd));\n\n    if (err) {\n\n        qapi_free_VncServerInfo(info);\n\n        info = NULL;\n\n        error_free(err);\n\n    }\n\n    return info;\n\n}\n", "target": true}
{"task_id": "defect/train/199", "input": "static int vm_request_pending(void)\n\n{\n\n    return powerdown_requested ||\n\n           reset_requested ||\n\n           shutdown_requested ||\n\n           debug_requested ||\n\n           vmstop_requested;\n\n}\n", "target": true}

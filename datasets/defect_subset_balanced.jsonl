{"task_id": "defect/train/0", "input": "static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    /* init pix_fmts of codec */\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    /* init vda */\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    /* changes callback functions */\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    // force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    /* init H.264 decoder */\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n", "target": 0}
{"task_id": "defect/train/1", "input": "static int transcode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     InputFile *input_files,\n\n                     int nb_input_files,\n\n                     StreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret = 0, i, j, k, n, nb_ostreams = 0, step;\n\n\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost, **ost_table = NULL;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int key;\n\n    int want_sdp = 1;\n\n    uint8_t no_packet[MAX_FILES]={0};\n\n    int no_packet_count=0;\n\n    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};\n\n    int nb_streams[AVMEDIA_TYPE_NB]={0};\n\n\n\n    if (rate_emu)\n\n        for (i = 0; i < nb_input_streams; i++)\n\n            input_streams[i].start = av_gettime();\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        fi = stream_maps[i].sync_file_index;\n\n        si = stream_maps[i].sync_stream_index;\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find sync stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            nb_streams[os->streams[i]->codec->codec_type]++;\n\n        }\n\n    }\n\n    for(step=1<<30; step; step>>=1){\n\n        int found_streams[AVMEDIA_TYPE_NB]={0};\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            nb_frame_threshold[j] += step;\n\n\n\n        for(j=0; j<nb_input_streams; j++) {\n\n            int skip=0;\n\n            ist = &input_streams[j];\n\n            if(opt_programid){\n\n                int pi,si;\n\n                AVFormatContext *f= input_files[ ist->file_index ].ctx;\n\n                skip=1;\n\n                for(pi=0; pi<f->nb_programs; pi++){\n\n                    AVProgram *p= f->programs[pi];\n\n                    if(p->id == opt_programid)\n\n                        for(si=0; si<p->nb_stream_indexes; si++){\n\n                            if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                skip=0;\n\n                        }\n\n                }\n\n            }\n\n            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip\n\n                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){\n\n                found_streams[ist->st->codec->codec_type]++;\n\n            }\n\n        }\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            if(found_streams[j] < nb_streams[j])\n\n                nb_frame_threshold[j] -= step;\n\n    }\n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            int found;\n\n            ost = ost_table[n] = output_streams_for_file[k][i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = input_files[stream_maps[n].file_index].ist_index +\n\n                    stream_maps[n].stream_index;\n\n\n\n                /* Sanity check that the stream types match */\n\n                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n\n                    int i= ost->file_index;\n\n                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n].file_index, stream_maps[n].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    ffmpeg_exit(1);\n\n                }\n\n\n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for (j = 0; j < nb_input_streams; j++) {\n\n                    int skip=0;\n\n                    ist = &input_streams[j];\n\n                    if(opt_programid){\n\n                        int pi,si;\n\n                        AVFormatContext *f = input_files[ist->file_index].ctx;\n\n                        skip=1;\n\n                        for(pi=0; pi<f->nb_programs; pi++){\n\n                            AVProgram *p= f->programs[pi];\n\n                            if(p->id == opt_programid)\n\n                                for(si=0; si<p->nb_stream_indexes; si++){\n\n                                    if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                        skip=0;\n\n                                }\n\n                        }\n\n                    }\n\n                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&\n\n                        ist->st->codec->codec_type == ost->st->codec->codec_type &&\n\n                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                            break;\n\n                    }\n\n                }\n\n\n\n                if (!found) {\n\n                    if(! opt_programid) {\n\n                        /* try again and reuse existing stream */\n\n                        for (j = 0; j < nb_input_streams; j++) {\n\n                            ist = &input_streams[j];\n\n                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type\n\n                                && ist->st->discard != AVDISCARD_ALL) {\n\n                                ost->source_index = j;\n\n                                found = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        int i= ost->file_index;\n\n                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = &input_streams[ost->source_index];\n\n            ist->discard = 0;\n\n            ost->sync_ist = (nb_stream_maps > 0) ?\n\n                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +\n\n                         stream_maps[n].sync_stream_index] : ist;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        os = output_files[ost->file_index];\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        if (metadata_streams_autocopy)\n\n            av_dict_copy(&ost->st->metadata, ist->st->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX)\n\n                goto fail;\n\n\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata)\n\n                goto fail;\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if(!ost->fifo)\n\n                    goto fail;\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels) {\n\n                    codec->channels = icodec->channels;\n\n                    codec->channel_layout = icodec->channel_layout;\n\n                }\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;\n\n                }\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method\n\n                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){\n\n                    av_log(os, AV_LOG_WARNING, \"Frame rate very high for a muxer not effciciently supporting it.\\n\"\n\n                                               \"Please consider specifiying a lower framerate, a different muxer or -vsync 2\\n\");\n\n                }\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            /* maximum video buffer size is 6-bytes per pixel, plus DPX header size */\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits/s as argument, not kbits/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec = ist->dec;\n\n            if (!codec)\n\n                codec = avcodec_find_decoder(ist->st->codec->codec_id);\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Decoder (codec id %d) not found for input stream #%d.%d\",\n\n                        ist->st->codec->codec_id, ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening decoder for input stream #%d.%d\",\n\n                        ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ist->st->codec, 0);\n\n            assert_avoptions(ost->opts);\n\n            //if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            //    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        AVStream *st;\n\n        ist = &input_streams[i];\n\n        st= ist->st;\n\n        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE / av_q2d(st->avg_frame_rate) : 0;\n\n        ist->next_pts = AV_NOPTS_VALUE;\n\n        ist->is_start = 1;\n\n    }\n\n\n\n    /* set meta data information from input file if required */\n\n    for (i=0;i<nb_meta_data_maps;i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            snprintf(error, sizeof(error), \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            ret = AVERROR(EINVAL);\\\n\n            goto dump_format;\\\n\n        }\n\n\n\n        int out_file_index = meta_data_maps[i][0].file;\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0 || out_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(out_file_index, nb_output_files, \"output file\")\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = output_files[out_file_index];\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy) {\n\n\n\n        for (i = 0; i < nb_output_files; i++)\n\n            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy chapters according to chapter maps */\n\n    for (i = 0; i < nb_chapter_maps; i++) {\n\n        int infile  = chapter_maps[i].in_file;\n\n        int outfile = chapter_maps[i].out_file;\n\n\n\n        if (infile < 0 || outfile < 0)\n\n            continue;\n\n        if (infile >= nb_input_files) {\n\n            snprintf(error, sizeof(error), \"Invalid input file index %d in chapter mapping.\\n\", infile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        if (outfile >= nb_output_files) {\n\n            snprintf(error, sizeof(error), \"Invalid output file index %d in chapter mapping.\\n\",outfile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        copy_chapters(infile, outfile);\n\n    }\n\n\n\n    /* copy chapters from the first input file that has them*/\n\n    if (!nb_chapter_maps)\n\n        for (i = 0; i < nb_input_files; i++) {\n\n            if (!input_files[i].ctx->nb_chapters)\n\n                continue;\n\n\n\n            for (j = 0; j < nb_output_files; j++)\n\n                if ((ret = copy_chapters(i, j)) < 0)\n\n                    goto dump_format;\n\n            break;\n\n        }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (avformat_write_header(os, &output_opts[i]) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_opts[i]);\n\n        if (strcmp(output_files[i]->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        goto fail;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    if (!using_stdin) {\n\n        if(verbose >= 0)\n\n            fprintf(stderr, \"Press [q] to stop, [?] for help\\n\");\n\n        avio_set_interrupt_cb(decode_interrupt_cb);\n\n    }\n\n    term_init();\n\n\n\n    timer_start = av_gettime();\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        double ipts_min;\n\n        double opts_min;\n\n\n\n    redo:\n\n        ipts_min= 1e100;\n\n        opts_min= 1e100;\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            if (q_pressed)\n\n                break;\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n            if (key == '+') verbose++;\n\n            if (key == '-') verbose--;\n\n            if (key == 's') qp_hist     ^= 1;\n\n            if (key == 'h'){\n\n                if (do_hex_dump){\n\n                    do_hex_dump = do_pkt_dump = 0;\n\n                } else if(do_pkt_dump){\n\n                    do_hex_dump = 1;\n\n                } else\n\n                    do_pkt_dump = 1;\n\n                av_log_set_level(AV_LOG_DEBUG);\n\n            }\n\n            if (key == 'd' || key == 'D'){\n\n                int debug=0;\n\n                if(key == 'D') {\n\n                    debug = input_streams[0].st->codec->debug<<1;\n\n                    if(!debug) debug = 1;\n\n                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n\n                        debug += debug;\n\n                }else\n\n                    scanf(\"%d\", &debug);\n\n                for(i=0;i<nb_input_streams;i++) {\n\n                    input_streams[i].st->codec->debug = debug;\n\n                }\n\n                for(i=0;i<nb_ostreams;i++) {\n\n                    ost = ost_table[i];\n\n                    ost->st->codec->debug = debug;\n\n                }\n\n                if(debug) av_log_set_level(AV_LOG_DEBUG);\n\n                fprintf(stderr,\"debug=%d\\n\", debug);\n\n            }\n\n            if (key == '?'){\n\n                fprintf(stderr, \"key    function\\n\"\n\n                                \"?      show this help\\n\"\n\n                                \"+      increase verbosity\\n\"\n\n                                \"-      decrease verbosity\\n\"\n\n                                \"D      cycle through available debug modes\\n\"\n\n                                \"h      dump packets/hex press to cycle through the 3 states\\n\"\n\n                                \"q      quit\\n\"\n\n                                \"s      Show QP histogram\\n\"\n\n                );\n\n            }\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double ipts, opts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = &input_streams[ost->source_index];\n\n            if(ist->is_past_recording_time || no_packet[ist->file_index])\n\n                continue;\n\n                opts = ost->st->pts.val * av_q2d(ost->st->time_base);\n\n            ipts = (double)ist->pts;\n\n            if (!input_files[ist->file_index].eof_reached){\n\n                if(ipts < ipts_min) {\n\n                    ipts_min = ipts;\n\n                    if(input_sync ) file_index = ist->file_index;\n\n                }\n\n                if(opts < opts_min) {\n\n                    opts_min = opts;\n\n                    if(!input_sync) file_index = ist->file_index;\n\n                }\n\n            }\n\n            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){\n\n                file_index= -1;\n\n                break;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            if(no_packet_count){\n\n                no_packet_count=0;\n\n                memset(no_packet, 0, sizeof(no_packet));\n\n                usleep(10000);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n        /* finish if limit size exhausted */\n\n        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))\n\n            break;\n\n\n\n        /* read a frame from it and output it in the fifo */\n\n        is = input_files[file_index].ctx;\n\n        ret= av_read_frame(is, &pkt);\n\n        if(ret == AVERROR(EAGAIN)){\n\n            no_packet[file_index]=1;\n\n            no_packet_count++;\n\n            continue;\n\n        }\n\n        if (ret < 0) {\n\n            input_files[file_index].eof_reached = 1;\n\n            if (opt_shortest)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        no_packet_count=0;\n\n        memset(no_packet, 0, sizeof(no_packet));\n\n\n\n        if (do_pkt_dump) {\n\n            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n\n                             is->streams[pkt.stream_index]);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)\n\n            goto discard_packet;\n\n        ist_index = input_files[file_index].ist_index + pkt.stream_index;\n\n        ist = &input_streams[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        if (pkt.dts != AV_NOPTS_VALUE)\n\n            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n\n\n        if (ist->ts_scale) {\n\n            if(pkt.pts != AV_NOPTS_VALUE)\n\n                pkt.pts *= ist->ts_scale;\n\n            if(pkt.dts != AV_NOPTS_VALUE)\n\n                pkt.dts *= ist->ts_scale;\n\n        }\n\n\n\n//        fprintf(stderr, \"next:%\"PRId64\" dts:%\"PRId64\" off:%\"PRId64\" %d\\n\", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);\n\n        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE\n\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n\n            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            int64_t delta= pkt_dts - ist->next_pts;\n\n            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){\n\n                input_files[ist->file_index].ts_offset -= delta;\n\n                if (verbose > 2)\n\n                    fprintf(stderr, \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n\n                            delta, input_files[ist->file_index].ts_offset);\n\n                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n                if(pkt.pts != AV_NOPTS_VALUE)\n\n                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n            }\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time != INT64_MAX &&\n\n            (pkt.pts != AV_NOPTS_VALUE ?\n\n                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})\n\n                    :\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})\n\n            )>= 0) {\n\n            ist->is_past_recording_time = 1;\n\n            goto discard_packet;\n\n        }\n\n\n\n        //fprintf(stderr,\"read #%d.%d size=%d\\n\", ist->file_index, ist->st->index, pkt.size);\n\n        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n\n\n\n            if (verbose >= 0)\n\n                fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                        ist->file_index, ist->st->index);\n\n            if (exit_on_error)\n\n                ffmpeg_exit(1);\n\n            av_free_packet(&pkt);\n\n            goto redo;\n\n        }\n\n\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n\n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n\n\n    /* at the end of stream, we must flush the decoder buffers */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            output_packet(ist, i, ost_table, nb_ostreams, NULL);\n\n        }\n\n    }\n\n\n\n    term_exit();\n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec->stats_in);\n\n            avcodec_close(ost->st->codec);\n\n        }\n\n#if CONFIG_AVFILTER\n\n        avfilter_graph_free(&ost->graph);\n\n#endif\n\n    }\n\n\n\n    /* close each decoder */\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(ist->st->codec);\n\n        }\n\n    }\n\n\n\n    /* finished ! */\n\n    ret = 0;\n\n\n\n fail:\n\n    av_freep(&bit_buffer);\n\n\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->st->stream_copy)\n\n                    av_freep(&ost->st->codec->extradata);\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                av_fifo_free(ost->fifo); /* works even if fifo is not\n\n                                             initialized but set to zero */\n\n                av_freep(&ost->st->codec->subtitle_header);\n\n                av_free(ost->resample_frame.data[0]);\n\n                av_free(ost->forced_kf_pts);\n\n                if (ost->video_resample)\n\n                    sws_freeContext(ost->img_resample_ctx);\n\n                if (ost->resample)\n\n                    audio_resample_close(ost->resample);\n\n                if (ost->reformat_ctx)\n\n                    av_audio_convert_free(ost->reformat_ctx);\n\n                av_dict_free(&ost->opts);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n}\n", "target": 0}
{"task_id": "defect/train/2", "input": "static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/3", "input": "int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/4", "input": "static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) / 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/5", "input": "static int dds_decode(AVCodecContext *avctx, void *data,\n\n                      int *got_frame, AVPacket *avpkt)\n\n{\n\n    DDSContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    AVFrame *frame = data;\n\n    int mipmap;\n\n    int ret;\n\n\n\n    ff_texturedsp_init(&ctx->texdsp);\n\n    bytestream2_init(gbc, avpkt->data, avpkt->size);\n\n\n\n    if (bytestream2_get_bytes_left(gbc) < 128) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small (%d).\\n\",\n\n               bytestream2_get_bytes_left(gbc));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||\n\n        bytestream2_get_le32(gbc) != 124) { // header size\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid DDS header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(gbc, 4); // flags\n\n\n\n    avctx->height = bytestream2_get_le32(gbc);\n\n    avctx->width  = bytestream2_get_le32(gbc);\n\n    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size %dx%d.\\n\",\n\n               avctx->width, avctx->height);\n\n        return ret;\n\n    }\n\n\n\n    /* Since codec is based on 4x4 blocks, size is aligned to 4. */\n\n    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);\n\n    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);\n\n\n\n    bytestream2_skip(gbc, 4); // pitch\n\n    bytestream2_skip(gbc, 4); // depth\n\n    mipmap = bytestream2_get_le32(gbc);\n\n    if (mipmap != 0)\n\n        av_log(avctx, AV_LOG_VERBOSE, \"Found %d mipmaps (ignored).\\n\", mipmap);\n\n\n\n    /* Extract pixel format information, considering additional elements\n\n     * in reserved1 and reserved2. */\n\n    ret = parse_pixel_format(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = ff_get_buffer(avctx, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (ctx->compressed) {\n\n        int size = (avctx->coded_height / TEXTURE_BLOCK_H) *\n\n                   (avctx->coded_width / TEXTURE_BLOCK_W) * ctx->tex_ratio;\n\n        ctx->slice_count = av_clip(avctx->thread_count, 1,\n\n                                   avctx->coded_height / TEXTURE_BLOCK_H);\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < size) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Compressed Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* Use the decompress function on the texture, one block per thread. */\n\n        ctx->tex_data = gbc->buffer;\n\n        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);\n\n    } else if (!ctx->paletted && ctx->bpp == 4 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n\n        uint8_t *dst = frame->data[0];\n\n        int x, y, i;\n\n\n\n        /* Use the first 64 bytes as palette, then copy the rest. */\n\n        bytestream2_get_buffer(gbc, frame->data[1], 16 * 4);\n\n        for (i = 0; i < 16; i++) {\n\n            AV_WN32(frame->data[1] + i*4,\n\n                    (frame->data[1][2+i*4]<<0)+\n\n                    (frame->data[1][1+i*4]<<8)+\n\n                    (frame->data[1][0+i*4]<<16)+\n\n                    (frame->data[1][3+i*4]<<24)\n\n            );\n\n        }\n\n        frame->palette_has_changed = 1;\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * frame->width / 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * frame->width / 2);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (y = 0; y < frame->height; y++) {\n\n            for (x = 0; x < frame->width; x += 2) {\n\n                uint8_t val = bytestream2_get_byte(gbc);\n\n                dst[x    ] = val & 0xF;\n\n                dst[x + 1] = val >> 4;\n\n            }\n\n            dst += frame->linesize[0];\n\n        }\n\n    } else {\n\n        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);\n\n\n\n        if (ctx->paletted) {\n\n            int i;\n\n            /* Use the first 1024 bytes as palette, then copy the rest. */\n\n            bytestream2_get_buffer(gbc, frame->data[1], 256 * 4);\n\n            for (i = 0; i < 256; i++)\n\n                AV_WN32(frame->data[1] + i*4,\n\n                        (frame->data[1][2+i*4]<<0)+\n\n                        (frame->data[1][1+i*4]<<8)+\n\n                        (frame->data[1][0+i*4]<<16)+\n\n                        (frame->data[1][3+i*4]<<24)\n\n                );\n\n\n\n            frame->palette_has_changed = 1;\n\n        }\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * linesize);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        av_image_copy_plane(frame->data[0], frame->linesize[0],\n\n                            gbc->buffer, linesize,\n\n                            linesize, frame->height);\n\n    }\n\n\n\n    /* Run any post processing here if needed. */\n\n    if (ctx->postproc != DDS_NONE)\n\n        run_postproc(avctx, frame);\n\n\n\n    /* Frame is ready to be output. */\n\n    frame->pict_type = AV_PICTURE_TYPE_I;\n\n    frame->key_frame = 1;\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "target": 1}
{"task_id": "defect/train/6", "input": "static void check_lowpass_line(int depth){\n\n    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);\n\n    int w = WIDTH;\n\n    int mref = WIDTH_PADDED * -1;\n\n    int pref = WIDTH_PADDED;\n\n    int i, depth_byte;\n\n    InterlaceContext s;\n\n\n\n    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,\n\n                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);\n\n\n\n    s.lowpass = 1;\n\n    s.lowpass = VLPF_LIN;\n\n    depth_byte = depth >> 3;\n\n    w /= depth_byte;\n\n\n\n    memset(src,     0, SRC_SIZE);\n\n    memset(dst_ref, 0, WIDTH_PADDED);\n\n    memset(dst_new, 0, WIDTH_PADDED);\n\n    randomize_buffers(src, SRC_SIZE);\n\n\n\n    ff_interlace_init(&s, depth);\n\n\n\n    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {\n\n        for (i = 0; i < 32; i++) { /* simulate crop */\n\n            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            if (memcmp(dst_ref, dst_new, WIDTH - i))\n\n                fail();\n\n        }\n\n        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/7", "input": "static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    /* set ACPI PM I/O space base address */\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    /* enable ACPI I/O */\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    /* set Root Complex BAR */\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n", "target": 1}
{"task_id": "defect/train/8", "input": "void assert_avoptions(AVDictionary *m)\n\n{\n\n    AVDictionaryEntry *t;\n\n    if ((t = av_dict_get(m, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Option %s not found.\\n\", t->key);\n\n        exit(1);\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/9", "input": "static void nbd_refresh_filename(BlockDriverState *bs, QDict *options)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    QDict *opts = qdict_new();\n\n    QObject *saddr_qdict;\n\n    Visitor *ov;\n\n    const char *host = NULL, *port = NULL, *path = NULL;\n\n\n\n    if (s->saddr->type == SOCKET_ADDRESS_KIND_INET) {\n\n        const InetSocketAddress *inet = s->saddr->u.inet.data;\n\n        if (!inet->has_ipv4 && !inet->has_ipv6 && !inet->has_to) {\n\n            host = inet->host;\n\n            port = inet->port;\n\n        }\n\n    } else if (s->saddr->type == SOCKET_ADDRESS_KIND_UNIX) {\n\n        path = s->saddr->u.q_unix.data->path;\n\n    }\n\n\n\n    qdict_put(opts, \"driver\", qstring_from_str(\"nbd\"));\n\n\n\n    if (path && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix:///%s?socket=%s\", s->export, path);\n\n    } else if (path && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd+unix://?socket=%s\", path);\n\n    } else if (host && s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s/%s\", host, port, s->export);\n\n    } else if (host && !s->export) {\n\n        snprintf(bs->exact_filename, sizeof(bs->exact_filename),\n\n                 \"nbd://%s:%s\", host, port);\n\n    }\n\n\n\n    ov = qobject_output_visitor_new(&saddr_qdict);\n\n    visit_type_SocketAddress(ov, NULL, &s->saddr, &error_abort);\n\n    visit_complete(ov, &saddr_qdict);\n\n\n    assert(qobject_type(saddr_qdict) == QTYPE_QDICT);\n\n\n\n    qdict_put_obj(opts, \"server\", saddr_qdict);\n\n\n\n    if (s->export) {\n\n        qdict_put(opts, \"export\", qstring_from_str(s->export));\n\n    }\n\n    if (s->tlscredsid) {\n\n        qdict_put(opts, \"tls-creds\", qstring_from_str(s->tlscredsid));\n\n    }\n\n\n\n    qdict_flatten(opts);\n\n    bs->full_open_options = opts;\n\n}", "target": 1}
{"task_id": "defect/train/10", "input": "int net_init_tap(QemuOpts *opts, const char *name, VLANState *vlan)\n\n{\n\n    const char *ifname;\n\n\n\n    ifname = qemu_opt_get(opts, \"ifname\");\n\n\n\n    if (!ifname) {\n\n        error_report(\"tap: no interface name\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap_win32_init(vlan, \"tap\", name, ifname) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/11", "input": "print_insn (bfd_vma pc, disassemble_info *info)\n\n{\n\n  const struct dis386 *dp;\n\n  int i;\n\n  char *op_txt[MAX_OPERANDS];\n\n  int needcomma;\n\n  unsigned char uses_DATA_prefix, uses_LOCK_prefix;\n\n  unsigned char uses_REPNZ_prefix, uses_REPZ_prefix;\n\n  int sizeflag;\n\n  const char *p;\n\n  struct dis_private priv;\n\n  unsigned char op;\n\n  unsigned char threebyte;\n\n\n\n  if (info->mach == bfd_mach_x86_64_intel_syntax\n\n      || info->mach == bfd_mach_x86_64)\n\n    address_mode = mode_64bit;\n\n  else\n\n    address_mode = mode_32bit;\n\n\n\n  if (intel_syntax == (char) -1)\n\n    intel_syntax = (info->mach == bfd_mach_i386_i386_intel_syntax\n\n\t\t    || info->mach == bfd_mach_x86_64_intel_syntax);\n\n\n\n  if (info->mach == bfd_mach_i386_i386\n\n      || info->mach == bfd_mach_x86_64\n\n      || info->mach == bfd_mach_i386_i386_intel_syntax\n\n      || info->mach == bfd_mach_x86_64_intel_syntax)\n\n    priv.orig_sizeflag = AFLAG | DFLAG;\n\n  else if (info->mach == bfd_mach_i386_i8086)\n\n    priv.orig_sizeflag = 0;\n\n  else\n\n    abort ();\n\n\n\n  for (p = info->disassembler_options; p != NULL; )\n\n    {\n\n      if (strncmp (p, \"x86-64\", 6) == 0)\n\n\t{\n\n\t  address_mode = mode_64bit;\n\n\t  priv.orig_sizeflag = AFLAG | DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"i386\", 4) == 0)\n\n\t{\n\n\t  address_mode = mode_32bit;\n\n\t  priv.orig_sizeflag = AFLAG | DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"i8086\", 5) == 0)\n\n\t{\n\n\t  address_mode = mode_16bit;\n\n\t  priv.orig_sizeflag = 0;\n\n\t}\n\n      else if (strncmp (p, \"intel\", 5) == 0)\n\n\t{\n\n\t  intel_syntax = 1;\n\n\t}\n\n      else if (strncmp (p, \"att\", 3) == 0)\n\n\t{\n\n\t  intel_syntax = 0;\n\n\t}\n\n      else if (strncmp (p, \"addr\", 4) == 0)\n\n\t{\n\n\t  if (address_mode == mode_64bit)\n\n\t    {\n\n\t      if (p[4] == '3' && p[5] == '2')\n\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\n\t      else if (p[4] == '6' && p[5] == '4')\n\n\t\tpriv.orig_sizeflag |= AFLAG;\n\n\t    }\n\n\t  else\n\n\t    {\n\n\t      if (p[4] == '1' && p[5] == '6')\n\n\t\tpriv.orig_sizeflag &= ~AFLAG;\n\n\t      else if (p[4] == '3' && p[5] == '2')\n\n\t\tpriv.orig_sizeflag |= AFLAG;\n\n\t    }\n\n\t}\n\n      else if (strncmp (p, \"data\", 4) == 0)\n\n\t{\n\n\t  if (p[4] == '1' && p[5] == '6')\n\n\t    priv.orig_sizeflag &= ~DFLAG;\n\n\t  else if (p[4] == '3' && p[5] == '2')\n\n\t    priv.orig_sizeflag |= DFLAG;\n\n\t}\n\n      else if (strncmp (p, \"suffix\", 6) == 0)\n\n\tpriv.orig_sizeflag |= SUFFIX_ALWAYS;\n\n\n\n      p = strchr (p, ',');\n\n      if (p != NULL)\n\n\tp++;\n\n    }\n\n\n\n  if (intel_syntax)\n\n    {\n\n      names64 = intel_names64;\n\n      names32 = intel_names32;\n\n      names16 = intel_names16;\n\n      names8 = intel_names8;\n\n      names8rex = intel_names8rex;\n\n      names_seg = intel_names_seg;\n\n      index16 = intel_index16;\n\n      open_char = '[';\n\n      close_char = ']';\n\n      separator_char = '+';\n\n      scale_char = '*';\n\n    }\n\n  else\n\n    {\n\n      names64 = att_names64;\n\n      names32 = att_names32;\n\n      names16 = att_names16;\n\n      names8 = att_names8;\n\n      names8rex = att_names8rex;\n\n      names_seg = att_names_seg;\n\n      index16 = att_index16;\n\n      open_char = '(';\n\n      close_char =  ')';\n\n      separator_char = ',';\n\n      scale_char = ',';\n\n    }\n\n\n\n  /* The output looks better if we put 7 bytes on a line, since that\n\n     puts most long word instructions on a single line.  */\n\n  info->bytes_per_line = 7;\n\n\n\n  info->private_data = &priv;\n\n  priv.max_fetched = priv.the_buffer;\n\n  priv.insn_start = pc;\n\n\n\n  obuf[0] = 0;\n\n  for (i = 0; i < MAX_OPERANDS; ++i)\n\n    {\n\n      op_out[i][0] = 0;\n\n      op_index[i] = -1;\n\n    }\n\n\n\n  the_info = info;\n\n  start_pc = pc;\n\n  start_codep = priv.the_buffer;\n\n  codep = priv.the_buffer;\n\n\n\n  if (sigsetjmp(priv.bailout, 0) != 0)\n\n    {\n\n      const char *name;\n\n\n\n      /* Getting here means we tried for data but didn't get it.  That\n\n\t means we have an incomplete instruction of some sort.  Just\n\n\t print the first byte as a prefix or a .byte pseudo-op.  */\n\n      if (codep > priv.the_buffer)\n\n\t{\n\n\t  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n\t  if (name != NULL)\n\n\t    (*info->fprintf_func) (info->stream, \"%s\", name);\n\n\t  else\n\n\t    {\n\n\t      /* Just print the first byte as a .byte instruction.  */\n\n\t      (*info->fprintf_func) (info->stream, \".byte 0x%x\",\n\n\t\t\t\t     (unsigned int) priv.the_buffer[0]);\n\n\t    }\n\n\n\n\t  return 1;\n\n\t}\n\n\n\n      return -1;\n\n    }\n\n\n\n  obufp = obuf;\n\n  ckprefix ();\n\n  ckvexprefix ();\n\n\n\n  insn_codep = codep;\n\n  sizeflag = priv.orig_sizeflag;\n\n\n\n  fetch_data(info, codep + 1);\n\n  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);\n\n\n\n  if (((prefixes & PREFIX_FWAIT)\n\n       && ((*codep < 0xd8) || (*codep > 0xdf)))\n\n      || (rex && rex_used))\n\n    {\n\n      const char *name;\n\n\n\n      /* fwait not followed by floating point instruction, or rex followed\n\n\t by other prefixes.  Print the first prefix.  */\n\n      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s\", name);\n\n      return 1;\n\n    }\n\n\n\n  op = 0;\n\n  if (prefixes & PREFIX_VEX_0F)\n\n    {\n\n      used_prefixes |= PREFIX_VEX_0F | PREFIX_VEX_0F38 | PREFIX_VEX_0F3A;\n\n      if (prefixes & PREFIX_VEX_0F38)\n\n        threebyte = 0x38;\n\n      else if (prefixes & PREFIX_VEX_0F3A)\n\n        threebyte = 0x3a;\n\n      else\n\n        threebyte = *codep++;\n\n      goto vex_opcode;\n\n    }\n\n  if (*codep == 0x0f)\n\n    {\n\n      fetch_data(info, codep + 2);\n\n      threebyte = codep[1];\n\n      codep += 2;\n\n    vex_opcode:\n\n      dp = &dis386_twobyte[threebyte];\n\n      need_modrm = twobyte_has_modrm[threebyte];\n\n      uses_DATA_prefix = twobyte_uses_DATA_prefix[threebyte];\n\n      uses_REPNZ_prefix = twobyte_uses_REPNZ_prefix[threebyte];\n\n      uses_REPZ_prefix = twobyte_uses_REPZ_prefix[threebyte];\n\n      uses_LOCK_prefix = (threebyte & ~0x02) == 0x20;\n\n      if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)\n\n\t{\n\n          fetch_data(info, codep + 2);\n\n\t  op = *codep++;\n\n\t  switch (threebyte)\n\n\t    {\n\n\t    case 0x38:\n\n\t      uses_DATA_prefix = threebyte_0x38_uses_DATA_prefix[op];\n\n\t      uses_REPNZ_prefix = threebyte_0x38_uses_REPNZ_prefix[op];\n\n\t      uses_REPZ_prefix = threebyte_0x38_uses_REPZ_prefix[op];\n\n\t      break;\n\n\t    case 0x3a:\n\n\t      uses_DATA_prefix = threebyte_0x3a_uses_DATA_prefix[op];\n\n\t      uses_REPNZ_prefix = threebyte_0x3a_uses_REPNZ_prefix[op];\n\n\t      uses_REPZ_prefix = threebyte_0x3a_uses_REPZ_prefix[op];\n\n\t      break;\n\n\t    default:\n\n\t      break;\n\n\t    }\n\n\t}\n\n    }\n\n  else\n\n    {\n\n      dp = &dis386[*codep];\n\n      need_modrm = onebyte_has_modrm[*codep];\n\n      uses_DATA_prefix = 0;\n\n      uses_REPNZ_prefix = 0;\n\n      /* pause is 0xf3 0x90.  */\n\n      uses_REPZ_prefix = *codep == 0x90;\n\n      uses_LOCK_prefix = 0;\n\n      codep++;\n\n    }\n\n\n\n  if (!uses_REPZ_prefix && (prefixes & PREFIX_REPZ))\n\n    {\n\n      oappend (\"repz \");\n\n      used_prefixes |= PREFIX_REPZ;\n\n    }\n\n  if (!uses_REPNZ_prefix && (prefixes & PREFIX_REPNZ))\n\n    {\n\n      oappend (\"repnz \");\n\n      used_prefixes |= PREFIX_REPNZ;\n\n    }\n\n\n\n  if (!uses_LOCK_prefix && (prefixes & PREFIX_LOCK))\n\n    {\n\n      oappend (\"lock \");\n\n      used_prefixes |= PREFIX_LOCK;\n\n    }\n\n\n\n  if (prefixes & PREFIX_ADDR)\n\n    {\n\n      sizeflag ^= AFLAG;\n\n      if (dp->op[2].bytemode != loop_jcxz_mode || intel_syntax)\n\n\t{\n\n\t  if ((sizeflag & AFLAG) || address_mode == mode_64bit)\n\n\t    oappend (\"addr32 \");\n\n\t  else\n\n\t    oappend (\"addr16 \");\n\n\t  used_prefixes |= PREFIX_ADDR;\n\n\t}\n\n    }\n\n\n\n  if (!uses_DATA_prefix && (prefixes & PREFIX_DATA))\n\n    {\n\n      sizeflag ^= DFLAG;\n\n      if (dp->op[2].bytemode == cond_jump_mode\n\n\t  && dp->op[0].bytemode == v_mode\n\n\t  && !intel_syntax)\n\n\t{\n\n\t  if (sizeflag & DFLAG)\n\n\t    oappend (\"data32 \");\n\n\t  else\n\n\t    oappend (\"data16 \");\n\n\t  used_prefixes |= PREFIX_DATA;\n\n\t}\n\n    }\n\n\n\n  if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)\n\n    {\n\n      dp = &three_byte_table[dp->op[1].bytemode][op];\n\n      modrm.mod = (*codep >> 6) & 3;\n\n      modrm.reg = (*codep >> 3) & 7;\n\n      modrm.rm = *codep & 7;\n\n    }\n\n  else if (need_modrm)\n\n    {\n\n      fetch_data(info, codep + 1);\n\n      modrm.mod = (*codep >> 6) & 3;\n\n      modrm.reg = (*codep >> 3) & 7;\n\n      modrm.rm = *codep & 7;\n\n    }\n\n\n\n  if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n\n    {\n\n      dofloat (sizeflag);\n\n    }\n\n  else\n\n    {\n\n      int index;\n\n      if (dp->name == NULL)\n\n\t{\n\n\t  switch (dp->op[0].bytemode)\n\n\t    {\n\n\t    case USE_GROUPS:\n\n\t      dp = &grps[dp->op[1].bytemode][modrm.reg];\n\n\t      break;\n\n\n\n\t    case USE_PREFIX_USER_TABLE:\n\n\t      index = 0;\n\n\t      used_prefixes |= (prefixes & PREFIX_REPZ);\n\n\t      if (prefixes & PREFIX_REPZ)\n\n\t\tindex = 1;\n\n\t      else\n\n\t\t{\n\n\t\t  /* We should check PREFIX_REPNZ and PREFIX_REPZ\n\n\t\t     before PREFIX_DATA.  */\n\n\t\t  used_prefixes |= (prefixes & PREFIX_REPNZ);\n\n\t\t  if (prefixes & PREFIX_REPNZ)\n\n\t\t    index = 3;\n\n\t\t  else\n\n\t\t    {\n\n\t\t      used_prefixes |= (prefixes & PREFIX_DATA);\n\n\t\t      if (prefixes & PREFIX_DATA)\n\n\t\t\tindex = 2;\n\n\t\t    }\n\n\t\t}\n\n\t      dp = &prefix_user_table[dp->op[1].bytemode][index];\n\n\t      break;\n\n\n\n\t    case X86_64_SPECIAL:\n\n\t      index = address_mode == mode_64bit ? 1 : 0;\n\n\t      dp = &x86_64_table[dp->op[1].bytemode][index];\n\n\t      break;\n\n\n\n\t    default:\n\n\t      oappend (INTERNAL_DISASSEMBLER_ERROR);\n\n\t      break;\n\n\t    }\n\n\t}\n\n\n\n      if (putop (dp->name, sizeflag) == 0)\n\n        {\n\n\t  for (i = 0; i < MAX_OPERANDS; ++i)\n\n\t    {\n\n\t      obufp = op_out[i];\n\n\t      op_ad = MAX_OPERANDS - 1 - i;\n\n\t      if (dp->op[i].rtn)\n\n\t\t(*dp->op[i].rtn) (dp->op[i].bytemode, sizeflag);\n\n\t    }\n\n\t}\n\n    }\n\n\n\n  /* See if any prefixes were not used.  If so, print the first one\n\n     separately.  If we don't do this, we'll wind up printing an\n\n     instruction stream which does not precisely correspond to the\n\n     bytes we are disassembling.  */\n\n  if ((prefixes & ~used_prefixes) != 0)\n\n    {\n\n      const char *name;\n\n\n\n      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s\", name);\n\n      return 1;\n\n    }\n\n  if (rex & ~rex_used)\n\n    {\n\n      const char *name;\n\n      name = prefix_name (rex | 0x40, priv.orig_sizeflag);\n\n      if (name == NULL)\n\n\tname = INTERNAL_DISASSEMBLER_ERROR;\n\n      (*info->fprintf_func) (info->stream, \"%s \", name);\n\n    }\n\n\n\n  obufp = obuf + strlen (obuf);\n\n  for (i = strlen (obuf); i < 6; i++)\n\n    oappend (\" \");\n\n  oappend (\" \");\n\n  (*info->fprintf_func) (info->stream, \"%s\", obuf);\n\n\n\n  /* The enter and bound instructions are printed with operands in the same\n\n     order as the intel book; everything else is printed in reverse order.  */\n\n  if (intel_syntax || two_source_ops)\n\n    {\n\n      bfd_vma riprel;\n\n\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\n        op_txt[i] = op_out[i];\n\n\n\n      for (i = 0; i < (MAX_OPERANDS >> 1); ++i)\n\n\t{\n\n          op_ad = op_index[i];\n\n          op_index[i] = op_index[MAX_OPERANDS - 1 - i];\n\n          op_index[MAX_OPERANDS - 1 - i] = op_ad;\n\n\t  riprel = op_riprel[i];\n\n\t  op_riprel[i] = op_riprel [MAX_OPERANDS - 1 - i];\n\n\t  op_riprel[MAX_OPERANDS - 1 - i] = riprel;\n\n\t}\n\n    }\n\n  else\n\n    {\n\n      for (i = 0; i < MAX_OPERANDS; ++i)\n\n        op_txt[MAX_OPERANDS - 1 - i] = op_out[i];\n\n    }\n\n\n\n  needcomma = 0;\n\n  for (i = 0; i < MAX_OPERANDS; ++i)\n\n    if (*op_txt[i])\n\n      {\n\n\tif (needcomma)\n\n\t  (*info->fprintf_func) (info->stream, \",\");\n\n\tif (op_index[i] != -1 && !op_riprel[i])\n\n\t  (*info->print_address_func) ((bfd_vma) op_address[op_index[i]], info);\n\n\telse\n\n\t  (*info->fprintf_func) (info->stream, \"%s\", op_txt[i]);\n\n\tneedcomma = 1;\n\n      }\n\n\n\n  for (i = 0; i < MAX_OPERANDS; i++)\n\n    if (op_index[i] != -1 && op_riprel[i])\n\n      {\n\n\t(*info->fprintf_func) (info->stream, \"        # \");\n\n\t(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep\n\n\t\t\t\t\t\t+ op_address[op_index[i]]), info);\n\n\tbreak;\n\n      }\n\n  return codep - priv.the_buffer;\n\n}\n", "target": 1}
{"task_id": "defect/train/12", "input": "static void vp6_parse_coeff_huffman(VP56Context *s)\n\n{\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->scantable.permutated;\n\n    VLC *vlc_coeff;\n\n    int coeff, sign, coeff_idx;\n\n    int b, cg, idx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 0;    /* code type */\n\n        if (b > 3) pt = 1;\n\n        vlc_coeff = &s->dccv_vlc[pt];\n\n\n\n        for (coeff_idx=0; coeff_idx<64; ) {\n\n            int run = 1;\n\n            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {\n\n                s->nb_null[coeff_idx][pt]--;\n\n                if (coeff_idx)\n\n                    break;\n\n            } else {\n\n                if (get_bits_count(&s->gb) >= s->gb.size_in_bits)\n\n                    return;\n\n                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);\n\n                if (coeff == 0) {\n\n                    if (coeff_idx) {\n\n                        int pt = (coeff_idx >= 6);\n\n                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);\n\n                        if (run >= 9)\n\n                            run += get_bits(&s->gb, 6);\n\n                    } else\n\n                        s->nb_null[0][pt] = vp6_get_nb_null(s);\n\n                    ct = 0;\n\n                } else if (coeff == 11) {  /* end of block */\n\n                    if (coeff_idx == 1)    /* first AC coeff ? */\n\n                        s->nb_null[1][pt] = vp6_get_nb_null(s);\n\n                    break;\n\n                } else {\n\n                    int coeff2 = vp56_coeff_bias[coeff];\n\n                    if (coeff > 4)\n\n                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);\n\n                    ct = 1 + (coeff2 > 1);\n\n                    sign = get_bits1(&s->gb);\n\n                    coeff2 = (coeff2 ^ -sign) + sign;\n\n                    if (coeff_idx)\n\n                        coeff2 *= s->dequant_ac;\n\n                    idx = model->coeff_index_to_pos[coeff_idx];\n\n                    s->block_coeff[b][permute[idx]] = coeff2;\n\n                }\n\n            }\n\n            coeff_idx+=run;\n\n            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);\n\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n\n        }\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/13", "input": "static int vncws_start_tls_handshake(VncState *vs)\n\n{\n\n    int ret = gnutls_handshake(vs->tls.session);\n\n\n\n    if (ret < 0) {\n\n        if (!gnutls_error_is_fatal(ret)) {\n\n            VNC_DEBUG(\"Handshake interrupted (blocking)\\n\");\n\n            if (!gnutls_record_get_direction(vs->tls.session)) {\n\n                qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io,\n\n                                    NULL, vs);\n\n            } else {\n\n                qemu_set_fd_handler(vs->csock, NULL, vncws_tls_handshake_io,\n\n                                    vs);\n\n            }\n\n            return 0;\n\n        }\n\n        VNC_DEBUG(\"Handshake failed %s\\n\", gnutls_strerror(ret));\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (vs->vd->tls.x509verify) {\n\n        if (vnc_tls_validate_certificate(vs) < 0) {\n\n            VNC_DEBUG(\"Client verification failed\\n\");\n\n            vnc_client_error(vs);\n\n            return -1;\n\n        } else {\n\n            VNC_DEBUG(\"Client verification passed\\n\");\n\n        }\n\n    }\n\n\n\n    VNC_DEBUG(\"Handshake done, switching to TLS data mode\\n\");\n\n    qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/14", "input": "av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "target": 0}
{"task_id": "defect/train/15", "input": "static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    char *backing_file = NULL;\n\n    char *backing_fmt = NULL;\n\n    char *buf = NULL;\n\n    uint64_t size = 0;\n\n    int flags = 0;\n\n    size_t cluster_size = DEFAULT_CLUSTER_SIZE;\n\n    PreallocMode prealloc;\n\n    int version;\n\n    uint64_t refcount_bits;\n\n    int refcount_order;\n\n    const char *encryptfmt = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    /* Read out options */\n\n    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),\n\n                    BDRV_SECTOR_SIZE);\n\n    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);\n\n    encryptfmt = qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT_FORMAT);\n\n    if (encryptfmt) {\n\n        if (qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT)) {\n\n            error_setg(errp, \"Options \" BLOCK_OPT_ENCRYPT \" and \"\n\n                       BLOCK_OPT_ENCRYPT_FORMAT \" are mutually exclusive\");\n\n            ret = -EINVAL;\n\n            goto finish;\n\n        }\n\n    } else if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {\n\n        encryptfmt = \"aes\";\n\n    }\n\n    cluster_size = qcow2_opt_get_cluster_size_del(opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,\n\n                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,\n\n                               &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    version = qcow2_opt_get_version_del(opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n\n        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;\n\n    }\n\n\n\n    if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n\n        error_setg(errp, \"Backing file and preallocation cannot be used at \"\n\n                   \"the same time\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {\n\n        error_setg(errp, \"Lazy refcounts only supported with compatibility \"\n\n                   \"level 1.1 and above (use compat=1.1 or greater)\");\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto finish;\n\n    }\n\n\n\n    refcount_order = ctz32(refcount_bits);\n\n\n\n    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,\n\n                        cluster_size, prealloc, opts, version, refcount_order,\n\n                        encryptfmt, &local_err);\n\n    error_propagate(errp, local_err);\n\n\n\nfinish:\n\n    g_free(backing_file);\n\n    g_free(backing_fmt);\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "target": 1}
{"task_id": "defect/train/16", "input": "static void quantize_mantissas(AC3EncodeContext *s)\n\n{\n\n    int blk, ch;\n\n\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        AC3Block *block = &s->blocks[blk];\n\n        s->mant1_cnt  = s->mant2_cnt  = s->mant4_cnt  = 0;\n\n        s->qmant1_ptr = s->qmant2_ptr = s->qmant4_ptr = NULL;\n\n\n\n        for (ch = 0; ch < s->channels; ch++) {\n\n            quantize_mantissas_blk_ch(s, block->fixed_coef[ch], block->exp_shift[ch],\n\n                                      block->exp[ch], block->bap[ch],\n\n                                      block->qmant[ch], s->nb_coefs[ch]);\n\n        }\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/17", "input": "static void dma_blk_cb(void *opaque, int ret)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n    dma_addr_t cur_addr, cur_len;\n\n    void *mem;\n\n\n\n    trace_dma_blk_cb(dbs, ret);\n\n\n\n    dbs->acb = NULL;\n\n    dbs->sector_num += dbs->iov.size / 512;\n\n\n\n    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {\n\n        dma_complete(dbs, ret);\n\n        return;\n\n    }\n\n    dma_blk_unmap(dbs);\n\n\n\n    while (dbs->sg_cur_index < dbs->sg->nsg) {\n\n        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;\n\n        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;\n\n        mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);\n\n        if (!mem)\n\n            break;\n\n        qemu_iovec_add(&dbs->iov, mem, cur_len);\n\n        dbs->sg_cur_byte += cur_len;\n\n        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {\n\n            dbs->sg_cur_byte = 0;\n\n            ++dbs->sg_cur_index;\n\n        }\n\n    }\n\n\n\n    if (dbs->iov.size == 0) {\n\n        trace_dma_map_wait(dbs);\n\n        cpu_register_map_client(dbs, continue_after_map_failure);\n\n        return;\n\n    }\n\n\n\n    if (dbs->iov.size & ~BDRV_SECTOR_MASK) {\n\n        qemu_iovec_discard_back(&dbs->iov, dbs->iov.size & ~BDRV_SECTOR_MASK);\n\n    }\n\n\n\n    dbs->acb = dbs->io_func(dbs->blk, dbs->sector_num, &dbs->iov,\n\n                            dbs->iov.size / 512, dma_blk_cb, dbs);\n\n    assert(dbs->acb);\n\n}\n", "target": 1}
{"task_id": "defect/train/18", "input": "long do_sigreturn(CPUPPCState *env)\n\n{\n\n    struct target_sigcontext *sc = NULL;\n\n    struct target_mcontext *sr = NULL;\n\n    target_ulong sr_addr = 0, sc_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t set;\n\n\n\n    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;\n\n    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1))\n\n        goto sigsegv;\n\n\n\n#if defined(TARGET_PPC64)\n\n    set.sig[0] = sc->oldmask + ((uint64_t)(sc->_unused[3]) << 32);\n\n#else\n\n    __get_user(set.sig[0], &sc->oldmask);\n\n    __get_user(set.sig[1], &sc->_unused[3]);\n\n#endif\n\n    target_to_host_sigset_internal(&blocked, &set);\n\n    set_sigmask(&blocked);\n\n\n\n    __get_user(sr_addr, &sc->regs);\n\n    if (!lock_user_struct(VERIFY_READ, sr, sr_addr, 1))\n\n        goto sigsegv;\n\n    restore_user_regs(env, sr, 1);\n\n\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nsigsegv:\n\n    unlock_user_struct(sr, sr_addr, 1);\n\n    unlock_user_struct(sc, sc_addr, 1);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/19", "input": "static int virtio_gpu_load(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    VirtIOGPU *g = opaque;\n\n    struct virtio_gpu_simple_resource *res;\n\n    struct virtio_gpu_scanout *scanout;\n\n    uint32_t resource_id, pformat;\n\n    int i;\n\n\n\n    g->hostmem = 0;\n\n\n\n    resource_id = qemu_get_be32(f);\n\n    while (resource_id != 0) {\n\n        res = g_new0(struct virtio_gpu_simple_resource, 1);\n\n        res->resource_id = resource_id;\n\n        res->width = qemu_get_be32(f);\n\n        res->height = qemu_get_be32(f);\n\n        res->format = qemu_get_be32(f);\n\n        res->iov_cnt = qemu_get_be32(f);\n\n\n\n        /* allocate */\n\n        pformat = get_pixman_format(res->format);\n\n        if (!pformat) {\n\n\n            return -EINVAL;\n\n\n        res->image = pixman_image_create_bits(pformat,\n\n                                              res->width, res->height,\n\n                                              NULL, 0);\n\n        if (!res->image) {\n\n\n            return -EINVAL;\n\n\n\n\n        res->hostmem = PIXMAN_FORMAT_BPP(pformat) * res->width * res->height;\n\n\n\n        res->addrs = g_new(uint64_t, res->iov_cnt);\n\n        res->iov = g_new(struct iovec, res->iov_cnt);\n\n\n\n        /* read data */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            res->addrs[i] = qemu_get_be64(f);\n\n            res->iov[i].iov_len = qemu_get_be32(f);\n\n\n        qemu_get_buffer(f, (void *)pixman_image_get_data(res->image),\n\n                        pixman_image_get_stride(res->image) * res->height);\n\n\n\n        /* restore mapping */\n\n        for (i = 0; i < res->iov_cnt; i++) {\n\n            hwaddr len = res->iov[i].iov_len;\n\n            res->iov[i].iov_base =\n\n                cpu_physical_memory_map(res->addrs[i], &len, 1);\n\n            if (!res->iov[i].iov_base || len != res->iov[i].iov_len) {\n\n\n\n\n\n\n\n\n\n\n\n                return -EINVAL;\n\n\n\n\n\n        QTAILQ_INSERT_HEAD(&g->reslist, res, next);\n\n        g->hostmem += res->hostmem;\n\n\n\n        resource_id = qemu_get_be32(f);\n\n\n\n\n    /* load & apply scanout state */\n\n    vmstate_load_state(f, &vmstate_virtio_gpu_scanouts, g, 1);\n\n    for (i = 0; i < g->conf.max_outputs; i++) {\n\n        scanout = &g->scanout[i];\n\n        if (!scanout->resource_id) {\n\n            continue;\n\n\n        res = virtio_gpu_find_resource(g, scanout->resource_id);\n\n        if (!res) {\n\n            return -EINVAL;\n\n\n        scanout->ds = qemu_create_displaysurface_pixman(res->image);\n\n        if (!scanout->ds) {\n\n            return -EINVAL;\n\n\n\n\n        dpy_gfx_replace_surface(scanout->con, scanout->ds);\n\n        dpy_gfx_update(scanout->con, 0, 0, scanout->width, scanout->height);\n\n        update_cursor(g, &scanout->cursor);\n\n        res->scanout_bitmask |= (1 << i);\n\n\n\n\n    return 0;\n", "target": 1}
{"task_id": "defect/train/20", "input": "static av_cold int iv_alloc_frames(Indeo3DecodeContext *s)\n\n{\n\n    int luma_width    = (s->width           + 3) & ~3,\n\n        luma_height   = (s->height          + 3) & ~3,\n\n        chroma_width  = ((luma_width  >> 2) + 3) & ~3,\n\n        chroma_height = ((luma_height >> 2) + 3) & ~3,\n\n        luma_pixels   = luma_width   * luma_height,\n\n        chroma_pixels = chroma_width * chroma_height,\n\n        i;\n\n    unsigned int bufsize = luma_pixels * 2 + luma_width * 3 +\n\n                          (chroma_pixels   + chroma_width) * 4;\n\n\n\n\n    if(!(s->buf = av_malloc(bufsize)))\n\n        return AVERROR(ENOMEM);\n\n    s->iv_frame[0].y_w = s->iv_frame[1].y_w = luma_width;\n\n    s->iv_frame[0].y_h = s->iv_frame[1].y_h = luma_height;\n\n    s->iv_frame[0].uv_w = s->iv_frame[1].uv_w = chroma_width;\n\n    s->iv_frame[0].uv_h = s->iv_frame[1].uv_h = chroma_height;\n\n\n\n    s->iv_frame[0].Ybuf = s->buf + luma_width;\n\n    i = luma_pixels + luma_width * 2;\n\n    s->iv_frame[1].Ybuf = s->buf + i;\n\n    i += (luma_pixels + luma_width);\n\n    s->iv_frame[0].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Ubuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[0].Vbuf = s->buf + i;\n\n    i += (chroma_pixels + chroma_width);\n\n    s->iv_frame[1].Vbuf = s->buf + i;\n\n\n\n    for(i = 1; i <= luma_width; i++)\n\n        s->iv_frame[0].Ybuf[-i] = s->iv_frame[1].Ybuf[-i] =\n\n            s->iv_frame[0].Ubuf[-i] = 0x80;\n\n\n\n    for(i = 1; i <= chroma_width; i++) {\n\n        s->iv_frame[1].Ubuf[-i] = 0x80;\n\n        s->iv_frame[0].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[-i] = 0x80;\n\n        s->iv_frame[1].Vbuf[chroma_pixels+i-1] = 0x80;\n\n    }\n\n\n\n    return 0;\n\n}", "target": 1}
{"task_id": "defect/train/21", "input": "static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    int ret;\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"minf\");\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        mov_write_vmhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        mov_write_smhd_tag(pb);\n\n    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n\n            mov_write_gmhd_tag(pb, track);\n\n        } else {\n\n            mov_write_nmhd_tag(pb);\n\n        }\n\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n\n        mov_write_hmhd_tag(pb);\n\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n\n        mov_write_gmhd_tag(pb, track);\n\n    }\n\n    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */\n\n        mov_write_hdlr_tag(pb, NULL);\n\n    mov_write_dinf_tag(pb);\n\n    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)\n\n        return ret;\n\n    return update_size(pb, pos);\n\n}\n", "target": 0}
{"task_id": "defect/train/22", "input": "int av_packet_ref(AVPacket *dst, AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n    } else\n\n        dst->buf = av_buffer_ref(src->buf);\n\n\n\n    dst->size = src->size;\n\n    dst->data = dst->buf->data;\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n", "target": 0}
{"task_id": "defect/train/23", "input": "av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)\n\n{\n\n#if HAVE_ALTIVEC\n\n    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))\n\n        return;\n\n\n\n    fdsp->vector_fmul = ff_vector_fmul_altivec;\n\n    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;\n\n    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;\n\n\n\n    if (!bit_exact) {\n\n        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;\n\n    }\n\n#endif\n\n}\n", "target": 0}
{"task_id": "defect/train/24", "input": "static int config_props(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    LutContext *lut = ctx->priv;\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];\n\n    int min[4], max[4];\n\n    int val, comp, ret;\n\n\n\n    lut->hsub = desc->log2_chroma_w;\n\n    lut->vsub = desc->log2_chroma_h;\n\n\n\n    lut->var_values[VAR_W] = inlink->w;\n\n    lut->var_values[VAR_H] = inlink->h;\n\n\n\n    switch (inlink->format) {\n\n    case PIX_FMT_YUV410P:\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV440P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_YUVA420P:\n\n        min[Y] = min[U] = min[V] = 16;\n\n        max[Y] = 235;\n\n        max[U] = max[V] = 240;\n\n        min[A] = 0; max[A] = 255;\n\n        break;\n\n    default:\n\n        min[0] = min[1] = min[2] = min[3] = 0;\n\n        max[0] = max[1] = max[2] = max[3] = 255;\n\n    }\n\n\n\n    lut->is_yuv = lut->is_rgb = 0;\n\n    if      (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;\n\n    else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;\n\n\n\n    if (lut->is_rgb) {\n\n        switch (inlink->format) {\n\n        case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;\n\n        case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;\n\n        case PIX_FMT_RGBA:\n\n        case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;\n\n        case PIX_FMT_BGRA:\n\n        case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;\n\n        }\n\n        lut->step = av_get_bits_per_pixel(desc) >> 3;\n\n    }\n\n\n\n    for (comp = 0; comp < desc->nb_components; comp++) {\n\n        double res;\n\n\n\n        /* create the parsed expression */\n\n        ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],\n\n                            var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);\n\n        if (ret < 0) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Error when parsing the expression '%s' for the component %d.\\n\",\n\n                   lut->comp_expr_str[comp], comp);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        /* compute the lut */\n\n        lut->var_values[VAR_MAXVAL] = max[comp];\n\n        lut->var_values[VAR_MINVAL] = min[comp];\n\n\n\n        for (val = 0; val < 256; val++) {\n\n            lut->var_values[VAR_VAL] = val;\n\n            lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);\n\n            lut->var_values[VAR_NEGVAL] =\n\n                av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],\n\n                        min[comp], max[comp]);\n\n\n\n            res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);\n\n            if (isnan(res)) {\n\n                av_log(ctx, AV_LOG_ERROR,\n\n                       \"Error when evaluating the expression '%s' for the value %d for the component #%d.\\n\",\n\n                       lut->comp_expr_str[comp], val, comp);\n\n                return AVERROR(EINVAL);\n\n            }\n\n            lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);\n\n            av_log(ctx, AV_LOG_DEBUG, \"val[%d][%d] = %d\\n\", comp, val, lut->lut[comp][val]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/25", "input": "static av_cold int rpza_decode_init(AVCodecContext *avctx)\n\n{\n\n    RpzaContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/26", "input": "static int huffman_decode(MPADecodeContext *s, GranuleDef *g,\n\n                          int16_t *exponents, int end_pos2)\n\n{\n\n    int s_index;\n\n    int i;\n\n    int last_pos, bits_left;\n\n    VLC *vlc;\n\n    int end_pos = FFMIN(end_pos2, s->gb.size_in_bits);\n\n\n\n    /* low frequencies (called big values) */\n\n    s_index = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        int j, k, l, linbits;\n\n        j = g->region_size[i];\n\n        if (j == 0)\n\n            continue;\n\n        /* select vlc table */\n\n        k       = g->table_select[i];\n\n        l       = mpa_huff_data[k][0];\n\n        linbits = mpa_huff_data[k][1];\n\n        vlc     = &huff_vlc[l];\n\n\n\n        if (!l) {\n\n            memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * 2 * j);\n\n            s_index += 2 * j;\n\n            continue;\n\n        }\n\n\n\n        /* read huffcode and compute each couple */\n\n        for (; j > 0; j--) {\n\n            int exponent, x, y;\n\n            int v;\n\n            int pos = get_bits_count(&s->gb);\n\n\n\n            if (pos >= end_pos){\n\n                switch_buffer(s, &pos, &end_pos, &end_pos2);\n\n                if (pos >= end_pos)\n\n                    break;\n\n            }\n\n            y = get_vlc2(&s->gb, vlc->table, 7, 3);\n\n\n\n            if (!y) {\n\n                g->sb_hybrid[s_index  ] =\n\n                g->sb_hybrid[s_index+1] = 0;\n\n                s_index += 2;\n\n                continue;\n\n            }\n\n\n\n            exponent= exponents[s_index];\n\n\n\n            ff_dlog(s->avctx, \"region=%d n=%d x=%d y=%d exp=%d\\n\",\n\n                    i, g->region_size[i] - j, x, y, exponent);\n\n            if (y & 16) {\n\n                x = y >> 5;\n\n                y = y & 0x0f;\n\n                if (x < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index, RENAME(expval_table)[exponent] + x)\n\n                } else {\n\n                    x += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(x, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index] = v;\n\n                }\n\n                if (y < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index + 1, RENAME(expval_table)[exponent] + y)\n\n                } else {\n\n                    y += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(y, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index+1] = v;\n\n                }\n\n            } else {\n\n                x = y >> 5;\n\n                y = y & 0x0f;\n\n                x += y;\n\n                if (x < 15) {\n\n                    READ_FLIP_SIGN(g->sb_hybrid + s_index + !!y, RENAME(expval_table)[exponent] + x)\n\n                } else {\n\n                    x += get_bitsz(&s->gb, linbits);\n\n                    v  = l3_unscale(x, exponent);\n\n                    if (get_bits1(&s->gb))\n\n                        v = -v;\n\n                    g->sb_hybrid[s_index+!!y] = v;\n\n                }\n\n                g->sb_hybrid[s_index + !y] = 0;\n\n            }\n\n            s_index += 2;\n\n        }\n\n    }\n\n\n\n    /* high frequencies */\n\n    vlc = &huff_quad_vlc[g->count1table_select];\n\n    last_pos = 0;\n\n    while (s_index <= 572) {\n\n        int pos, code;\n\n        pos = get_bits_count(&s->gb);\n\n        if (pos >= end_pos) {\n\n            if (pos > end_pos2 && last_pos) {\n\n                /* some encoders generate an incorrect size for this\n\n                   part. We must go back into the data */\n\n                s_index -= 4;\n\n                skip_bits_long(&s->gb, last_pos - pos);\n\n                av_log(s->avctx, AV_LOG_INFO, \"overread, skip %d enddists: %d %d\\n\", last_pos - pos, end_pos-pos, end_pos2-pos);\n\n                if(s->err_recognition & AV_EF_BITSTREAM)\n\n                    s_index=0;\n\n                break;\n\n            }\n\n            switch_buffer(s, &pos, &end_pos, &end_pos2);\n\n            if (pos >= end_pos)\n\n                break;\n\n        }\n\n        last_pos = pos;\n\n\n\n        code = get_vlc2(&s->gb, vlc->table, vlc->bits, 1);\n\n        ff_dlog(s->avctx, \"t=%d code=%d\\n\", g->count1table_select, code);\n\n        g->sb_hybrid[s_index+0] =\n\n        g->sb_hybrid[s_index+1] =\n\n        g->sb_hybrid[s_index+2] =\n\n        g->sb_hybrid[s_index+3] = 0;\n\n        while (code) {\n\n            static const int idxtab[16] = { 3,3,2,2,1,1,1,1,0,0,0,0,0,0,0,0 };\n\n            int v;\n\n            int pos = s_index + idxtab[code];\n\n            code   ^= 8 >> idxtab[code];\n\n            READ_FLIP_SIGN(g->sb_hybrid + pos, RENAME(exp_table)+exponents[pos])\n\n        }\n\n        s_index += 4;\n\n    }\n\n    /* skip extension bits */\n\n    bits_left = end_pos2 - get_bits_count(&s->gb);\n\n    if (bits_left < 0 && (s->err_recognition & AV_EF_BUFFER)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"bits_left=%d\\n\", bits_left);\n\n        s_index=0;\n\n    } else if (bits_left > 0 && (s->err_recognition & AV_EF_BUFFER)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"bits_left=%d\\n\", bits_left);\n\n        s_index = 0;\n\n    }\n\n    memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * (576 - s_index));\n\n    skip_bits_long(&s->gb, bits_left);\n\n\n\n    i = get_bits_count(&s->gb);\n\n    switch_buffer(s, &i, &end_pos, &end_pos2);\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/27", "input": "void helper_slbie(CPUPPCState *env, target_ulong addr)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    ppc_slb_t *slb;\n\n\n\n    slb = slb_lookup(cpu, addr);\n\n    if (!slb) {\n\n        return;\n\n    }\n\n\n\n    if (slb->esid & SLB_ESID_V) {\n\n        slb->esid &= ~SLB_ESID_V;\n\n\n\n        /* XXX: given the fact that segment size is 256 MB or 1TB,\n\n         *      and we still don't have a tlb_flush_mask(env, n, mask)\n\n         *      in QEMU, we just invalidate all TLBs\n\n         */\n\n        tlb_flush(CPU(cpu), 1);\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/28", "input": "static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)\n\n{\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n\n\n    /* MSR:POW cannot be set by any form of rfi */\n\n    msr &= ~(1ULL << MSR_POW);\n\n\n\n#if defined(TARGET_PPC64)\n\n    /* Switching to 32-bit ? Crop the nip */\n\n    if (!msr_is_64bit(env, msr)) {\n\n        nip = (uint32_t)nip;\n\n    }\n\n#else\n\n    nip = (uint32_t)nip;\n\n#endif\n\n    /* XXX: beware: this is false if VLE is supported */\n\n    env->nip = nip & ~((target_ulong)0x00000003);\n\n    hreg_store_msr(env, msr, 1);\n\n#if defined(DEBUG_OP)\n\n    cpu_dump_rfi(env->nip, env->msr);\n\n#endif\n\n    /* No need to raise an exception here,\n\n     * as rfi is always the last insn of a TB\n\n     */\n\n    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n\n\n\n    /* Context synchronizing: check if TCG TLB needs flush */\n\n    check_tlb_flush(env);\n\n}\n", "target": 1}
{"task_id": "defect/train/29", "input": "static void d3d11va_device_uninit(AVHWDeviceContext *hwdev)\n\n{\n\n    AVD3D11VADeviceContext *device_hwctx = hwdev->hwctx;\n\n\n\n    if (device_hwctx->device)\n\n        ID3D11Device_Release(device_hwctx->device);\n\n\n\n    if (device_hwctx->device_context)\n\n        ID3D11DeviceContext_Release(device_hwctx->device_context);\n\n\n\n    if (device_hwctx->video_device)\n\n        ID3D11VideoDevice_Release(device_hwctx->video_device);\n\n\n\n    if (device_hwctx->video_context)\n\n        ID3D11VideoContext_Release(device_hwctx->video_context);\n\n\n\n    if (device_hwctx->lock == d3d11va_default_lock)\n\n        CloseHandle(device_hwctx->lock_ctx);\n\n}\n", "target": 1}
{"task_id": "defect/train/30", "input": "int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        codec->channels    = avio_rl16(pb);\n\n        codec->sample_rate = avio_rl32(pb);\n\n        bitrate            = avio_rl32(pb) * 8;\n\n        codec->block_align = avio_rl16(pb);\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18) {  /* We're obviously dealing with WAVEFORMATEX */\n\n        int cbSize = avio_rl16(pb); /* cbSize */\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        /* It is possible for the chunk to contain garbage at the end */\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/31", "input": "static void test_acpi_asl(test_data *data)\n\n{\n\n    int i;\n\n    AcpiSdtTable *sdt, *exp_sdt;\n\n    test_data exp_data;\n\n    gboolean exp_err, err;\n\n\n\n    memset(&exp_data, 0, sizeof(exp_data));\n\n    exp_data.tables = load_expected_aml(data);\n\n    dump_aml_files(data, false);\n\n    for (i = 0; i < data->tables->len; ++i) {\n\n        GString *asl, *exp_asl;\n\n\n\n        sdt = &g_array_index(data->tables, AcpiSdtTable, i);\n\n        exp_sdt = &g_array_index(exp_data.tables, AcpiSdtTable, i);\n\n\n\n        err = load_asl(data->tables, sdt);\n\n        asl = normalize_asl(sdt->asl);\n\n\n\n        exp_err = load_asl(exp_data.tables, exp_sdt);\n\n        exp_asl = normalize_asl(exp_sdt->asl);\n\n\n\n        /* TODO: check for warnings */\n\n        g_assert(!err || exp_err);\n\n\n\n        if (g_strcmp0(asl->str, exp_asl->str)) {\n\n            uint32_t signature = cpu_to_le32(exp_sdt->header.signature);\n\n            sdt->tmp_files_retain = true;\n\n            exp_sdt->tmp_files_retain = true;\n\n            fprintf(stderr,\n\n                    \"acpi-test: Warning! %.4s mismatch. \"\n\n                    \"Actual [asl:%s, aml:%s], Expected [asl:%s, aml:%s].\\n\",\n\n                    (gchar *)&signature,\n\n                    sdt->asl_file, sdt->aml_file,\n\n                    exp_sdt->asl_file, exp_sdt->aml_file);\n\n        }\n\n        g_string_free(asl, true);\n\n        g_string_free(exp_asl, true);\n\n    }\n\n\n\n    free_test_data(&exp_data);\n\n}\n", "target": 1}
{"task_id": "defect/train/32", "input": "static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,\n\n                                int size, int type,\n\n                                uint32_t **lace_buf, int *laces)\n\n{\n\n    int res = 0, n;\n\n    uint8_t *data = *buf;\n\n    uint32_t *lace_size;\n\n\n\n    if (!type) {\n\n        *laces = 1;\n\n        *lace_buf = av_mallocz(sizeof(int));\n\n        if (!*lace_buf)\n\n            return AVERROR(ENOMEM);\n\n\n\n        *lace_buf[0] = size;\n\n        return 0;\n\n    }\n\n\n\n    assert(size > 0);\n\n    *laces = *data + 1;\n\n    data += 1;\n\n    size -= 1;\n\n    lace_size = av_mallocz(*laces * sizeof(int));\n\n    if (!lace_size)\n\n        return AVERROR(ENOMEM);\n\n\n\n    switch (type) {\n\n    case 0x1: /* Xiph lacing */ {\n\n        uint8_t temp;\n\n        uint32_t total = 0;\n\n        for (n = 0; res == 0 && n < *laces - 1; n++) {\n\n            while (1) {\n\n                if (size == 0) {\n\n                    res = AVERROR_EOF;\n\n                    break;\n\n                }\n\n                temp = *data;\n\n                lace_size[n] += temp;\n\n                data += 1;\n\n                size -= 1;\n\n                if (temp != 0xff)\n\n                    break;\n\n            }\n\n            total += lace_size[n];\n\n        }\n\n        if (size <= total) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n\n\n        lace_size[n] = size - total;\n\n        break;\n\n    }\n\n\n\n    case 0x2: /* fixed-size lacing */\n\n        if (size != (size / *laces) * size) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n        for (n = 0; n < *laces; n++)\n\n            lace_size[n] = size / *laces;\n\n        break;\n\n\n\n    case 0x3: /* EBML lacing */ {\n\n        uint64_t num;\n\n        uint32_t total;\n\n        n = matroska_ebmlnum_uint(matroska, data, size, &num);\n\n        if (n < 0) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"EBML block data error\\n\");\n\n            res = n;\n\n            break;\n\n        }\n\n        data += n;\n\n        size -= n;\n\n        total = lace_size[0] = num;\n\n        for (n = 1; res == 0 && n < *laces - 1; n++) {\n\n            int64_t snum;\n\n            int r;\n\n            r = matroska_ebmlnum_sint(matroska, data, size, &snum);\n\n            if (r < 0) {\n\n                av_log(matroska->ctx, AV_LOG_INFO,\n\n                       \"EBML block data error\\n\");\n\n                res = r;\n\n                break;\n\n            }\n\n            data += r;\n\n            size -= r;\n\n            lace_size[n] = lace_size[n - 1] + snum;\n\n            total += lace_size[n];\n\n        }\n\n        if (size <= total) {\n\n            res = AVERROR_INVALIDDATA;\n\n            break;\n\n        }\n\n        lace_size[*laces - 1] = size - total;\n\n        break;\n\n    }\n\n    }\n\n\n\n    *buf      = data;\n\n    *lace_buf = lace_size;\n\n\n\n    return res;\n\n}\n", "target": 1}
{"task_id": "defect/train/33", "input": "static int parse_picture_segment(AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    uint8_t sequence_desc;\n\n    unsigned int rle_bitmap_len, width, height;\n\n\n\n    if (buf_size <= 4)\n\n        return -1;\n\n    buf_size -= 4;\n\n\n\n    /* skip 3 unknown bytes: Object ID (2 bytes), Version Number */\n\n    buf += 3;\n\n\n\n    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > ctx->picture.rle_remaining_len)\n\n            return -1;\n\n\n\n        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n\n        ctx->picture.rle_data_len += buf_size;\n\n        ctx->picture.rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return -1;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions larger than video.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->picture.w = width;\n\n    ctx->picture.h = height;\n\n\n\n    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!ctx->picture.rle)\n\n        return -1;\n\n\n\n    memcpy(ctx->picture.rle, buf, buf_size);\n\n    ctx->picture.rle_data_len = buf_size;\n\n    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/34", "input": "void hmp_info_io_apic(Monitor *mon, const QDict *qdict)\n\n{\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_ioapic_dump_state(mon, qdict);\n\n    } else {\n\n        ioapic_dump_state(mon, qdict);\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/35", "input": "static av_cold int split_init(AVFilterContext *ctx)\n\n{\n\n    SplitContext *s = ctx->priv;\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_outputs; i++) {\n\n        char name[32];\n\n        AVFilterPad pad = { 0 };\n\n\n\n        snprintf(name, sizeof(name), \"output%d\", i);\n\n        pad.type = ctx->filter->inputs[0].type;\n\n        pad.name = av_strdup(name);\n\n        if (!pad.name)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ff_insert_outpad(ctx, i, &pad);\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/36", "input": "static void ide_set_signature(IDEState *s)\n\n{\n\n    s->select &= 0xf0; /* clear head */\n\n    /* put signature */\n\n    s->nsector = 1;\n\n    s->sector = 1;\n\n    if (s->drive_kind == IDE_CD) {\n\n        s->lcyl = 0x14;\n\n        s->hcyl = 0xeb;\n\n    } else if (s->bs) {\n\n        s->lcyl = 0;\n\n        s->hcyl = 0;\n\n    } else {\n\n        s->lcyl = 0xff;\n\n        s->hcyl = 0xff;\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/37", "input": "void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)\n\n{\n\n    MemoryRegion *mr = g_malloc(sizeof(*mr));\n\n\n\n    isa_mmio_setup(mr, size);\n\n    memory_region_add_subregion(get_system_memory(), base, mr);\n\n}\n", "target": 0}
{"task_id": "defect/train/38", "input": "static int find_allocation(BlockDriverState *bs, off_t start,\n\n                           off_t *data, off_t *hole)\n\n{\n\n    BDRVGlusterState *s = bs->opaque;\n\n    off_t offs;\n\n\n\n    if (!s->supports_seek_data) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    /*\n\n     * SEEK_DATA cases:\n\n     * D1. offs == start: start is in data\n\n     * D2. offs > start: start is in a hole, next data at offs\n\n     * D3. offs < 0, errno = ENXIO: either start is in a trailing hole\n\n     *                              or start is beyond EOF\n\n     *     If the latter happens, the file has been truncated behind\n\n     *     our back since we opened it.  All bets are off then.\n\n     *     Treating like a trailing hole is simplest.\n\n     * D4. offs < 0, errno != ENXIO: we learned nothing\n\n     */\n\n    offs = glfs_lseek(s->fd, start, SEEK_DATA);\n\n    if (offs < 0) {\n\n        return -errno;          /* D3 or D4 */\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        /* D2: in hole, next data at offs */\n\n        *hole = start;\n\n        *data = offs;\n\n        return 0;\n\n    }\n\n\n\n    /* D1: in data, end not yet known */\n\n\n\n    /*\n\n     * SEEK_HOLE cases:\n\n     * H1. offs == start: start is in a hole\n\n     *     If this happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H2. offs > start: either start is in data, next hole at offs,\n\n     *                   or start is in trailing hole, EOF at offs\n\n     *     Linux treats trailing holes like any other hole: offs ==\n\n     *     start.  Solaris seeks to EOF instead: offs > start (blech).\n\n     *     If that happens here, a hole has been dug behind our back\n\n     *     since the previous lseek().\n\n     * H3. offs < 0, errno = ENXIO: start is beyond EOF\n\n     *     If this happens, the file has been truncated behind our\n\n     *     back since we opened it.  Treat it like a trailing hole.\n\n     * H4. offs < 0, errno != ENXIO: we learned nothing\n\n     *     Pretend we know nothing at all, i.e. \"forget\" about D1.\n\n     */\n\n    offs = glfs_lseek(s->fd, start, SEEK_HOLE);\n\n    if (offs < 0) {\n\n        return -errno;          /* D1 and (H3 or H4) */\n\n    }\n\n    assert(offs >= start);\n\n\n\n    if (offs > start) {\n\n        /*\n\n         * D1 and H2: either in data, next hole at offs, or it was in\n\n         * data but is now in a trailing hole.  In the latter case,\n\n         * all bets are off.  Treating it as if it there was data all\n\n         * the way to EOF is safe, so simply do that.\n\n         */\n\n        *data = start;\n\n        *hole = offs;\n\n        return 0;\n\n    }\n\n\n\n    /* D1 and H1 */\n\n    return -EBUSY;\n\n}\n", "target": 0}
{"task_id": "defect/train/39", "input": "static void test_validate_struct_nested(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', \"\n\n                           \"'dict1': { 'string1': 'string1', \"\n\n                           \"'dict2': { 'userdef': { 'integer': 42, \"\n\n                           \"'string': 'string' }, 'string': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "target": 0}
{"task_id": "defect/train/40", "input": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n\n{\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n}\n", "target": 0}
{"task_id": "defect/train/41", "input": "static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)\n\n{\n\n    AVIOContext *in, *out;\n\n    int ret = 0;\n\n    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {\n\n        avio_close(in);\n\n        return ret;\n\n    }\n\n    while (size > 0) {\n\n        uint8_t buf[8192];\n\n        int n = FFMIN(size, sizeof(buf));\n\n        n = avio_read(in, buf, n);\n\n        if (n <= 0) {\n\n            ret = AVERROR(EIO);\n\n            break;\n\n        }\n\n        avio_write(out, buf, n);\n\n        size -= n;\n\n    }\n\n    avio_flush(out);\n\n    avio_close(out);\n\n    avio_close(in);\n\n    return ret;\n\n}\n", "target": 0}
{"task_id": "defect/train/42", "input": "static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,\n\n                                VMStateField *field)\n\n{\n\n    uint64_t *v = pv;\n\n    *v = qemu_get_be32(f);\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/43", "input": "void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n\n\n    if (!dc->hotpluggable) {\n\n        return;\n\n    }\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    if (dev->hotplugged) {\n\n        mdev->is_inserting = true;\n\n        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/44", "input": "uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,\n\n                       uint8_t lock)\n\n{\n\n    MapCacheEntry *entry, *pentry = NULL;\n\n    hwaddr address_index;\n\n    hwaddr address_offset;\n\n    hwaddr cache_size = size;\n\n    hwaddr test_bit_size;\n\n    bool translated = false;\n\n\n\ntryagain:\n\n    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;\n\n    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);\n\n\n\n    trace_xen_map_cache(phys_addr);\n\n\n\n    /* test_bit_size is always a multiple of XC_PAGE_SIZE */\n\n    if (size) {\n\n        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));\n\n\n\n        if (test_bit_size % XC_PAGE_SIZE) {\n\n            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);\n\n        }\n\n    } else {\n\n        test_bit_size = XC_PAGE_SIZE;\n\n    }\n\n\n\n    if (mapcache->last_entry != NULL &&\n\n        mapcache->last_entry->paddr_index == address_index &&\n\n        !lock && !size &&\n\n        test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                  test_bit_size >> XC_PAGE_SHIFT,\n\n                  mapcache->last_entry->valid_mapping)) {\n\n        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n        return mapcache->last_entry->vaddr_base + address_offset;\n\n    }\n\n\n\n    /* size is always a multiple of MCACHE_BUCKET_SIZE */\n\n    if (size) {\n\n        cache_size = size + address_offset;\n\n        if (cache_size % MCACHE_BUCKET_SIZE) {\n\n            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);\n\n        }\n\n    } else {\n\n        cache_size = MCACHE_BUCKET_SIZE;\n\n    }\n\n\n\n    entry = &mapcache->entry[address_index % mapcache->nr_buckets];\n\n\n\n    while (entry && entry->lock && entry->vaddr_base &&\n\n            (entry->paddr_index != address_index || entry->size != cache_size ||\n\n             !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                 test_bit_size >> XC_PAGE_SHIFT,\n\n                 entry->valid_mapping))) {\n\n        pentry = entry;\n\n        entry = entry->next;\n\n    }\n\n    if (!entry) {\n\n        entry = g_malloc0(sizeof (MapCacheEntry));\n\n        pentry->next = entry;\n\n        xen_remap_bucket(entry, cache_size, address_index);\n\n    } else if (!entry->lock) {\n\n        if (!entry->vaddr_base || entry->paddr_index != address_index ||\n\n                entry->size != cache_size ||\n\n                !test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                    test_bit_size >> XC_PAGE_SHIFT,\n\n                    entry->valid_mapping)) {\n\n            xen_remap_bucket(entry, cache_size, address_index);\n\n        }\n\n    }\n\n\n\n    if(!test_bits(address_offset >> XC_PAGE_SHIFT,\n\n                test_bit_size >> XC_PAGE_SHIFT,\n\n                entry->valid_mapping)) {\n\n        mapcache->last_entry = NULL;\n\n        if (!translated && mapcache->phys_offset_to_gaddr) {\n\n            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);\n\n            translated = true;\n\n            goto tryagain;\n\n        }\n\n        trace_xen_map_cache_return(NULL);\n\n        return NULL;\n\n    }\n\n\n\n    mapcache->last_entry = entry;\n\n    if (lock) {\n\n        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));\n\n        entry->lock++;\n\n        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;\n\n        reventry->paddr_index = mapcache->last_entry->paddr_index;\n\n        reventry->size = entry->size;\n\n        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);\n\n    }\n\n\n\n    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);\n\n    return mapcache->last_entry->vaddr_base + address_offset;\n\n}\n", "target": 0}
{"task_id": "defect/train/45", "input": "static void usb_hid_changed(HIDState *hs)\n\n{\n\n    USBHIDState *us = container_of(hs, USBHIDState, hid);\n\n\n\n    us->changed = 1;\n\n\n\n    if (us->datain) {\n\n        us->datain(us->datain_opaque);\n\n    }\n\n\n\n    usb_wakeup(&us->dev);\n\n}\n", "target": 0}
{"task_id": "defect/train/46", "input": "static int nbd_errno_to_system_errno(int err)\n\n{\n\n    switch (err) {\n\n    case NBD_SUCCESS:\n\n        return 0;\n\n    case NBD_EPERM:\n\n        return EPERM;\n\n    case NBD_EIO:\n\n        return EIO;\n\n    case NBD_ENOMEM:\n\n        return ENOMEM;\n\n    case NBD_ENOSPC:\n\n        return ENOSPC;\n\n    default:\n\n        TRACE(\"Squashing unexpected error %d to EINVAL\", err);\n\n        /* fallthrough */\n\n    case NBD_EINVAL:\n\n        return EINVAL;\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/47", "input": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, uint16_t **refcount_table,\n\n                               int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    *refcount_table = g_try_new0(uint16_t, *nb_clusters);\n\n    if (*nb_clusters && *refcount_table == NULL) {\n\n        res->check_errors++;\n\n        return -ENOMEM;\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);\n\n}\n", "target": 0}
{"task_id": "defect/train/48", "input": "void aio_context_setup(AioContext *ctx)\n\n{\n\n}\n", "target": 0}
{"task_id": "defect/train/49", "input": "static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    LM32TimerState *s = opaque;\n\n    uint32_t r = 0;\n\n\n\n    addr >>= 2;\n\n    switch (addr) {\n\n    case R_SR:\n\n    case R_CR:\n\n    case R_PERIOD:\n\n        r = s->regs[addr];\n\n        break;\n\n    case R_SNAPSHOT:\n\n        r = (uint32_t)ptimer_get_count(s->ptimer);\n\n        break;\n\n    default:\n\n        error_report(\"lm32_timer: read access to unknown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n\n\n    trace_lm32_timer_memory_read(addr << 2, r);\n\n    return r;\n\n}\n", "target": 0}
{"task_id": "defect/train/50", "input": "void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    SCSIRequest *sreq = req->sreq;\n\n    if (scsi_req_enqueue(sreq)) {\n\n        scsi_req_continue(sreq);\n\n    }\n\n    bdrv_io_unplug(sreq->dev->conf.bs);\n\n    scsi_req_unref(sreq);\n\n}\n", "target": 0}
{"task_id": "defect/train/51", "input": "static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i, j;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n    int iterations;\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    if (buf_size < 32) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Too small input buffer (%d bytes), need at least 32 bytes\\n\", buf_size);\n\n        return -1;\n\n    }\n\n    iterations = FFMIN(buf_size / 32, *data_size / 480);\n\n    for(j = 0; j < iterations; j++) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        /* finally output decoded frame */\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return consumed;\n\n}\n", "target": 0}
{"task_id": "defect/train/52", "input": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (blit_is_unsafe(s, false))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "target": 0}
{"task_id": "defect/train/53", "input": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 int flags, Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (offset > end_offset || ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n            s->image_backing_format = g_strdup(bs->backing_format);\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_CRYPTO_HEADER: {\n\n            unsigned int cflags = 0;\n\n            if (s->crypt_method_header != QCOW_CRYPT_LUKS) {\n\n                error_setg(errp, \"CRYPTO header extension only \"\n\n                           \"expected with LUKS encryption method\");\n\n                return -EINVAL;\n\n            }\n\n            if (ext.len != sizeof(Qcow2CryptoHeaderExtension)) {\n\n                error_setg(errp, \"CRYPTO header extension size %u, \"\n\n                           \"but expected size %zu\", ext.len,\n\n                           sizeof(Qcow2CryptoHeaderExtension));\n\n                return -EINVAL;\n\n            }\n\n\n\n            ret = bdrv_pread(bs->file, offset, &s->crypto_header, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret,\n\n                                 \"Unable to read CRYPTO header extension\");\n\n                return ret;\n\n            }\n\n            be64_to_cpus(&s->crypto_header.offset);\n\n            be64_to_cpus(&s->crypto_header.length);\n\n\n\n            if ((s->crypto_header.offset % s->cluster_size) != 0) {\n\n                error_setg(errp, \"Encryption header offset '%\" PRIu64 \"' is \"\n\n                           \"not a multiple of cluster size '%u'\",\n\n                           s->crypto_header.offset, s->cluster_size);\n\n                return -EINVAL;\n\n            }\n\n\n\n            if (flags & BDRV_O_NO_IO) {\n\n                cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;\n\n            }\n\n            s->crypto = qcrypto_block_open(s->crypto_opts, \"encrypt.\",\n\n                                           qcow2_crypto_hdr_read_func,\n\n                                           bs, cflags, errp);\n\n            if (!s->crypto) {\n\n                return -EINVAL;\n\n            }\n\n        }   break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/54", "input": "static void listener_add_address_space(MemoryListener *listener,\n\n                                       AddressSpace *as)\n\n{\n\n    FlatView *view;\n\n    FlatRange *fr;\n\n\n\n    if (listener->address_space_filter\n\n        && listener->address_space_filter != as) {\n\n        return;\n\n    }\n\n\n\n    if (global_dirty_log) {\n\n        if (listener->log_global_start) {\n\n            listener->log_global_start(listener);\n\n        }\n\n    }\n\n\n\n    view = as->current_map;\n\n    FOR_EACH_FLAT_RANGE(fr, view) {\n\n        MemoryRegionSection section = {\n\n            .mr = fr->mr,\n\n            .address_space = as,\n\n            .offset_within_region = fr->offset_in_region,\n\n            .size = fr->addr.size,\n\n            .offset_within_address_space = int128_get64(fr->addr.start),\n\n            .readonly = fr->readonly,\n\n        };\n\n        if (listener->region_add) {\n\n            listener->region_add(listener, &section);\n\n        }\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/55", "input": "long do_sigreturn(CPUM68KState *env)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr = env->aregs[7] - 4;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int d0, i;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* set blocked signals */\n\n\n\n    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))\n\n        goto badframe;\n\n\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    /* restore registers */\n\n\n\n    if (restore_sigcontext(env, &frame->sc, &d0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return d0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/56", "input": "static int tcg_match_cmpi(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        /* The COMPARE IMMEDIATE instruction is available.  */\n\n        if (type == TCG_TYPE_I32) {\n\n            /* We have a 32-bit immediate and can compare against anything.  */\n\n            return 1;\n\n        } else {\n\n            /* ??? We have no insight here into whether the comparison is\n\n               signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit\n\n               signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses\n\n               a 32-bit unsigned immediate.  If we were to use the (semi)\n\n               obvious \"val == (int32_t)val\" we would be enabling unsigned\n\n               comparisons vs very large numbers.  The only solution is to\n\n               take the intersection of the ranges.  */\n\n            /* ??? Another possible solution is to simply lie and allow all\n\n               constants here and force the out-of-range values into a temp\n\n               register in tgen_cmp when we have knowledge of the actual\n\n               comparison code in use.  */\n\n            return val >= 0 && val <= 0x7fffffff;\n\n        }\n\n    } else {\n\n        /* Only the LOAD AND TEST instruction is available.  */\n\n        return val == 0;\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/57", "input": "static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)\n\n{\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        return false;\n\n    }\n\n#ifdef TARGET_IS_BIENDIAN\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    return !virtio_is_big_endian(vdev);\n\n#else\n\n    return virtio_is_big_endian(vdev);\n\n#endif\n\n#else\n\n    return false;\n\n#endif\n\n}\n", "target": 0}
{"task_id": "defect/train/58", "input": "int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n\n{\n\n    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    QXLCursor *cursor;\n\n    QEMUCursor *c;\n\n\n\n    if (!cmd) {\n\n        return 1;\n\n    }\n\n\n\n    if (!dpy_cursor_define_supported(qxl->vga.con)) {\n\n        return 0;\n\n    }\n\n\n\n    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n\n        fprintf(stderr, \"%s\", __FUNCTION__);\n\n        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n\n        fprintf(stderr, \"\\n\");\n\n    }\n\n    switch (cmd->type) {\n\n    case QXL_CURSOR_SET:\n\n        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n\n        if (!cursor) {\n\n            return 1;\n\n        }\n\n        c = qxl_cursor(qxl, cursor, ext->group_id);\n\n        if (c == NULL) {\n\n            c = cursor_builtin_left_ptr();\n\n        }\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        if (qxl->ssd.cursor) {\n\n            cursor_put(qxl->ssd.cursor);\n\n        }\n\n        qxl->ssd.cursor = c;\n\n        qxl->ssd.mouse_x = cmd->u.set.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.set.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    case QXL_CURSOR_MOVE:\n\n        qemu_mutex_lock(&qxl->ssd.lock);\n\n        qxl->ssd.mouse_x = cmd->u.position.x;\n\n        qxl->ssd.mouse_y = cmd->u.position.y;\n\n        qemu_mutex_unlock(&qxl->ssd.lock);\n\n        qemu_bh_schedule(qxl->ssd.cursor_bh);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/59", "input": "static int decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y, *src[4];\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkx, cblky, cblkno=0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        int i, j;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        /* Manage band offsets */\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        ff_dwt_decode(&comp->dwt, comp->data);\n\n        src[compno] = comp->data;\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * s->ncomponents + compno;\n\n\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s->cdx[compno]) {\n\n                    int val = *src[compno]++ << (8 - s->cbps[compno]);\n\n                    val += 1 << 7;\n\n                    val = av_clip(val, 0, (1 << 8) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            y = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = s->picture->data[0] + y * s->picture->linesize[0];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = (uint16_t *)(line + (x * s->ncomponents + compno) * 2);\n\n                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s-> cdx[compno]) {\n\n                    int32_t val;\n\n\n\n                    val = *src[compno]++ << (16 - s->cbps[compno]);\n\n                    val += 1 << 15;\n\n                    val = av_clip(val, 0, (1 << 16) - 1);\n\n                    *dst = val;\n\n                    dst += s->ncomponents;\n\n                }\n\n                line += s->picture->linesize[0];\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/60", "input": "static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwl.base = base;\n\n    omap_pwl_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,\n\n                    omap_pwl_writefn, s);\n\n    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);\n\n\n\n    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);\n\n}\n", "target": 0}
{"task_id": "defect/train/61", "input": "static void virt_acpi_build_update(void *build_opaque)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = true;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    virt_acpi_build(build_state->guest_info, &tables);\n\n\n\n    acpi_ram_update(build_state->table_mr, tables.table_data);\n\n    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);\n\n    acpi_ram_update(build_state->linker_mr, tables.linker);\n\n\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "target": 0}
{"task_id": "defect/train/62", "input": "static void uart_rx_reset(UartState *s)\n\n{\n\n    s->rx_wpos = 0;\n\n    s->rx_count = 0;\n\n    qemu_chr_accept_input(s->chr);\n\n\n\n    s->r[R_SR] |= UART_SR_INTR_REMPTY;\n\n    s->r[R_SR] &= ~UART_SR_INTR_RFUL;\n\n}\n", "target": 0}
{"task_id": "defect/train/63", "input": "static int rndis_set_response(USBNetState *s,\n\n                rndis_set_msg_type *buf, unsigned int length)\n\n{\n\n    rndis_set_cmplt_type *resp =\n\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n\n    uint32_t bufoffs, buflen;\n\n    int ret;\n\n\n\n    if (!resp)\n\n        return USB_RET_STALL;\n\n\n\n    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n\n    buflen = le32_to_cpu(buf->InformationBufferLength);\n\n    if (bufoffs + buflen > length)\n\n        return USB_RET_STALL;\n\n\n\n    ret = ndis_set(s, le32_to_cpu(buf->OID),\n\n                    bufoffs + (uint8_t *) buf, buflen);\n\n    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);\n\n    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n\n    if (ret < 0) {\n\n        /* OID not supported */\n\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\n        return 0;\n\n    }\n\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/64", "input": "SwsContext *sws_alloc_context(void)\n\n{\n\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n\n\n    c->av_class = &sws_context_class;\n\n    av_opt_set_defaults(c);\n\n\n\n    return c;\n\n}\n", "target": 1}
{"task_id": "defect/train/65", "input": "static i2c_interface *musicpal_audio_init(qemu_irq irq)\n\n{\n\n    AudioState *audio;\n\n    musicpal_audio_state *s;\n\n    i2c_interface *i2c;\n\n    int iomemtype;\n\n\n\n    audio = AUD_init();\n\n    if (!audio) {\n\n        AUD_log(audio_name, \"No audio state\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(musicpal_audio_state));\n\n    s->irq = irq;\n\n\n\n    i2c = qemu_mallocz(sizeof(i2c_interface));\n\n    i2c->bus = i2c_init_bus();\n\n    i2c->current_addr = -1;\n\n\n\n    s->wm = wm8750_init(i2c->bus, audio);\n\n    if (!s->wm)\n\n        return NULL;\n\n    i2c_set_slave_address(s->wm, MP_WM_ADDR);\n\n    wm8750_data_req_set(s->wm, audio_callback, s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, musicpal_audio_readfn,\n\n                       musicpal_audio_writefn, s);\n\n    cpu_register_physical_memory(MP_AUDIO_BASE, MP_AUDIO_SIZE, iomemtype);\n\n\n\n    qemu_register_reset(musicpal_audio_reset, s);\n\n\n\n    return i2c;\n\n}\n", "target": 1}
{"task_id": "defect/train/66", "input": "void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,\n\n                       bool is_read, int error)\n\n{\n\n    assert(error >= 0);\n\n    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);\n\n    if (action == BDRV_ACTION_STOP) {\n\n        vm_stop(RUN_STATE_IO_ERROR);\n\n        bdrv_iostatus_set_err(bs, error);\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/67", "input": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,\n\n                     uint64_t max_mem)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    if ((uint64_t)RAM_size > max_mem) {\n\n        fprintf(stderr,\n\n                \"qemu: Too much memory for this machine: %d, maximum %d\\n\",\n\n                (unsigned int)(RAM_size / (1024 * 1024)),\n\n                (unsigned int)(max_mem / (1024 * 1024)));\n\n        exit(1);\n\n    }\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "target": 1}
{"task_id": "defect/train/68", "input": "int xics_alloc_block(XICSState *icp, int src, int num, bool lsi, bool align)\n\n{\n\n    int i, first = -1;\n\n    ICSState *ics = &icp->ics[src];\n\n\n\n    assert(src == 0);\n\n    /*\n\n     * MSIMesage::data is used for storing VIRQ so\n\n     * it has to be aligned to num to support multiple\n\n     * MSI vectors. MSI-X is not affected by this.\n\n     * The hint is used for the first IRQ, the rest should\n\n     * be allocated continuously.\n\n     */\n\n    if (align) {\n\n        assert((num == 1) || (num == 2) || (num == 4) ||\n\n               (num == 8) || (num == 16) || (num == 32));\n\n        first = ics_find_free_block(ics, num, num);\n\n    } else {\n\n        first = ics_find_free_block(ics, num, 1);\n\n    }\n\n\n\n    if (first >= 0) {\n\n        for (i = first; i < first + num; ++i) {\n\n            ics_set_irq_type(ics, i, lsi);\n\n        }\n\n    }\n\n    first += ics->offset;\n\n\n\n    trace_xics_alloc_block(src, first, num, lsi, align);\n\n\n\n    return first;\n\n}\n", "target": 1}
{"task_id": "defect/train/69", "input": "void object_property_get_uint16List(Object *obj, const char *name,\n\n                                    uint16List **list, Error **errp)\n\n{\n\n    StringOutputVisitor *ov;\n\n    StringInputVisitor *iv;\n\n\n\n    ov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(ov),\n\n                        name, errp);\n\n    iv = string_input_visitor_new(string_output_get_string(ov));\n\n    visit_type_uint16List(string_input_get_visitor(iv),\n\n                          list, NULL, errp);\n\n    string_output_visitor_cleanup(ov);\n\n    string_input_visitor_cleanup(iv);\n\n}\n", "target": 1}
{"task_id": "defect/train/70", "input": "static int raw_create(const char *filename, QEMUOptionParameter *options)\n\n{\n\n    int fd;\n\n    int64_t total_size = 0;\n\n\n\n    /* Read out options */\n\n    while (options && options->name) {\n\n        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n\n            total_size = options->value.n / 512;\n\n        }\n\n        options++;\n\n    }\n\n\n\n    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\n              0644);\n\n    if (fd < 0)\n\n        return -EIO;\n\n    ftruncate(fd, total_size * 512);\n\n    close(fd);\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/71", "input": "static inline void RENAME(rgb24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    assert(src1==src2);\n\n    for (i=0; i<width; i++) {\n\n        int r= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int b= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/72", "input": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    QLIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "target": 1}
{"task_id": "defect/train/73", "input": "void ff_xvmc_init_block(MpegEncContext *s)\n\n{\n\n    struct xvmc_render_state *render = (struct xvmc_render_state*)s->current_picture.data[2];\n\n    assert(render);\n\n    if (!render || render->magic != AV_XVMC_RENDER_MAGIC) {\n\n        assert(0);\n\n        return; // make sure that this is a render packet\n\n    }\n\n    s->block = (DCTELEM *)(render->data_blocks + render->next_free_data_block_num * 64);\n\n}\n", "target": 1}
{"task_id": "defect/train/74", "input": "void do_adde (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1 + xer_ca;\n\n    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/75", "input": "static uint32_t ecc_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    ECCState *s = opaque;\n\n    uint32_t ret = 0;\n\n\n\n    switch (addr & ECC_ADDR_MASK) {\n\n    case ECC_MER:\n\n        ret = s->regs[0];\n\n        DPRINTF(\"Read memory enable %08x\\n\", ret);\n\n        break;\n\n    case ECC_MDR:\n\n        ret = s->regs[1];\n\n        DPRINTF(\"Read memory delay %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFSR:\n\n        ret = s->regs[2];\n\n        DPRINTF(\"Read memory fault status %08x\\n\", ret);\n\n        break;\n\n    case ECC_VCR:\n\n        ret = s->regs[3];\n\n        DPRINTF(\"Read slot configuration %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR0:\n\n        ret = s->regs[4];\n\n        DPRINTF(\"Read memory fault address 0 %08x\\n\", ret);\n\n        break;\n\n    case ECC_MFAR1:\n\n        ret = s->regs[5];\n\n        DPRINTF(\"Read memory fault address 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_DR:\n\n        ret = s->regs[6];\n\n        DPRINTF(\"Read diagnostic %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR0:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 1 %08x\\n\", ret);\n\n        break;\n\n    case ECC_ECR1:\n\n        ret = s->regs[7];\n\n        DPRINTF(\"Read event count 2 %08x\\n\", ret);\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "target": 1}
{"task_id": "defect/train/76", "input": "int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,\n                             int *got_sub_ptr,\n                             AVPacket *avpkt)\n{\n    int i, ret = 0;\n    if (!avpkt->data && avpkt->size) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid packet: NULL data, size != 0\\n\");\n        return AVERROR(EINVAL);\n    if (!avctx->codec)\n        return AVERROR(EINVAL);\n    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid media type for subtitles\\n\");\n        return AVERROR(EINVAL);\n    *got_sub_ptr = 0;\n    avcodec_get_subtitle_defaults(sub);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size) {\n        AVPacket pkt_recoded;\n        AVPacket tmp = *avpkt;\n        int did_split = av_packet_split_side_data(&tmp);\n        //apply_param_change(avctx, &tmp);\n        pkt_recoded = tmp;\n        ret = recode_subtitle(avctx, &pkt_recoded, &tmp);\n        if (ret < 0) {\n            *got_sub_ptr = 0;\n        } else {\n            avctx->internal->pkt = &pkt_recoded;\n            if (avctx->pkt_timebase.den && avpkt->pts != AV_NOPTS_VALUE)\n                sub->pts = av_rescale_q(avpkt->pts,\n                                        avctx->pkt_timebase, AV_TIME_BASE_Q);\n            ret = avctx->codec->decode(avctx, sub, got_sub_ptr, &pkt_recoded);\n            av_assert1((ret >= 0) >= !!*got_sub_ptr &&\n                       !!*got_sub_ptr >= !!sub->num_rects);\n            if (sub->num_rects && !sub->end_display_time && avpkt->duration &&\n                avctx->pkt_timebase.num) {\n                AVRational ms = { 1, 1000 };\n                sub->end_display_time = av_rescale_q(avpkt->duration,\n                                                     avctx->pkt_timebase, ms);\n            for (i = 0; i < sub->num_rects; i++) {\n                if (sub->rects[i]->ass && !utf8_check(sub->rects[i]->ass)) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Invalid UTF-8 in decoded subtitles text; \"\n                           \"maybe missing -sub_charenc option\\n\");\n                    avsubtitle_free(sub);\n                    return AVERROR_INVALIDDATA;\n            if (tmp.data != pkt_recoded.data) { // did we recode?\n                /* prevent from destroying side data from original packet */\n                pkt_recoded.side_data = NULL;\n                pkt_recoded.side_data_elems = 0;\n                av_free_packet(&pkt_recoded);\n            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB)\n                sub->format = 0;\n            else if (avctx->codec_descriptor->props & AV_CODEC_PROP_TEXT_SUB)\n                sub->format = 1;\n            avctx->internal->pkt = NULL;\n            av_packet_free_side_data(&tmp);\n            if(ret == tmp.size)\n                ret = avpkt->size;\n        if (*got_sub_ptr)\n            avctx->frame_number++;\n    return ret;", "target": 1}
{"task_id": "defect/train/77", "input": "static int mp_decode_frame(MPADecodeContext *s, \n\n                           short *samples)\n\n{\n\n    int i, nb_frames, ch;\n\n    short *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, \n\n                  s->inbuf_ptr - s->inbuf - HEADER_SIZE);\n\n    \n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        get_bits(&s->gb, 16);\n\n\n\n    dprintf(\"frame %d:\\n\", s->frame_count);\n\n    switch(s->layer) {\n\n    case 1:\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n        break;\n\n    }\n\n#if defined(DEBUG)\n\n    for(i=0;i<nb_frames;i++) {\n\n        for(ch=0;ch<s->nb_channels;ch++) {\n\n            int j;\n\n            printf(\"%d-%d:\", i, ch);\n\n            for(j=0;j<SBLIMIT;j++)\n\n                printf(\" %0.6f\", (double)s->sb_samples[ch][i][j] / FRAC_ONE);\n\n            printf(\"\\n\");\n\n        }\n\n    }\n\n#endif\n\n    /* apply the synthesis filter */\n\n    for(ch=0;ch<s->nb_channels;ch++) {\n\n        samples_ptr = samples + ch;\n\n        for(i=0;i<nb_frames;i++) {\n\n            synth_filter(s, ch, samples_ptr, s->nb_channels,\n\n                         s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * s->nb_channels;\n\n        }\n\n    }\n\n#ifdef DEBUG\n\n    s->frame_count++;        \n\n#endif\n\n    return nb_frames * 32 * sizeof(short) * s->nb_channels;\n\n}\n", "target": 0}
{"task_id": "defect/train/78", "input": "static int pcm_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            const uint8_t *buf, int buf_size)\n\n{\n\n    PCMDecode *s = avctx->priv_data;\n\n    int sample_size, c, n;\n\n    short *samples;\n\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n\n    uint8_t *dstu8;\n\n    int16_t *dst_int16_t;\n\n    int32_t *dst_int32_t;\n\n    int64_t *dst_int64_t;\n\n    uint16_t *dst_uint16_t;\n\n    uint32_t *dst_uint32_t;\n\n\n\n    samples = data;\n\n    src = buf;\n\n\n\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n\n        return -1;\n\n    }\n\n\n\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n\n\n\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n\n        /* 2 samples are interleaved per block in PCM_DVD */\n\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n\n\n\n    n = avctx->channels * sample_size;\n\n\n\n    if(n && buf_size % n){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n\n        return -1;\n\n    }\n\n\n\n    buf_size= FFMIN(buf_size, *data_size/2);\n\n    *data_size=0;\n\n\n\n    n = buf_size/sample_size;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_PCM_U32LE:\n\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_U32BE:\n\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n\n        break;\n\n    case CODEC_ID_PCM_S24LE:\n\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S24BE:\n\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n\n        break;\n\n    case CODEC_ID_PCM_U24LE:\n\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_U24BE:\n\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n\n        break;\n\n    case CODEC_ID_PCM_S24DAUD:\n\n        for(;n>0;n--) {\n\n          uint32_t v = bytestream_get_be24(&src);\n\n          v >>= 4; // sync flags are here\n\n          *samples++ = ff_reverse[(v >> 8) & 0xff] +\n\n                       (ff_reverse[v & 0xff] << 8);\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S16LE_PLANAR:\n\n        n /= avctx->channels;\n\n        for(c=0;c<avctx->channels;c++)\n\n            src2[c] = &src[c*n*2];\n\n        for(;n>0;n--)\n\n            for(c=0;c<avctx->channels;c++)\n\n                *samples++ = bytestream_get_le16(&src2[c]);\n\n        src = src2[avctx->channels-1];\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        dstu8= (uint8_t*)samples;\n\n        for(;n>0;n--) {\n\n            *dstu8++ = *src++ + 128;\n\n        }\n\n        samples= (short*)dstu8;\n\n        break;\n\n#if WORDS_BIGENDIAN\n\n    case CODEC_ID_PCM_F64LE:\n\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16LE:\n\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64BE:\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n    case CODEC_ID_PCM_S16BE:\n\n#else\n\n    case CODEC_ID_PCM_F64BE:\n\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F32BE:\n\n    case CODEC_ID_PCM_S32BE:\n\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_S16BE:\n\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n\n        break;\n\n    case CODEC_ID_PCM_F64LE:\n\n    case CODEC_ID_PCM_F32LE:\n\n    case CODEC_ID_PCM_S32LE:\n\n    case CODEC_ID_PCM_S16LE:\n\n#endif /* WORDS_BIGENDIAN */\n\n    case CODEC_ID_PCM_U8:\n\n        memcpy(samples, src, n*sample_size);\n\n        src += n*sample_size;\n\n        samples = (short*)((uint8_t*)data + n*sample_size);\n\n        break;\n\n    case CODEC_ID_PCM_ZORK:\n\n        for(;n>0;n--) {\n\n            int x= *src++;\n\n            if(x&128) x-= 128;\n\n            else      x = -x;\n\n            *samples++ = x << 8;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            *samples++ = s->table[*src++];\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_DVD:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        switch (avctx->bits_per_coded_sample) {\n\n        case 20:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        case 24:\n\n            while (n--) {\n\n                c = avctx->channels;\n\n                src8 = src + 4*c;\n\n                while (c--) {\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n            break;\n\n        }\n\n        samples = (short *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n", "target": 0}
{"task_id": "defect/train/79", "input": "static int write_trailer(AVFormatContext *s)\n\n{\n\n    WVMuxContext *wc = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    ff_ape_write(s);\n\n\n\n    if (pb->seekable) {\n\n        avio_seek(pb, 12, SEEK_SET);\n\n        avio_wl32(pb, wc->duration);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/80", "input": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    /* virtio-1 compliant devices cannot change the alignment */\n\n    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    /* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     */\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n", "target": 0}
{"task_id": "defect/train/81", "input": "static inline void RENAME(yuvPlanartouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                           long width, long height,\n\n                                           long lumStride, long chromStride, long dstStride, long vertLumPerChroma)\n\n{\n\n    long y;\n\n    const x86_reg chromWidth= width>>1;\n\n    for (y=0; y<height; y++) {\n\n#if COMPILE_TEMPLATE_MMX\n\n        //FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)\n\n        __asm__ volatile(\n\n            \"xor                %%\"REG_a\", %%\"REG_a\"    \\n\\t\"\n\n            \".p2align                   4               \\n\\t\"\n\n            \"1:                                         \\n\\t\"\n\n            PREFETCH\"   32(%1, %%\"REG_a\", 2)            \\n\\t\"\n\n            PREFETCH\"   32(%2, %%\"REG_a\")               \\n\\t\"\n\n            PREFETCH\"   32(%3, %%\"REG_a\")               \\n\\t\"\n\n            \"movq         (%2, %%\"REG_a\"), %%mm0        \\n\\t\" // U(0)\n\n            \"movq                   %%mm0, %%mm2        \\n\\t\" // U(0)\n\n            \"movq         (%3, %%\"REG_a\"), %%mm1        \\n\\t\" // V(0)\n\n            \"punpcklbw              %%mm1, %%mm0        \\n\\t\" // UVUV UVUV(0)\n\n            \"punpckhbw              %%mm1, %%mm2        \\n\\t\" // UVUV UVUV(8)\n\n\n\n            \"movq       (%1, %%\"REG_a\",2), %%mm3        \\n\\t\" // Y(0)\n\n            \"movq      8(%1, %%\"REG_a\",2), %%mm5        \\n\\t\" // Y(8)\n\n            \"movq                   %%mm0, %%mm4        \\n\\t\" // Y(0)\n\n            \"movq                   %%mm2, %%mm6        \\n\\t\" // Y(8)\n\n            \"punpcklbw              %%mm3, %%mm0        \\n\\t\" // YUYV YUYV(0)\n\n            \"punpckhbw              %%mm3, %%mm4        \\n\\t\" // YUYV YUYV(4)\n\n            \"punpcklbw              %%mm5, %%mm2        \\n\\t\" // YUYV YUYV(8)\n\n            \"punpckhbw              %%mm5, %%mm6        \\n\\t\" // YUYV YUYV(12)\n\n\n\n            MOVNTQ\"                 %%mm0,   (%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm4,  8(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm2, 16(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n            MOVNTQ\"                 %%mm6, 24(%0, %%\"REG_a\", 4)     \\n\\t\"\n\n\n\n            \"add                       $8, %%\"REG_a\"    \\n\\t\"\n\n            \"cmp                       %4, %%\"REG_a\"    \\n\\t\"\n\n            \" jb                       1b               \\n\\t\"\n\n            ::\"r\"(dst), \"r\"(ysrc), \"r\"(usrc), \"r\"(vsrc), \"g\" (chromWidth)\n\n            : \"%\"REG_a\n\n        );\n\n#else\n\n//FIXME adapt the Alpha ASM code from yv12->yuy2\n\n\n\n#if HAVE_FAST_64BIT\n\n        int i;\n\n        uint64_t *ldst = (uint64_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i += 2) {\n\n            uint64_t k, l;\n\n            k = uc[0] + (yc[0] << 8) +\n\n                (vc[0] << 16) + (yc[1] << 24);\n\n            l = uc[1] + (yc[2] << 8) +\n\n                (vc[1] << 16) + (yc[3] << 24);\n\n            *ldst++ = k + (l << 32);\n\n            yc += 4;\n\n            uc += 2;\n\n            vc += 2;\n\n        }\n\n\n\n#else\n\n        int i, *idst = (int32_t *) dst;\n\n        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;\n\n        for (i = 0; i < chromWidth; i++) {\n\n#if HAVE_BIGENDIAN\n\n            *idst++ = (uc[0] << 24)+ (yc[0] << 16) +\n\n                (vc[0] << 8) + (yc[1] << 0);\n\n#else\n\n            *idst++ = uc[0] + (yc[0] << 8) +\n\n               (vc[0] << 16) + (yc[1] << 24);\n\n#endif\n\n            yc += 2;\n\n            uc++;\n\n            vc++;\n\n        }\n\n#endif\n\n#endif\n\n        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {\n\n            usrc += chromStride;\n\n            vsrc += chromStride;\n\n        }\n\n        ysrc += lumStride;\n\n        dst += dstStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            :::\"memory\");\n\n#endif\n\n}\n", "target": 0}
{"task_id": "defect/train/82", "input": "int qcrypto_init(Error **errp)\n\n{\n\n    int ret;\n\n    ret = gnutls_global_init();\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Unable to initialize GNUTLS library: %s\",\n\n                   gnutls_strerror(ret));\n\n        return -1;\n\n    }\n\n#ifdef DEBUG_GNUTLS\n\n    gnutls_global_set_log_level(10);\n\n    gnutls_global_set_log_function(qcrypto_gnutls_log);\n\n#endif\n\n\n\n#ifdef CONFIG_GNUTLS_GCRYPT\n\n    if (!gcry_check_version(GCRYPT_VERSION)) {\n\n        error_setg(errp, \"Unable to initialize gcrypt\");\n\n        return -1;\n\n    }\n\n#ifdef QCRYPTO_INIT_GCRYPT_THREADS\n\n    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);\n\n#endif /* QCRYPTO_INIT_GCRYPT_THREADS */\n\n    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "target": 0}
{"task_id": "defect/train/83", "input": "static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,\n\n                                 int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_8|MO_SIGN:\n\n        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_16|MO_SIGN:\n\n        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n    case MO_32|MO_SIGN:\n\n        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n", "target": 0}
{"task_id": "defect/train/84", "input": "static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,\n\n                            hwaddr desc_pa, int i)\n\n{\n\n    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),\n\n                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));\n\n    virtio_tswap64s(vdev, &desc->addr);\n\n    virtio_tswap32s(vdev, &desc->len);\n\n    virtio_tswap16s(vdev, &desc->flags);\n\n    virtio_tswap16s(vdev, &desc->next);\n\n}\n", "target": 0}
{"task_id": "defect/train/85", "input": "static AddressSpace *q35_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    IntelIOMMUState *s = opaque;\n\n    VTDAddressSpace **pvtd_as;\n\n    int bus_num = pci_bus_num(bus);\n\n\n\n    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);\n\n    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);\n\n\n\n    pvtd_as = s->address_spaces[bus_num];\n\n    if (!pvtd_as) {\n\n        /* No corresponding free() */\n\n        pvtd_as = g_malloc0(sizeof(VTDAddressSpace *) * VTD_PCI_DEVFN_MAX);\n\n        s->address_spaces[bus_num] = pvtd_as;\n\n    }\n\n    if (!pvtd_as[devfn]) {\n\n        pvtd_as[devfn] = g_malloc0(sizeof(VTDAddressSpace));\n\n\n\n        pvtd_as[devfn]->bus_num = (uint8_t)bus_num;\n\n        pvtd_as[devfn]->devfn = (uint8_t)devfn;\n\n        pvtd_as[devfn]->iommu_state = s;\n\n        pvtd_as[devfn]->context_cache_entry.context_cache_gen = 0;\n\n        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s),\n\n                                 &s->iommu_ops, \"intel_iommu\", UINT64_MAX);\n\n        address_space_init(&pvtd_as[devfn]->as,\n\n                           &pvtd_as[devfn]->iommu, \"intel_iommu\");\n\n    }\n\n    return &pvtd_as[devfn]->as;\n\n}\n", "target": 0}
{"task_id": "defect/train/86", "input": "static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,\n\n                                                   int64_t offset)\n\n{\n\n    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;\n\n    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    extent_begin_offset =\n\n        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;\n\n    extent_relative_offset = offset - extent_begin_offset;\n\n    offset_in_cluster = extent_relative_offset % cluster_size;\n\n\n\n    return offset_in_cluster;\n\n}\n", "target": 0}
{"task_id": "defect/train/87", "input": "static unsigned int dec_move_pr(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"move $p%u, $r%u\\n\", dc->op1, dc->op2));\n\n\tcris_cc_mask(dc, 0);\n\n\n\n\tif (dc->op2 == PR_CCS)\n\n\t\tcris_evaluate_flags(dc);\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_gen_mov_TN_preg(t0, dc->op2);\n\n\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t cpu_R[dc->op1], cpu_R[dc->op1], t0, preg_sizes[dc->op2]);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "target": 0}
{"task_id": "defect/train/88", "input": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = virtio_balloon_init_pci;\n\n    k->exit = virtio_balloon_exit_pci;\n\n    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;\n\n    k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;\n\n    k->revision = VIRTIO_PCI_ABI_VERSION;\n\n    k->class_id = PCI_CLASS_MEMORY_RAM;\n\n    dc->alias = \"virtio-balloon\";\n\n    dc->reset = virtio_pci_reset;\n\n    dc->props = virtio_balloon_properties;\n\n}\n", "target": 0}
{"task_id": "defect/train/101", "input": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n\n\n    memset(block, 0, 16 * sizeof(dctcoef));\n\n}\n", "target": 1}
{"task_id": "defect/train/102", "input": "static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque,\n\n                                         uint64_t flags)\n\n{\n\n    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),\n\n                               .type = RDMA_CONTROL_REGISTER_RESULT,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader unreg_resp = { .len = 0,\n\n                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,\n\n                               .repeat = 0,\n\n                             };\n\n    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,\n\n                                 .repeat = 1 };\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMAControlHeader head;\n\n    RDMARegister *reg, *registers;\n\n    RDMACompress *comp;\n\n    RDMARegisterResult *reg_result;\n\n    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];\n\n    RDMALocalBlock *block;\n\n    void *host_addr;\n\n    int ret = 0;\n\n    int idx = 0;\n\n    int count = 0;\n\n    int i = 0;\n\n\n\n    CHECK_ERROR_STATE();\n\n\n\n    do {\n\n        DDDPRINTF(\"Waiting for next request %\" PRIu64 \"...\\n\", flags);\n\n\n\n        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n\n\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n\n            fprintf(stderr, \"rdma: Too many requests in this message (%d).\"\n\n                            \"Bailing.\\n\", head.repeat);\n\n            ret = -EIO;\n\n            break;\n\n        }\n\n\n\n        switch (head.type) {\n\n        case RDMA_CONTROL_COMPRESS:\n\n            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;\n\n            network_to_compress(comp);\n\n\n\n            DDPRINTF(\"Zapping zero chunk: %\" PRId64\n\n                    \" bytes, index %d, offset %\" PRId64 \"\\n\",\n\n                    comp->length, comp->block_idx, comp->offset);\n\n            block = &(rdma->local_ram_blocks.block[comp->block_idx]);\n\n\n\n            host_addr = block->local_host_addr +\n\n                            (comp->offset - block->offset);\n\n\n\n            ram_handle_compressed(host_addr, comp->value, comp->length);\n\n            break;\n\n\n\n        case RDMA_CONTROL_REGISTER_FINISHED:\n\n            DDDPRINTF(\"Current registrations complete.\\n\");\n\n            goto out;\n\n\n\n        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:\n\n            DPRINTF(\"Initial setup info requested.\\n\");\n\n\n\n            if (rdma->pin_all) {\n\n                ret = qemu_rdma_reg_whole_ram_blocks(rdma);\n\n                if (ret) {\n\n                    fprintf(stderr, \"rdma migration: error dest \"\n\n                                    \"registering ram blocks!\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /*\n\n             * Dest uses this to prepare to transmit the RAMBlock descriptions\n\n             * to the source VM after connection setup.\n\n             * Both sides use the \"remote\" structure to communicate and update\n\n             * their \"local\" descriptions with what was sent.\n\n             */\n\n            for (i = 0; i < local->nb_blocks; i++) {\n\n                rdma->block[i].remote_host_addr =\n\n                    (uint64_t)(local->block[i].local_host_addr);\n\n\n\n                if (rdma->pin_all) {\n\n                    rdma->block[i].remote_rkey = local->block[i].mr->rkey;\n\n                }\n\n\n\n                rdma->block[i].offset = local->block[i].offset;\n\n                rdma->block[i].length = local->block[i].length;\n\n\n\n                remote_block_to_network(&rdma->block[i]);\n\n            }\n\n\n\n            blocks.len = rdma->local_ram_blocks.nb_blocks\n\n                                                * sizeof(RDMARemoteBlock);\n\n\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                                        (uint8_t *) rdma->block, &blocks);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"rdma migration: error sending remote info!\\n\");\n\n                goto out;\n\n            }\n\n\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d registration requests\\n\", head.repeat);\n\n\n\n            reg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                uint64_t chunk;\n\n                uint8_t *chunk_start, *chunk_end;\n\n\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                reg_result = &results[count];\n\n\n\n                DDPRINTF(\"Registration request (%d): index %d, current_addr %\"\n\n                         PRIu64 \" chunks: %\" PRIu64 \"\\n\", count,\n\n                         reg->current_index, reg->key.current_addr, reg->chunks);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n                if (block->is_ram_block) {\n\n                    host_addr = (block->local_host_addr +\n\n                                (reg->key.current_addr - block->offset));\n\n                    chunk = ram_chunk_index(block->local_host_addr,\n\n                                            (uint8_t *) host_addr);\n\n                } else {\n\n                    chunk = reg->key.chunk;\n\n                    host_addr = block->local_host_addr +\n\n                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));\n\n                }\n\n                chunk_start = ram_chunk_start(block, chunk);\n\n                chunk_end = ram_chunk_end(block, chunk + reg->chunks);\n\n                if (qemu_rdma_register_and_get_keys(rdma, block,\n\n                            (uint8_t *)host_addr, NULL, &reg_result->rkey,\n\n                            chunk, chunk_start, chunk_end)) {\n\n                    fprintf(stderr, \"cannot get rkey!\\n\");\n\n                    ret = -EINVAL;\n\n                    goto out;\n\n                }\n\n\n\n                reg_result->host_addr = (uint64_t) block->local_host_addr;\n\n\n\n                DDPRINTF(\"Registered rkey for this request: %x\\n\",\n\n                                reg_result->rkey);\n\n\n\n                result_to_network(reg_result);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma,\n\n                            (uint8_t *) results, &reg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_UNREGISTER_REQUEST:\n\n            DDPRINTF(\"There are %d unregistration requests\\n\", head.repeat);\n\n            unreg_resp.repeat = head.repeat;\n\n            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;\n\n\n\n            for (count = 0; count < head.repeat; count++) {\n\n                reg = &registers[count];\n\n                network_to_register(reg);\n\n\n\n                DDPRINTF(\"Unregistration request (%d): \"\n\n                         \" index %d, chunk %\" PRIu64 \"\\n\",\n\n                         count, reg->current_index, reg->key.chunk);\n\n\n\n                block = &(rdma->local_ram_blocks.block[reg->current_index]);\n\n\n\n                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);\n\n                block->pmr[reg->key.chunk] = NULL;\n\n\n\n                if (ret != 0) {\n\n                    perror(\"rdma unregistration chunk failed\");\n\n                    ret = -ret;\n\n                    goto out;\n\n                }\n\n\n\n                rdma->total_registrations--;\n\n\n\n                DDPRINTF(\"Unregistered chunk %\" PRIu64 \" successfully.\\n\",\n\n                            reg->key.chunk);\n\n            }\n\n\n\n            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);\n\n\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Failed to send control buffer!\\n\");\n\n                goto out;\n\n            }\n\n            break;\n\n        case RDMA_CONTROL_REGISTER_RESULT:\n\n            fprintf(stderr, \"Invalid RESULT message at dest.\\n\");\n\n            ret = -EIO;\n\n            goto out;\n\n        default:\n\n            fprintf(stderr, \"Unknown control message %s\\n\",\n\n                                control_desc[head.type]);\n\n            ret = -EIO;\n\n            goto out;\n\n        }\n\n    } while (1);\n\nout:\n\n    if (ret < 0) {\n\n        rdma->error_state = ret;\n\n    }\n\n    return ret;\n\n}\n", "target": 1}
{"task_id": "defect/train/103", "input": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n\n{\n\n    struct playlist *v = opaque;\n\n    HLSContext *c = v->parent->priv_data;\n\n    int ret, i;\n\n    int just_opened = 0;\n\n\n\n\nrestart:\n\n    if (!v->needed)\n\n        return AVERROR_EOF;\n\n\n\n    if (!v->input) {\n\n        int64_t reload_interval;\n\n        struct segment *seg;\n\n\n\n        /* Check that the playlist is still needed before opening a new\n\n         * segment. */\n\n        if (v->ctx && v->ctx->nb_streams) {\n\n            v->needed = 0;\n\n            for (i = 0; i < v->n_main_streams; i++) {\n\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n\n                    v->needed = 1;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        if (!v->needed) {\n\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n\n                v->index);\n\n            return AVERROR_EOF;\n\n        }\n\n\n\n        /* If this is a live stream and the reload interval has elapsed since\n\n         * the last playlist reload, reload the playlists now. */\n\n        reload_interval = default_reload_interval(v);\n\n\n\nreload:\n\n        reload_count++;\n\n        if (reload_count > c->max_reload)\n\n            return AVERROR_EOF;\n\n        if (!v->finished &&\n\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n\n                       v->index);\n\n                return ret;\n\n            }\n\n            /* If we need to reload the playlist again below (if\n\n             * there's still no more segments), switch to a reload\n\n             * interval of half the target duration. */\n\n            reload_interval = v->target_duration / 2;\n\n        }\n\n        if (v->cur_seq_no < v->start_seq_no) {\n\n            av_log(NULL, AV_LOG_WARNING,\n\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n\n                   v->start_seq_no - v->cur_seq_no);\n\n            v->cur_seq_no = v->start_seq_no;\n\n        }\n\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n\n            if (v->finished)\n\n                return AVERROR_EOF;\n\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n\n                if (ff_check_interrupt(c->interrupt_callback))\n\n                    return AVERROR_EXIT;\n\n                av_usleep(100*1000);\n\n            }\n\n            /* Enough time has elapsed since the last reload */\n\n            goto reload;\n\n        }\n\n\n\n        seg = current_segment(v);\n\n\n\n        /* load/update Media Initialization Section, if any */\n\n        ret = update_init_section(v, seg);\n\n        if (ret)\n\n            return ret;\n\n\n\n        ret = open_input(c, v, seg);\n\n        if (ret < 0) {\n\n            if (ff_check_interrupt(c->interrupt_callback))\n\n                return AVERROR_EXIT;\n\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n\n                   v->index);\n\n            v->cur_seq_no += 1;\n\n            goto reload;\n\n        }\n\n        just_opened = 1;\n\n    }\n\n\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n\n        /* Push init section out first before first actual segment */\n\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n\n        memcpy(buf, v->init_sec_buf, copy_size);\n\n        v->init_sec_buf_read_offset += copy_size;\n\n        return copy_size;\n\n    }\n\n\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n\n    if (ret > 0) {\n\n        if (just_opened && v->is_id3_timestamped != 0) {\n\n            /* Intercept ID3 tags here, elementary audio streams are required\n\n             * to convey timestamps using them in the beginning of each segment. */\n\n            intercept_id3(v, buf, buf_size, &ret);\n\n        }\n\n\n\n        return ret;\n\n    }\n\n    ff_format_io_close(v->parent, &v->input);\n\n    v->cur_seq_no++;\n\n\n\n    c->cur_seq_no = v->cur_seq_no;\n\n\n\n    goto restart;\n\n}", "target": 1}
{"task_id": "defect/train/104", "input": "static void put_swf_matrix(ByteIOContext *pb,\n\n                           int a, int b, int c, int d, int tx, int ty)\n\n{\n\n    PutBitContext p;\n\n    uint8_t buf[256];\n\n\n\n    init_put_bits(&p, buf, sizeof(buf));\n\n    \n\n    put_bits(&p, 1, 1); /* a, d present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, a);\n\n    put_bits(&p, 20, d);\n\n    \n\n    put_bits(&p, 1, 1); /* b, c present */\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, c);\n\n    put_bits(&p, 20, b);\n\n\n\n    put_bits(&p, 5, 20); /* nb bits */\n\n    put_bits(&p, 20, tx);\n\n    put_bits(&p, 20, ty);\n\n\n\n    flush_put_bits(&p);\n\n    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);\n\n}\n", "target": 1}
{"task_id": "defect/train/109", "input": "static void device_finalize(Object *obj)\n\n{\n\n    NamedGPIOList *ngl, *next;\n\n\n\n    DeviceState *dev = DEVICE(obj);\n\n    qemu_opts_del(dev->opts);\n\n\n\n    QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) {\n\n        QLIST_REMOVE(ngl, node);\n\n        qemu_free_irqs(ngl->in, ngl->num_in);\n\n        g_free(ngl->name);\n\n        g_free(ngl);\n\n        /* ngl->out irqs are owned by the other end and should not be freed\n\n         * here\n\n         */\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/110", "input": "static int vdi_open(BlockDriverState *bs, QDict *options, int flags,\n\n                    Error **errp)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n    VdiHeader header;\n\n    size_t bmap_size;\n\n    int ret;\n\n\n\n    logout(\"\\n\");\n\n\n\n    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    vdi_header_to_cpu(&header);\n\n#if defined(CONFIG_VDI_DEBUG)\n\n    vdi_header_print(&header);\n\n#endif\n\n\n\n    if (header.disk_size % SECTOR_SIZE != 0) {\n\n        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.\n\n           We accept them but round the disk size to the next multiple of\n\n           SECTOR_SIZE. */\n\n        logout(\"odd disk size %\" PRIu64 \" B, round up\\n\", header.disk_size);\n\n        header.disk_size += SECTOR_SIZE - 1;\n\n        header.disk_size &= ~(SECTOR_SIZE - 1);\n\n    }\n\n\n\n    if (header.signature != VDI_SIGNATURE) {\n\n        error_setg(errp, \"Image not in VDI format (bad signature %08x)\", header.signature);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    } else if (header.version != VDI_VERSION_1_1) {\n\n        error_setg(errp, \"unsupported VDI image (version %u.%u)\",\n\n                   header.version >> 16, header.version & 0xffff);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_bmap % SECTOR_SIZE != 0) {\n\n        /* We only support block maps which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned block map offset \"\n\n                   \"0x%x)\", header.offset_bmap);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.offset_data % SECTOR_SIZE != 0) {\n\n        /* We only support data blocks which start on a sector boundary. */\n\n        error_setg(errp, \"unsupported VDI image (unaligned data offset 0x%x)\",\n\n                   header.offset_data);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.sector_size != SECTOR_SIZE) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.sector_size, SECTOR_SIZE);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.block_size != 1 * MiB) {\n\n        error_setg(errp, \"unsupported VDI image (sector size %u is not %u)\",\n\n                   header.block_size, 1 * MiB);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (header.disk_size >\n\n               (uint64_t)header.blocks_in_image * header.block_size) {\n\n        error_setg(errp, \"unsupported VDI image (disk size %\" PRIu64 \", \"\n\n                   \"image bitmap has room for %\" PRIu64 \")\",\n\n                   header.disk_size,\n\n                   (uint64_t)header.blocks_in_image * header.block_size);\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_link)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL link UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    } else if (!uuid_is_null(header.uuid_parent)) {\n\n        error_setg(errp, \"unsupported VDI image (non-NULL parent UUID)\");\n\n        ret = -ENOTSUP;\n\n        goto fail;\n\n    }\n\n\n\n    bs->total_sectors = header.disk_size / SECTOR_SIZE;\n\n\n\n    s->block_size = header.block_size;\n\n    s->block_sectors = header.block_size / SECTOR_SIZE;\n\n    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;\n\n    s->header = header;\n\n\n\n    bmap_size = header.blocks_in_image * sizeof(uint32_t);\n\n    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);\n\n    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);\n\n    if (ret < 0) {\n\n        goto fail_free_bmap;\n\n    }\n\n\n\n    /* Disable migration when vdi images are used */\n\n    error_set(&s->migration_blocker,\n\n              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,\n\n              \"vdi\", bs->device_name, \"live migration\");\n\n    migrate_add_blocker(s->migration_blocker);\n\n\n\n    return 0;\n\n\n\n fail_free_bmap:\n\n    g_free(s->bmap);\n\n\n\n fail:\n\n    return ret;\n\n}\n", "target": 1}
{"task_id": "defect/train/111", "input": "static void i440fx_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = i440fx_initfn;\n\n    k->config_write = i440fx_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82441;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"Host bridge\";\n\n    dc->no_user = 1;\n\n    dc->vmsd = &vmstate_i440fx;\n\n}\n", "target": 1}
{"task_id": "defect/train/112", "input": "int yuv2rgb_c_init_tables (SwsContext *c, const int inv_table[4], int fullRange, int brightness, int contrast, int saturation)\n\n{\n\n    const int isRgb = isBGR(c->dstFormat);\n\n    const int bpp = fmt_depth(c->dstFormat);\n\n    int i;\n\n    uint8_t table_Y[1024];\n\n    uint32_t *table_32 = 0;\n\n    uint16_t *table_16 = 0;\n\n    uint8_t *table_8 = 0;\n\n    uint8_t *table_332 = 0;\n\n    uint8_t *table_121 = 0;\n\n    uint8_t *table_1 = 0;\n\n    int entry_size = 0;\n\n    void *table_r = 0, *table_g = 0, *table_b = 0;\n\n    void *table_start;\n\n\n\n    int64_t crv =  inv_table[0];\n\n    int64_t cbu =  inv_table[1];\n\n    int64_t cgu = -inv_table[2];\n\n    int64_t cgv = -inv_table[3];\n\n    int64_t cy  = 1<<16;\n\n    int64_t oy  = 0;\n\n\n\n//printf(\"%lld %lld %lld %lld %lld\\n\", cy, crv, cbu, cgu, cgv);\n\n    if(!fullRange){\n\n\tcy= (cy*255) / 219;\n\n\toy= 16<<16;\n\n    }else{\n\n        crv= (crv*224) / 255;\n\n        cbu= (cbu*224) / 255;\n\n        cgu= (cgu*224) / 255;\n\n        cgv= (cgv*224) / 255;\n\n    }\n\n\n\n    cy = (cy *contrast             )>>16;\n\n    crv= (crv*contrast * saturation)>>32;\n\n    cbu= (cbu*contrast * saturation)>>32;\n\n    cgu= (cgu*contrast * saturation)>>32;\n\n    cgv= (cgv*contrast * saturation)>>32;\n\n//printf(\"%lld %lld %lld %lld %lld\\n\", cy, crv, cbu, cgu, cgv);\n\n    oy -= 256*brightness;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n\tint j;\n\n\n\n\tj= (cy*(((i - 384)<<16) - oy) + (1<<31))>>32;\n\n\tj = (j < 0) ? 0 : ((j > 255) ? 255 : j);\n\n\ttable_Y[i] = j;\n\n    }\n\n\n\n    switch (bpp) {\n\n    case 32:\n\n\ttable_start= table_32 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint32_t));\n\n\n\n\tentry_size = sizeof (uint32_t);\n\n\ttable_r = table_32 + 197;\n\n\ttable_b = table_32 + 197 + 685;\n\n\ttable_g = table_32 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++)\n\n\t    ((uint32_t *)table_r)[i] = table_Y[i+384] << (isRgb ? 16 : 0);\n\n\tfor (i = -132; i < 256+132; i++)\n\n\t    ((uint32_t *)table_g)[i] = table_Y[i+384] << 8;\n\n\tfor (i = -232; i < 256+232; i++)\n\n\t    ((uint32_t *)table_b)[i] = table_Y[i+384] << (isRgb ? 0 : 16);\n\n\tbreak;\n\n\n\n    case 24:\n\n\ttable_start= table_8 = av_malloc ((256 + 2*232) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_g = table_b = table_8 + 232;\n\n\n\n\tfor (i = -232; i < 256+232; i++)\n\n\t    ((uint8_t * )table_b)[i] = table_Y[i+384];\n\n\tbreak;\n\n\n\n    case 15:\n\n    case 16:\n\n\ttable_start= table_16 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint16_t));\n\n\n\n\tentry_size = sizeof (uint16_t);\n\n\ttable_r = table_16 + 197;\n\n\ttable_b = table_16 + 197 + 685;\n\n\ttable_g = table_16 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = table_Y[i+384] >> 3;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= ((bpp==16) ? 11 : 10);\n\n\n\n\t    ((uint16_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = table_Y[i+384] >> ((bpp==16) ? 2 : 3);\n\n\n\n\t    ((uint16_t *)table_g)[i] = j << 5;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j = table_Y[i+384] >> 3;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= ((bpp==16) ? 11 : 10);\n\n\n\n\t    ((uint16_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    case 8:\n\n\ttable_start= table_332 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_332 + 197;\n\n\ttable_b = table_332 + 197 + 685;\n\n\ttable_g = table_332 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = (table_Y[i+384 - 16] + 18)/36;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= 5;\n\n\n\n\t    ((uint8_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = (table_Y[i+384 - 16] + 18)/36;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 1;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j << 2;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j = (table_Y[i+384 - 37] + 43)/85;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 6;\n\n\n\n\t    ((uint8_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n    case 4:\n\n    case 4|128:\n\n\ttable_start= table_121 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_r = table_121 + 197;\n\n\ttable_b = table_121 + 197 + 685;\n\n\ttable_g = table_121 + 197 + 2*682;\n\n\n\n\tfor (i = -197; i < 256+197; i++) {\n\n\t    int j = table_Y[i+384 - 110] >> 7;\n\n\n\n\t    if (isRgb)\n\n\t\tj <<= 3;\n\n\n\n\t    ((uint8_t *)table_r)[i] = j;\n\n\t}\n\n\tfor (i = -132; i < 256+132; i++) {\n\n\t    int j = (table_Y[i+384 - 37]+ 43)/85;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j << 1;\n\n\t}\n\n\tfor (i = -232; i < 256+232; i++) {\n\n\t    int j =table_Y[i+384 - 110] >> 7;\n\n\n\n\t    if (!isRgb)\n\n\t\tj <<= 3;\n\n\n\n\t    ((uint8_t *)table_b)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    case 1:\n\n\ttable_start= table_1 = av_malloc (256*2 * sizeof (uint8_t));\n\n\n\n\tentry_size = sizeof (uint8_t);\n\n\ttable_g = table_1;\n\n\ttable_r = table_b = NULL;\n\n\n\n\tfor (i = 0; i < 256+256; i++) {\n\n\t    int j = table_Y[i + 384 - 110]>>7;\n\n\n\n\t    ((uint8_t *)table_g)[i] = j;\n\n\t}\n\n\tbreak;\n\n\n\n    default:\n\n\ttable_start= NULL;\n\n\tav_log(c, AV_LOG_ERROR, \"%ibpp not supported by yuv2rgb\\n\", bpp);\n\n\t//free mem?\n\n\treturn -1;\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n\tc->table_rV[i] = (uint8_t *)table_r + entry_size * div_round (crv * (i-128), 76309);\n\n\tc->table_gU[i] = (uint8_t *)table_g + entry_size * div_round (cgu * (i-128), 76309);\n\n\tc->table_gV[i] = entry_size * div_round (cgv * (i-128), 76309);\n\n\tc->table_bU[i] = (uint8_t *)table_b + entry_size * div_round (cbu * (i-128), 76309);\n\n    }\n\n\n\n    av_free(c->yuvTable);\n\n    c->yuvTable= table_start;\n\n    return 0;\n\n}\n", "target": 1}
{"task_id": "defect/train/113", "input": "target_ulong helper_udiv(target_ulong a, target_ulong b)\n\n{\n\n    uint64_t x0;\n\n    uint32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if (x0 > 0xffffffff) {\n\n        env->cc_src2 = 1;\n\n        return 0xffffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "target": 1}
{"task_id": "defect/train/114", "input": "static direntry_t *create_short_filename(BDRVVVFATState *s,\n\n                                         const char *filename,\n\n                                         unsigned int directory_start)\n\n{\n\n    int i, j = 0;\n\n    direntry_t *entry = array_get_next(&(s->directory));\n\n    const gchar *p, *last_dot = NULL;\n\n    gunichar c;\n\n    bool lossy_conversion = false;\n\n    char tail[11];\n\n\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n    memset(entry->name, 0x20, sizeof(entry->name));\n\n\n\n    /* copy filename and search last dot */\n\n    for (p = filename; ; p = g_utf8_next_char(p)) {\n\n        c = g_utf8_get_char(p);\n\n        if (c == '\\0') {\n\n            break;\n\n        } else if (c == '.') {\n\n            if (j == 0) {\n\n                /* '.' at start of filename */\n\n                lossy_conversion = true;\n\n            } else {\n\n                if (last_dot) {\n\n                    lossy_conversion = true;\n\n                }\n\n                last_dot = p;\n\n            }\n\n        } else if (!last_dot) {\n\n            /* first part of the name; copy it */\n\n            uint8_t v = to_valid_short_char(c);\n\n            if (j < 8 && v) {\n\n                entry->name[j++] = v;\n\n            } else {\n\n                lossy_conversion = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* copy extension (if any) */\n\n    if (last_dot) {\n\n        j = 0;\n\n        for (p = g_utf8_next_char(last_dot); ; p = g_utf8_next_char(p)) {\n\n            c = g_utf8_get_char(p);\n\n            if (c == '\\0') {\n\n                break;\n\n            } else {\n\n                /* extension; copy it */\n\n                uint8_t v = to_valid_short_char(c);\n\n                if (j < 3 && v) {\n\n                    entry->name[8 + (j++)] = v;\n\n                } else {\n\n                    lossy_conversion = true;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (entry->name[0] == DIR_KANJI) {\n\n        entry->name[0] = DIR_KANJI_FAKE;\n\n    }\n\n\n\n    /* numeric-tail generation */\n\n    for (j = 0; j < 8; j++) {\n\n        if (entry->name[j] == ' ') {\n\n            break;\n\n        }\n\n    }\n\n    for (i = lossy_conversion ? 1 : 0; i < 999999; i++) {\n\n        direntry_t *entry1;\n\n        if (i > 0) {\n\n            int len = sprintf(tail, \"~%d\", i);\n\n            memcpy(entry->name + MIN(j, 8 - len), tail, len);\n\n        }\n\n        for (entry1 = array_get(&(s->directory), directory_start);\n\n             entry1 < entry; entry1++) {\n\n            if (!is_long_name(entry1) &&\n\n                !memcmp(entry1->name, entry->name, 11)) {\n\n                break; /* found dupe */\n\n            }\n\n        }\n\n        if (entry1 == entry) {\n\n            /* no dupe found */\n\n            return entry;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "target": 1}
{"task_id": "defect/train/115", "input": "void ff_print_debug_info(MpegEncContext *s, Picture *p)\n\n{\n\n    AVFrame *pict;\n\n    if (s->avctx->hwaccel || !p || !p->mb_type)\n\n        return;\n\n    pict = &p->f;\n\n\n\n    if (s->avctx->debug & (FF_DEBUG_SKIP | FF_DEBUG_QP | FF_DEBUG_MB_TYPE)) {\n\n        int x,y;\n\n\n\n        av_log(s->avctx,AV_LOG_DEBUG,\"New frame, type: \");\n\n        switch (pict->pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"I\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"P\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"B\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_S:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"S\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_SI:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"SI\\n\");\n\n            break;\n\n        case AV_PICTURE_TYPE_SP:\n\n            av_log(s->avctx,AV_LOG_DEBUG,\"SP\\n\");\n\n            break;\n\n        }\n\n        for (y = 0; y < s->mb_height; y++) {\n\n            for (x = 0; x < s->mb_width; x++) {\n\n                if (s->avctx->debug & FF_DEBUG_SKIP) {\n\n                    int count = s->mbskip_table[x + y * s->mb_stride];\n\n                    if (count > 9)\n\n                        count = 9;\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"%1d\", count);\n\n                }\n\n                if (s->avctx->debug & FF_DEBUG_QP) {\n\n                    av_log(s->avctx, AV_LOG_DEBUG, \"%2d\",\n\n                           p->qscale_table[x + y * s->mb_stride]);\n\n                }\n\n                if (s->avctx->debug & FF_DEBUG_MB_TYPE) {\n\n                    int mb_type = p->mb_type[x + y * s->mb_stride];\n\n                    // Type & MV direction\n\n                    if (IS_PCM(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"P\");\n\n                    else if (IS_INTRA(mb_type) && IS_ACPRED(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"A\");\n\n                    else if (IS_INTRA4x4(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"i\");\n\n                    else if (IS_INTRA16x16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"I\");\n\n                    else if (IS_DIRECT(mb_type) && IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"d\");\n\n                    else if (IS_DIRECT(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"D\");\n\n                    else if (IS_GMC(mb_type) && IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"g\");\n\n                    else if (IS_GMC(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"G\");\n\n                    else if (IS_SKIP(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"S\");\n\n                    else if (!USES_LIST(mb_type, 1))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \">\");\n\n                    else if (!USES_LIST(mb_type, 0))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"<\");\n\n                    else {\n\n                        assert(USES_LIST(mb_type, 0) && USES_LIST(mb_type, 1));\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"X\");\n\n                    }\n\n\n\n                    // segmentation\n\n                    if (IS_8X8(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"+\");\n\n                    else if (IS_16X8(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"-\");\n\n                    else if (IS_8X16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"|\");\n\n                    else if (IS_INTRA(mb_type) || IS_16X16(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \" \");\n\n                    else\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"?\");\n\n\n\n\n\n                    if (IS_INTERLACED(mb_type))\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \"=\");\n\n                    else\n\n                        av_log(s->avctx, AV_LOG_DEBUG, \" \");\n\n                }\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n        }\n\n    }\n\n}\n", "target": 1}
